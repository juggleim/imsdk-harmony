/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import { index } from "@ohos/protobufjs";
const $protobuf = index;
import Long from 'long';
$protobuf.util.Long=Long
$protobuf.configure()

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const immessage = $root.immessage = (() => {

    /**
     * Namespace immessage.
     * @exports immessage
     * @namespace
     */
    const immessage = {};

    immessage.Nil = (function() {

        /**
         * Properties of a Nil.
         * @memberof immessage
         * @interface INil
         */

        /**
         * Constructs a new Nil.
         * @memberof immessage
         * @classdesc Represents a Nil.
         * @implements INil
         * @constructor
         * @param {immessage.INil=} [properties] Properties to set
         */
        function Nil(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Nil instance using the specified properties.
         * @function create
         * @memberof immessage.Nil
         * @static
         * @param {immessage.INil=} [properties] Properties to set
         * @returns {immessage.Nil} Nil instance
         */
        Nil.create = function create(properties) {
            return new Nil(properties);
        };

        /**
         * Encodes the specified Nil message. Does not implicitly {@link immessage.Nil.verify|verify} messages.
         * @function encode
         * @memberof immessage.Nil
         * @static
         * @param {immessage.INil} message Nil message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Nil.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Nil message, length delimited. Does not implicitly {@link immessage.Nil.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.Nil
         * @static
         * @param {immessage.INil} message Nil message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Nil.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Nil message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.Nil
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.Nil} Nil
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Nil.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.Nil();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Nil message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.Nil
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.Nil} Nil
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Nil.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Nil message.
         * @function verify
         * @memberof immessage.Nil
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Nil.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Nil message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.Nil
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.Nil} Nil
         */
        Nil.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.Nil)
                return object;
            return new $root.immessage.Nil();
        };

        /**
         * Creates a plain object from a Nil message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.Nil
         * @static
         * @param {immessage.Nil} message Nil
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Nil.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Nil to JSON.
         * @function toJSON
         * @memberof immessage.Nil
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Nil.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Nil
         * @function getTypeUrl
         * @memberof immessage.Nil
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Nil.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.Nil";
        };

        return Nil;
    })();

    immessage.UpMsg = (function() {

        /**
         * Properties of an UpMsg.
         * @memberof immessage
         * @interface IUpMsg
         * @property {string|null} [msgType] UpMsg msgType
         * @property {Uint8Array|null} [msgContent] UpMsg msgContent
         * @property {number|null} [flags] UpMsg flags
         * @property {string|null} [clientUid] UpMsg clientUid
         * @property {immessage.IPushData|null} [pushData] UpMsg pushData
         * @property {immessage.IMentionInfo|null} [mentionInfo] UpMsg mentionInfo
         * @property {immessage.IDownMsg|null} [referMsg] UpMsg referMsg
         * @property {Array.<string>|null} [toUserIds] UpMsg toUserIds
         * @property {immessage.IMergedMsgs|null} [mergedMsgs] UpMsg mergedMsgs
         * @property {string|null} [SearchText] UpMsg SearchText
         * @property {number|Long|null} [msgTime] UpMsg msgTime
         */

        /**
         * Constructs a new UpMsg.
         * @memberof immessage
         * @classdesc Represents an UpMsg.
         * @implements IUpMsg
         * @constructor
         * @param {immessage.IUpMsg=} [properties] Properties to set
         */
        function UpMsg(properties) {
            this.toUserIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpMsg msgType.
         * @member {string} msgType
         * @memberof immessage.UpMsg
         * @instance
         */
        UpMsg.prototype.msgType = "";

        /**
         * UpMsg msgContent.
         * @member {Uint8Array} msgContent
         * @memberof immessage.UpMsg
         * @instance
         */
        UpMsg.prototype.msgContent = $util.newBuffer([]);

        /**
         * UpMsg flags.
         * @member {number} flags
         * @memberof immessage.UpMsg
         * @instance
         */
        UpMsg.prototype.flags = 0;

        /**
         * UpMsg clientUid.
         * @member {string} clientUid
         * @memberof immessage.UpMsg
         * @instance
         */
        UpMsg.prototype.clientUid = "";

        /**
         * UpMsg pushData.
         * @member {immessage.IPushData|null|undefined} pushData
         * @memberof immessage.UpMsg
         * @instance
         */
        UpMsg.prototype.pushData = null;

        /**
         * UpMsg mentionInfo.
         * @member {immessage.IMentionInfo|null|undefined} mentionInfo
         * @memberof immessage.UpMsg
         * @instance
         */
        UpMsg.prototype.mentionInfo = null;

        /**
         * UpMsg referMsg.
         * @member {immessage.IDownMsg|null|undefined} referMsg
         * @memberof immessage.UpMsg
         * @instance
         */
        UpMsg.prototype.referMsg = null;

        /**
         * UpMsg toUserIds.
         * @member {Array.<string>} toUserIds
         * @memberof immessage.UpMsg
         * @instance
         */
        UpMsg.prototype.toUserIds = $util.emptyArray;

        /**
         * UpMsg mergedMsgs.
         * @member {immessage.IMergedMsgs|null|undefined} mergedMsgs
         * @memberof immessage.UpMsg
         * @instance
         */
        UpMsg.prototype.mergedMsgs = null;

        /**
         * UpMsg SearchText.
         * @member {string} SearchText
         * @memberof immessage.UpMsg
         * @instance
         */
        UpMsg.prototype.SearchText = "";

        /**
         * UpMsg msgTime.
         * @member {number|Long} msgTime
         * @memberof immessage.UpMsg
         * @instance
         */
        UpMsg.prototype.msgTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UpMsg instance using the specified properties.
         * @function create
         * @memberof immessage.UpMsg
         * @static
         * @param {immessage.IUpMsg=} [properties] Properties to set
         * @returns {immessage.UpMsg} UpMsg instance
         */
        UpMsg.create = function create(properties) {
            return new UpMsg(properties);
        };

        /**
         * Encodes the specified UpMsg message. Does not implicitly {@link immessage.UpMsg.verify|verify} messages.
         * @function encode
         * @memberof immessage.UpMsg
         * @static
         * @param {immessage.IUpMsg} message UpMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msgType != null && Object.hasOwnProperty.call(message, "msgType"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.msgType);
            if (message.msgContent != null && Object.hasOwnProperty.call(message, "msgContent"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.msgContent);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.flags);
            if (message.clientUid != null && Object.hasOwnProperty.call(message, "clientUid"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.clientUid);
            if (message.pushData != null && Object.hasOwnProperty.call(message, "pushData"))
                $root.immessage.PushData.encode(message.pushData, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.mentionInfo != null && Object.hasOwnProperty.call(message, "mentionInfo"))
                $root.immessage.MentionInfo.encode(message.mentionInfo, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.referMsg != null && Object.hasOwnProperty.call(message, "referMsg"))
                $root.immessage.DownMsg.encode(message.referMsg, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.toUserIds != null && message.toUserIds.length)
                for (let i = 0; i < message.toUserIds.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.toUserIds[i]);
            if (message.mergedMsgs != null && Object.hasOwnProperty.call(message, "mergedMsgs"))
                $root.immessage.MergedMsgs.encode(message.mergedMsgs, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.SearchText != null && Object.hasOwnProperty.call(message, "SearchText"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.SearchText);
            if (message.msgTime != null && Object.hasOwnProperty.call(message, "msgTime"))
                writer.uint32(/* id 51, wireType 0 =*/408).int64(message.msgTime);
            return writer;
        };

        /**
         * Encodes the specified UpMsg message, length delimited. Does not implicitly {@link immessage.UpMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UpMsg
         * @static
         * @param {immessage.IUpMsg} message UpMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpMsg message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UpMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UpMsg} UpMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UpMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.msgType = reader.string();
                        break;
                    }
                case 2: {
                        message.msgContent = reader.bytes();
                        break;
                    }
                case 3: {
                        message.flags = reader.int32();
                        break;
                    }
                case 4: {
                        message.clientUid = reader.string();
                        break;
                    }
                case 5: {
                        message.pushData = $root.immessage.PushData.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.mentionInfo = $root.immessage.MentionInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.referMsg = $root.immessage.DownMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        if (!(message.toUserIds && message.toUserIds.length))
                            message.toUserIds = [];
                        message.toUserIds.push(reader.string());
                        break;
                    }
                case 9: {
                        message.mergedMsgs = $root.immessage.MergedMsgs.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.SearchText = reader.string();
                        break;
                    }
                case 51: {
                        message.msgTime = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UpMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UpMsg} UpMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpMsg message.
         * @function verify
         * @memberof immessage.UpMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msgType != null && message.hasOwnProperty("msgType"))
                if (!$util.isString(message.msgType))
                    return "msgType: string expected";
            if (message.msgContent != null && message.hasOwnProperty("msgContent"))
                if (!(message.msgContent && typeof message.msgContent.length === "number" || $util.isString(message.msgContent)))
                    return "msgContent: buffer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.clientUid != null && message.hasOwnProperty("clientUid"))
                if (!$util.isString(message.clientUid))
                    return "clientUid: string expected";
            if (message.pushData != null && message.hasOwnProperty("pushData")) {
                let error = $root.immessage.PushData.verify(message.pushData);
                if (error)
                    return "pushData." + error;
            }
            if (message.mentionInfo != null && message.hasOwnProperty("mentionInfo")) {
                let error = $root.immessage.MentionInfo.verify(message.mentionInfo);
                if (error)
                    return "mentionInfo." + error;
            }
            if (message.referMsg != null && message.hasOwnProperty("referMsg")) {
                let error = $root.immessage.DownMsg.verify(message.referMsg);
                if (error)
                    return "referMsg." + error;
            }
            if (message.toUserIds != null && message.hasOwnProperty("toUserIds")) {
                if (!Array.isArray(message.toUserIds))
                    return "toUserIds: array expected";
                for (let i = 0; i < message.toUserIds.length; ++i)
                    if (!$util.isString(message.toUserIds[i]))
                        return "toUserIds: string[] expected";
            }
            if (message.mergedMsgs != null && message.hasOwnProperty("mergedMsgs")) {
                let error = $root.immessage.MergedMsgs.verify(message.mergedMsgs);
                if (error)
                    return "mergedMsgs." + error;
            }
            if (message.SearchText != null && message.hasOwnProperty("SearchText"))
                if (!$util.isString(message.SearchText))
                    return "SearchText: string expected";
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (!$util.isInteger(message.msgTime) && !(message.msgTime && $util.isInteger(message.msgTime.low) && $util.isInteger(message.msgTime.high)))
                    return "msgTime: integer|Long expected";
            return null;
        };

        /**
         * Creates an UpMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UpMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UpMsg} UpMsg
         */
        UpMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UpMsg)
                return object;
            let message = new $root.immessage.UpMsg();
            if (object.msgType != null)
                message.msgType = String(object.msgType);
            if (object.msgContent != null)
                if (typeof object.msgContent === "string")
                    $util.base64.decode(object.msgContent, message.msgContent = $util.newBuffer($util.base64.length(object.msgContent)), 0);
                else if (object.msgContent.length >= 0)
                    message.msgContent = object.msgContent;
            if (object.flags != null)
                message.flags = object.flags | 0;
            if (object.clientUid != null)
                message.clientUid = String(object.clientUid);
            if (object.pushData != null) {
                if (typeof object.pushData !== "object")
                    throw TypeError(".immessage.UpMsg.pushData: object expected");
                message.pushData = $root.immessage.PushData.fromObject(object.pushData);
            }
            if (object.mentionInfo != null) {
                if (typeof object.mentionInfo !== "object")
                    throw TypeError(".immessage.UpMsg.mentionInfo: object expected");
                message.mentionInfo = $root.immessage.MentionInfo.fromObject(object.mentionInfo);
            }
            if (object.referMsg != null) {
                if (typeof object.referMsg !== "object")
                    throw TypeError(".immessage.UpMsg.referMsg: object expected");
                message.referMsg = $root.immessage.DownMsg.fromObject(object.referMsg);
            }
            if (object.toUserIds) {
                if (!Array.isArray(object.toUserIds))
                    throw TypeError(".immessage.UpMsg.toUserIds: array expected");
                message.toUserIds = [];
                for (let i = 0; i < object.toUserIds.length; ++i)
                    message.toUserIds[i] = String(object.toUserIds[i]);
            }
            if (object.mergedMsgs != null) {
                if (typeof object.mergedMsgs !== "object")
                    throw TypeError(".immessage.UpMsg.mergedMsgs: object expected");
                message.mergedMsgs = $root.immessage.MergedMsgs.fromObject(object.mergedMsgs);
            }
            if (object.SearchText != null)
                message.SearchText = String(object.SearchText);
            if (object.msgTime != null)
                if ($util.Long)
                    (message.msgTime = $util.Long.fromValue(object.msgTime)).unsigned = false;
                else if (typeof object.msgTime === "string")
                    message.msgTime = parseInt(object.msgTime, 10);
                else if (typeof object.msgTime === "number")
                    message.msgTime = object.msgTime;
                else if (typeof object.msgTime === "object")
                    message.msgTime = new $util.LongBits(object.msgTime.low >>> 0, object.msgTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an UpMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UpMsg
         * @static
         * @param {immessage.UpMsg} message UpMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.toUserIds = [];
            if (options.defaults) {
                object.msgType = "";
                if (options.bytes === String)
                    object.msgContent = "";
                else {
                    object.msgContent = [];
                    if (options.bytes !== Array)
                        object.msgContent = $util.newBuffer(object.msgContent);
                }
                object.flags = 0;
                object.clientUid = "";
                object.pushData = null;
                object.mentionInfo = null;
                object.referMsg = null;
                object.mergedMsgs = null;
                object.SearchText = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.msgTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msgTime = options.longs === String ? "0" : 0;
            }
            if (message.msgType != null && message.hasOwnProperty("msgType"))
                object.msgType = message.msgType;
            if (message.msgContent != null && message.hasOwnProperty("msgContent"))
                object.msgContent = options.bytes === String ? $util.base64.encode(message.msgContent, 0, message.msgContent.length) : options.bytes === Array ? Array.prototype.slice.call(message.msgContent) : message.msgContent;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.clientUid != null && message.hasOwnProperty("clientUid"))
                object.clientUid = message.clientUid;
            if (message.pushData != null && message.hasOwnProperty("pushData"))
                object.pushData = $root.immessage.PushData.toObject(message.pushData, options);
            if (message.mentionInfo != null && message.hasOwnProperty("mentionInfo"))
                object.mentionInfo = $root.immessage.MentionInfo.toObject(message.mentionInfo, options);
            if (message.referMsg != null && message.hasOwnProperty("referMsg"))
                object.referMsg = $root.immessage.DownMsg.toObject(message.referMsg, options);
            if (message.toUserIds && message.toUserIds.length) {
                object.toUserIds = [];
                for (let j = 0; j < message.toUserIds.length; ++j)
                    object.toUserIds[j] = message.toUserIds[j];
            }
            if (message.mergedMsgs != null && message.hasOwnProperty("mergedMsgs"))
                object.mergedMsgs = $root.immessage.MergedMsgs.toObject(message.mergedMsgs, options);
            if (message.SearchText != null && message.hasOwnProperty("SearchText"))
                object.SearchText = message.SearchText;
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (typeof message.msgTime === "number")
                    object.msgTime = options.longs === String ? String(message.msgTime) : message.msgTime;
                else
                    object.msgTime = options.longs === String ? $util.Long.prototype.toString.call(message.msgTime) : options.longs === Number ? new $util.LongBits(message.msgTime.low >>> 0, message.msgTime.high >>> 0).toNumber() : message.msgTime;
            return object;
        };

        /**
         * Converts this UpMsg to JSON.
         * @function toJSON
         * @memberof immessage.UpMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UpMsg
         * @function getTypeUrl
         * @memberof immessage.UpMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UpMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UpMsg";
        };

        return UpMsg;
    })();

    immessage.MergedMsgs = (function() {

        /**
         * Properties of a MergedMsgs.
         * @memberof immessage
         * @interface IMergedMsgs
         * @property {immessage.ChannelType|null} [channelType] MergedMsgs channelType
         * @property {string|null} [userId] MergedMsgs userId
         * @property {string|null} [targetId] MergedMsgs targetId
         * @property {Array.<immessage.ISimpleMsg>|null} [msgs] MergedMsgs msgs
         */

        /**
         * Constructs a new MergedMsgs.
         * @memberof immessage
         * @classdesc Represents a MergedMsgs.
         * @implements IMergedMsgs
         * @constructor
         * @param {immessage.IMergedMsgs=} [properties] Properties to set
         */
        function MergedMsgs(properties) {
            this.msgs = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MergedMsgs channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.MergedMsgs
         * @instance
         */
        MergedMsgs.prototype.channelType = 0;

        /**
         * MergedMsgs userId.
         * @member {string} userId
         * @memberof immessage.MergedMsgs
         * @instance
         */
        MergedMsgs.prototype.userId = "";

        /**
         * MergedMsgs targetId.
         * @member {string} targetId
         * @memberof immessage.MergedMsgs
         * @instance
         */
        MergedMsgs.prototype.targetId = "";

        /**
         * MergedMsgs msgs.
         * @member {Array.<immessage.ISimpleMsg>} msgs
         * @memberof immessage.MergedMsgs
         * @instance
         */
        MergedMsgs.prototype.msgs = $util.emptyArray;

        /**
         * Creates a new MergedMsgs instance using the specified properties.
         * @function create
         * @memberof immessage.MergedMsgs
         * @static
         * @param {immessage.IMergedMsgs=} [properties] Properties to set
         * @returns {immessage.MergedMsgs} MergedMsgs instance
         */
        MergedMsgs.create = function create(properties) {
            return new MergedMsgs(properties);
        };

        /**
         * Encodes the specified MergedMsgs message. Does not implicitly {@link immessage.MergedMsgs.verify|verify} messages.
         * @function encode
         * @memberof immessage.MergedMsgs
         * @static
         * @param {immessage.IMergedMsgs} message MergedMsgs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MergedMsgs.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.channelType);
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.userId);
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.targetId);
            if (message.msgs != null && message.msgs.length)
                for (let i = 0; i < message.msgs.length; ++i)
                    $root.immessage.SimpleMsg.encode(message.msgs[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MergedMsgs message, length delimited. Does not implicitly {@link immessage.MergedMsgs.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.MergedMsgs
         * @static
         * @param {immessage.IMergedMsgs} message MergedMsgs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MergedMsgs.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MergedMsgs message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.MergedMsgs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.MergedMsgs} MergedMsgs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MergedMsgs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.MergedMsgs();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 2: {
                        message.userId = reader.string();
                        break;
                    }
                case 3: {
                        message.targetId = reader.string();
                        break;
                    }
                case 4: {
                        if (!(message.msgs && message.msgs.length))
                            message.msgs = [];
                        message.msgs.push($root.immessage.SimpleMsg.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MergedMsgs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.MergedMsgs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.MergedMsgs} MergedMsgs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MergedMsgs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MergedMsgs message.
         * @function verify
         * @memberof immessage.MergedMsgs
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MergedMsgs.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.msgs != null && message.hasOwnProperty("msgs")) {
                if (!Array.isArray(message.msgs))
                    return "msgs: array expected";
                for (let i = 0; i < message.msgs.length; ++i) {
                    let error = $root.immessage.SimpleMsg.verify(message.msgs[i]);
                    if (error)
                        return "msgs." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MergedMsgs message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.MergedMsgs
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.MergedMsgs} MergedMsgs
         */
        MergedMsgs.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.MergedMsgs)
                return object;
            let message = new $root.immessage.MergedMsgs();
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            if (object.msgs) {
                if (!Array.isArray(object.msgs))
                    throw TypeError(".immessage.MergedMsgs.msgs: array expected");
                message.msgs = [];
                for (let i = 0; i < object.msgs.length; ++i) {
                    if (typeof object.msgs[i] !== "object")
                        throw TypeError(".immessage.MergedMsgs.msgs: object expected");
                    message.msgs[i] = $root.immessage.SimpleMsg.fromObject(object.msgs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MergedMsgs message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.MergedMsgs
         * @static
         * @param {immessage.MergedMsgs} message MergedMsgs
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MergedMsgs.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.msgs = [];
            if (options.defaults) {
                object.channelType = options.enums === String ? "Unknown" : 0;
                object.userId = "";
                object.targetId = "";
            }
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.msgs && message.msgs.length) {
                object.msgs = [];
                for (let j = 0; j < message.msgs.length; ++j)
                    object.msgs[j] = $root.immessage.SimpleMsg.toObject(message.msgs[j], options);
            }
            return object;
        };

        /**
         * Converts this MergedMsgs to JSON.
         * @function toJSON
         * @memberof immessage.MergedMsgs
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MergedMsgs.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MergedMsgs
         * @function getTypeUrl
         * @memberof immessage.MergedMsgs
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MergedMsgs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.MergedMsgs";
        };

        return MergedMsgs;
    })();

    immessage.MentionInfo = (function() {

        /**
         * Properties of a MentionInfo.
         * @memberof immessage
         * @interface IMentionInfo
         * @property {immessage.MentionType|null} [mentionType] MentionInfo mentionType
         * @property {Array.<immessage.IUserInfo>|null} [targetUsers] MentionInfo targetUsers
         */

        /**
         * Constructs a new MentionInfo.
         * @memberof immessage
         * @classdesc Represents a MentionInfo.
         * @implements IMentionInfo
         * @constructor
         * @param {immessage.IMentionInfo=} [properties] Properties to set
         */
        function MentionInfo(properties) {
            this.targetUsers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MentionInfo mentionType.
         * @member {immessage.MentionType} mentionType
         * @memberof immessage.MentionInfo
         * @instance
         */
        MentionInfo.prototype.mentionType = 0;

        /**
         * MentionInfo targetUsers.
         * @member {Array.<immessage.IUserInfo>} targetUsers
         * @memberof immessage.MentionInfo
         * @instance
         */
        MentionInfo.prototype.targetUsers = $util.emptyArray;

        /**
         * Creates a new MentionInfo instance using the specified properties.
         * @function create
         * @memberof immessage.MentionInfo
         * @static
         * @param {immessage.IMentionInfo=} [properties] Properties to set
         * @returns {immessage.MentionInfo} MentionInfo instance
         */
        MentionInfo.create = function create(properties) {
            return new MentionInfo(properties);
        };

        /**
         * Encodes the specified MentionInfo message. Does not implicitly {@link immessage.MentionInfo.verify|verify} messages.
         * @function encode
         * @memberof immessage.MentionInfo
         * @static
         * @param {immessage.IMentionInfo} message MentionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MentionInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mentionType != null && Object.hasOwnProperty.call(message, "mentionType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mentionType);
            if (message.targetUsers != null && message.targetUsers.length)
                for (let i = 0; i < message.targetUsers.length; ++i)
                    $root.immessage.UserInfo.encode(message.targetUsers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MentionInfo message, length delimited. Does not implicitly {@link immessage.MentionInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.MentionInfo
         * @static
         * @param {immessage.IMentionInfo} message MentionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MentionInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MentionInfo message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.MentionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.MentionInfo} MentionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MentionInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.MentionInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.mentionType = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.targetUsers && message.targetUsers.length))
                            message.targetUsers = [];
                        message.targetUsers.push($root.immessage.UserInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MentionInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.MentionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.MentionInfo} MentionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MentionInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MentionInfo message.
         * @function verify
         * @memberof immessage.MentionInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MentionInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mentionType != null && message.hasOwnProperty("mentionType"))
                switch (message.mentionType) {
                default:
                    return "mentionType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.targetUsers != null && message.hasOwnProperty("targetUsers")) {
                if (!Array.isArray(message.targetUsers))
                    return "targetUsers: array expected";
                for (let i = 0; i < message.targetUsers.length; ++i) {
                    let error = $root.immessage.UserInfo.verify(message.targetUsers[i]);
                    if (error)
                        return "targetUsers." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MentionInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.MentionInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.MentionInfo} MentionInfo
         */
        MentionInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.MentionInfo)
                return object;
            let message = new $root.immessage.MentionInfo();
            switch (object.mentionType) {
            default:
                if (typeof object.mentionType === "number") {
                    message.mentionType = object.mentionType;
                    break;
                }
                break;
            case "MentionDefault":
            case 0:
                message.mentionType = 0;
                break;
            case "All":
            case 1:
                message.mentionType = 1;
                break;
            case "Someone":
            case 2:
                message.mentionType = 2;
                break;
            case "AllAndSomeone":
            case 3:
                message.mentionType = 3;
                break;
            }
            if (object.targetUsers) {
                if (!Array.isArray(object.targetUsers))
                    throw TypeError(".immessage.MentionInfo.targetUsers: array expected");
                message.targetUsers = [];
                for (let i = 0; i < object.targetUsers.length; ++i) {
                    if (typeof object.targetUsers[i] !== "object")
                        throw TypeError(".immessage.MentionInfo.targetUsers: object expected");
                    message.targetUsers[i] = $root.immessage.UserInfo.fromObject(object.targetUsers[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MentionInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.MentionInfo
         * @static
         * @param {immessage.MentionInfo} message MentionInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MentionInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.targetUsers = [];
            if (options.defaults)
                object.mentionType = options.enums === String ? "MentionDefault" : 0;
            if (message.mentionType != null && message.hasOwnProperty("mentionType"))
                object.mentionType = options.enums === String ? $root.immessage.MentionType[message.mentionType] === undefined ? message.mentionType : $root.immessage.MentionType[message.mentionType] : message.mentionType;
            if (message.targetUsers && message.targetUsers.length) {
                object.targetUsers = [];
                for (let j = 0; j < message.targetUsers.length; ++j)
                    object.targetUsers[j] = $root.immessage.UserInfo.toObject(message.targetUsers[j], options);
            }
            return object;
        };

        /**
         * Converts this MentionInfo to JSON.
         * @function toJSON
         * @memberof immessage.MentionInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MentionInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MentionInfo
         * @function getTypeUrl
         * @memberof immessage.MentionInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MentionInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.MentionInfo";
        };

        return MentionInfo;
    })();

    /**
     * MentionType enum.
     * @name immessage.MentionType
     * @enum {number}
     * @property {number} MentionDefault=0 MentionDefault value
     * @property {number} All=1 All value
     * @property {number} Someone=2 Someone value
     * @property {number} AllAndSomeone=3 AllAndSomeone value
     */
    immessage.MentionType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MentionDefault"] = 0;
        values[valuesById[1] = "All"] = 1;
        values[valuesById[2] = "Someone"] = 2;
        values[valuesById[3] = "AllAndSomeone"] = 3;
        return values;
    })();

    immessage.PushData = (function() {

        /**
         * Properties of a PushData.
         * @memberof immessage
         * @interface IPushData
         * @property {string|null} [title] PushData title
         * @property {string|null} [pushId] PushData pushId
         * @property {string|null} [pushText] PushData pushText
         * @property {string|null} [pushExtraData] PushData pushExtraData
         * @property {immessage.PushLevel|null} [pushLevel] PushData pushLevel
         * @property {boolean|null} [isVoip] PushData isVoip
         * @property {number|null} [badge] PushData badge
         * @property {string|null} [msgId] PushData msgId
         * @property {string|null} [senderId] PushData senderId
         * @property {string|null} [ConverId] PushData ConverId
         * @property {immessage.ChannelType|null} [channelType] PushData channelType
         * @property {string|null} [rtcRoomId] PushData rtcRoomId
         * @property {string|null} [rtcInviterId] PushData rtcInviterId
         * @property {number|null} [rtcRoomType] PushData rtcRoomType
         * @property {number|null} [rtcMediaType] PushData rtcMediaType
         */

        /**
         * Constructs a new PushData.
         * @memberof immessage
         * @classdesc Represents a PushData.
         * @implements IPushData
         * @constructor
         * @param {immessage.IPushData=} [properties] Properties to set
         */
        function PushData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushData title.
         * @member {string} title
         * @memberof immessage.PushData
         * @instance
         */
        PushData.prototype.title = "";

        /**
         * PushData pushId.
         * @member {string} pushId
         * @memberof immessage.PushData
         * @instance
         */
        PushData.prototype.pushId = "";

        /**
         * PushData pushText.
         * @member {string} pushText
         * @memberof immessage.PushData
         * @instance
         */
        PushData.prototype.pushText = "";

        /**
         * PushData pushExtraData.
         * @member {string} pushExtraData
         * @memberof immessage.PushData
         * @instance
         */
        PushData.prototype.pushExtraData = "";

        /**
         * PushData pushLevel.
         * @member {immessage.PushLevel} pushLevel
         * @memberof immessage.PushData
         * @instance
         */
        PushData.prototype.pushLevel = 0;

        /**
         * PushData isVoip.
         * @member {boolean} isVoip
         * @memberof immessage.PushData
         * @instance
         */
        PushData.prototype.isVoip = false;

        /**
         * PushData badge.
         * @member {number} badge
         * @memberof immessage.PushData
         * @instance
         */
        PushData.prototype.badge = 0;

        /**
         * PushData msgId.
         * @member {string} msgId
         * @memberof immessage.PushData
         * @instance
         */
        PushData.prototype.msgId = "";

        /**
         * PushData senderId.
         * @member {string} senderId
         * @memberof immessage.PushData
         * @instance
         */
        PushData.prototype.senderId = "";

        /**
         * PushData ConverId.
         * @member {string} ConverId
         * @memberof immessage.PushData
         * @instance
         */
        PushData.prototype.ConverId = "";

        /**
         * PushData channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.PushData
         * @instance
         */
        PushData.prototype.channelType = 0;

        /**
         * PushData rtcRoomId.
         * @member {string} rtcRoomId
         * @memberof immessage.PushData
         * @instance
         */
        PushData.prototype.rtcRoomId = "";

        /**
         * PushData rtcInviterId.
         * @member {string} rtcInviterId
         * @memberof immessage.PushData
         * @instance
         */
        PushData.prototype.rtcInviterId = "";

        /**
         * PushData rtcRoomType.
         * @member {number} rtcRoomType
         * @memberof immessage.PushData
         * @instance
         */
        PushData.prototype.rtcRoomType = 0;

        /**
         * PushData rtcMediaType.
         * @member {number} rtcMediaType
         * @memberof immessage.PushData
         * @instance
         */
        PushData.prototype.rtcMediaType = 0;

        /**
         * Creates a new PushData instance using the specified properties.
         * @function create
         * @memberof immessage.PushData
         * @static
         * @param {immessage.IPushData=} [properties] Properties to set
         * @returns {immessage.PushData} PushData instance
         */
        PushData.create = function create(properties) {
            return new PushData(properties);
        };

        /**
         * Encodes the specified PushData message. Does not implicitly {@link immessage.PushData.verify|verify} messages.
         * @function encode
         * @memberof immessage.PushData
         * @static
         * @param {immessage.IPushData} message PushData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
            if (message.pushId != null && Object.hasOwnProperty.call(message, "pushId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pushId);
            if (message.pushText != null && Object.hasOwnProperty.call(message, "pushText"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.pushText);
            if (message.pushExtraData != null && Object.hasOwnProperty.call(message, "pushExtraData"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.pushExtraData);
            if (message.pushLevel != null && Object.hasOwnProperty.call(message, "pushLevel"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.pushLevel);
            if (message.isVoip != null && Object.hasOwnProperty.call(message, "isVoip"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isVoip);
            if (message.badge != null && Object.hasOwnProperty.call(message, "badge"))
                writer.uint32(/* id 50, wireType 0 =*/400).int32(message.badge);
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 51, wireType 2 =*/410).string(message.msgId);
            if (message.senderId != null && Object.hasOwnProperty.call(message, "senderId"))
                writer.uint32(/* id 52, wireType 2 =*/418).string(message.senderId);
            if (message.ConverId != null && Object.hasOwnProperty.call(message, "ConverId"))
                writer.uint32(/* id 53, wireType 2 =*/426).string(message.ConverId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 54, wireType 0 =*/432).int32(message.channelType);
            if (message.rtcRoomId != null && Object.hasOwnProperty.call(message, "rtcRoomId"))
                writer.uint32(/* id 55, wireType 2 =*/442).string(message.rtcRoomId);
            if (message.rtcInviterId != null && Object.hasOwnProperty.call(message, "rtcInviterId"))
                writer.uint32(/* id 56, wireType 2 =*/450).string(message.rtcInviterId);
            if (message.rtcRoomType != null && Object.hasOwnProperty.call(message, "rtcRoomType"))
                writer.uint32(/* id 57, wireType 0 =*/456).int32(message.rtcRoomType);
            if (message.rtcMediaType != null && Object.hasOwnProperty.call(message, "rtcMediaType"))
                writer.uint32(/* id 58, wireType 0 =*/464).int32(message.rtcMediaType);
            return writer;
        };

        /**
         * Encodes the specified PushData message, length delimited. Does not implicitly {@link immessage.PushData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.PushData
         * @static
         * @param {immessage.IPushData} message PushData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PushData message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.PushData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.PushData} PushData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.PushData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.title = reader.string();
                        break;
                    }
                case 2: {
                        message.pushId = reader.string();
                        break;
                    }
                case 3: {
                        message.pushText = reader.string();
                        break;
                    }
                case 4: {
                        message.pushExtraData = reader.string();
                        break;
                    }
                case 5: {
                        message.pushLevel = reader.int32();
                        break;
                    }
                case 6: {
                        message.isVoip = reader.bool();
                        break;
                    }
                case 50: {
                        message.badge = reader.int32();
                        break;
                    }
                case 51: {
                        message.msgId = reader.string();
                        break;
                    }
                case 52: {
                        message.senderId = reader.string();
                        break;
                    }
                case 53: {
                        message.ConverId = reader.string();
                        break;
                    }
                case 54: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 55: {
                        message.rtcRoomId = reader.string();
                        break;
                    }
                case 56: {
                        message.rtcInviterId = reader.string();
                        break;
                    }
                case 57: {
                        message.rtcRoomType = reader.int32();
                        break;
                    }
                case 58: {
                        message.rtcMediaType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PushData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.PushData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.PushData} PushData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PushData message.
         * @function verify
         * @memberof immessage.PushData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PushData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.pushId != null && message.hasOwnProperty("pushId"))
                if (!$util.isString(message.pushId))
                    return "pushId: string expected";
            if (message.pushText != null && message.hasOwnProperty("pushText"))
                if (!$util.isString(message.pushText))
                    return "pushText: string expected";
            if (message.pushExtraData != null && message.hasOwnProperty("pushExtraData"))
                if (!$util.isString(message.pushExtraData))
                    return "pushExtraData: string expected";
            if (message.pushLevel != null && message.hasOwnProperty("pushLevel"))
                switch (message.pushLevel) {
                default:
                    return "pushLevel: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.isVoip != null && message.hasOwnProperty("isVoip"))
                if (typeof message.isVoip !== "boolean")
                    return "isVoip: boolean expected";
            if (message.badge != null && message.hasOwnProperty("badge"))
                if (!$util.isInteger(message.badge))
                    return "badge: integer expected";
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            if (message.senderId != null && message.hasOwnProperty("senderId"))
                if (!$util.isString(message.senderId))
                    return "senderId: string expected";
            if (message.ConverId != null && message.hasOwnProperty("ConverId"))
                if (!$util.isString(message.ConverId))
                    return "ConverId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.rtcRoomId != null && message.hasOwnProperty("rtcRoomId"))
                if (!$util.isString(message.rtcRoomId))
                    return "rtcRoomId: string expected";
            if (message.rtcInviterId != null && message.hasOwnProperty("rtcInviterId"))
                if (!$util.isString(message.rtcInviterId))
                    return "rtcInviterId: string expected";
            if (message.rtcRoomType != null && message.hasOwnProperty("rtcRoomType"))
                if (!$util.isInteger(message.rtcRoomType))
                    return "rtcRoomType: integer expected";
            if (message.rtcMediaType != null && message.hasOwnProperty("rtcMediaType"))
                if (!$util.isInteger(message.rtcMediaType))
                    return "rtcMediaType: integer expected";
            return null;
        };

        /**
         * Creates a PushData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.PushData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.PushData} PushData
         */
        PushData.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.PushData)
                return object;
            let message = new $root.immessage.PushData();
            if (object.title != null)
                message.title = String(object.title);
            if (object.pushId != null)
                message.pushId = String(object.pushId);
            if (object.pushText != null)
                message.pushText = String(object.pushText);
            if (object.pushExtraData != null)
                message.pushExtraData = String(object.pushExtraData);
            switch (object.pushLevel) {
            default:
                if (typeof object.pushLevel === "number") {
                    message.pushLevel = object.pushLevel;
                    break;
                }
                break;
            case "DefaultPuhsLevel":
            case 0:
                message.pushLevel = 0;
                break;
            case "IgnoreSpeedControl":
            case 1:
                message.pushLevel = 1;
                break;
            case "IgnoreUndisturb":
            case 2:
                message.pushLevel = 2;
                break;
            }
            if (object.isVoip != null)
                message.isVoip = Boolean(object.isVoip);
            if (object.badge != null)
                message.badge = object.badge | 0;
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            if (object.senderId != null)
                message.senderId = String(object.senderId);
            if (object.ConverId != null)
                message.ConverId = String(object.ConverId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.rtcRoomId != null)
                message.rtcRoomId = String(object.rtcRoomId);
            if (object.rtcInviterId != null)
                message.rtcInviterId = String(object.rtcInviterId);
            if (object.rtcRoomType != null)
                message.rtcRoomType = object.rtcRoomType | 0;
            if (object.rtcMediaType != null)
                message.rtcMediaType = object.rtcMediaType | 0;
            return message;
        };

        /**
         * Creates a plain object from a PushData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.PushData
         * @static
         * @param {immessage.PushData} message PushData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PushData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.title = "";
                object.pushId = "";
                object.pushText = "";
                object.pushExtraData = "";
                object.pushLevel = options.enums === String ? "DefaultPuhsLevel" : 0;
                object.isVoip = false;
                object.badge = 0;
                object.msgId = "";
                object.senderId = "";
                object.ConverId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                object.rtcRoomId = "";
                object.rtcInviterId = "";
                object.rtcRoomType = 0;
                object.rtcMediaType = 0;
            }
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.pushId != null && message.hasOwnProperty("pushId"))
                object.pushId = message.pushId;
            if (message.pushText != null && message.hasOwnProperty("pushText"))
                object.pushText = message.pushText;
            if (message.pushExtraData != null && message.hasOwnProperty("pushExtraData"))
                object.pushExtraData = message.pushExtraData;
            if (message.pushLevel != null && message.hasOwnProperty("pushLevel"))
                object.pushLevel = options.enums === String ? $root.immessage.PushLevel[message.pushLevel] === undefined ? message.pushLevel : $root.immessage.PushLevel[message.pushLevel] : message.pushLevel;
            if (message.isVoip != null && message.hasOwnProperty("isVoip"))
                object.isVoip = message.isVoip;
            if (message.badge != null && message.hasOwnProperty("badge"))
                object.badge = message.badge;
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            if (message.senderId != null && message.hasOwnProperty("senderId"))
                object.senderId = message.senderId;
            if (message.ConverId != null && message.hasOwnProperty("ConverId"))
                object.ConverId = message.ConverId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.rtcRoomId != null && message.hasOwnProperty("rtcRoomId"))
                object.rtcRoomId = message.rtcRoomId;
            if (message.rtcInviterId != null && message.hasOwnProperty("rtcInviterId"))
                object.rtcInviterId = message.rtcInviterId;
            if (message.rtcRoomType != null && message.hasOwnProperty("rtcRoomType"))
                object.rtcRoomType = message.rtcRoomType;
            if (message.rtcMediaType != null && message.hasOwnProperty("rtcMediaType"))
                object.rtcMediaType = message.rtcMediaType;
            return object;
        };

        /**
         * Converts this PushData to JSON.
         * @function toJSON
         * @memberof immessage.PushData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PushData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PushData
         * @function getTypeUrl
         * @memberof immessage.PushData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PushData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.PushData";
        };

        return PushData;
    })();

    /**
     * PushLevel enum.
     * @name immessage.PushLevel
     * @enum {number}
     * @property {number} DefaultPuhsLevel=0 DefaultPuhsLevel value
     * @property {number} IgnoreSpeedControl=1 IgnoreSpeedControl value
     * @property {number} IgnoreUndisturb=2 IgnoreUndisturb value
     */
    immessage.PushLevel = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DefaultPuhsLevel"] = 0;
        values[valuesById[1] = "IgnoreSpeedControl"] = 1;
        values[valuesById[2] = "IgnoreUndisturb"] = 2;
        return values;
    })();

    immessage.DownMsg = (function() {

        /**
         * Properties of a DownMsg.
         * @memberof immessage
         * @interface IDownMsg
         * @property {string|null} [targetId] DownMsg targetId
         * @property {immessage.ChannelType|null} [channelType] DownMsg channelType
         * @property {string|null} [msgType] DownMsg msgType
         * @property {string|null} [senderId] DownMsg senderId
         * @property {string|null} [msgId] DownMsg msgId
         * @property {number|Long|null} [msgSeqNo] DownMsg msgSeqNo
         * @property {Uint8Array|null} [msgContent] DownMsg msgContent
         * @property {number|Long|null} [msgTime] DownMsg msgTime
         * @property {number|null} [flags] DownMsg flags
         * @property {boolean|null} [isSend] DownMsg isSend
         * @property {string|null} [platform] DownMsg platform
         * @property {string|null} [clientUid] DownMsg clientUid
         * @property {immessage.IPushData|null} [pushData] DownMsg pushData
         * @property {immessage.IMentionInfo|null} [mentionInfo] DownMsg mentionInfo
         * @property {boolean|null} [isRead] DownMsg isRead
         * @property {immessage.IDownMsg|null} [referMsg] DownMsg referMsg
         * @property {immessage.IUserInfo|null} [targetUserInfo] DownMsg targetUserInfo
         * @property {immessage.IGroupInfo|null} [groupInfo] DownMsg groupInfo
         * @property {immessage.IMergedMsgs|null} [mergedMsgs] DownMsg mergedMsgs
         * @property {number|null} [undisturbType] DownMsg undisturbType
         * @property {number|null} [memberCount] DownMsg memberCount
         * @property {number|null} [readCount] DownMsg readCount
         * @property {number|Long|null} [unreadIndex] DownMsg unreadIndex
         * @property {Array.<immessage.IStreamMsgItem>|null} [streamMsgParts] DownMsg streamMsgParts
         * @property {Array.<immessage.IMsgExtItem>|null} [msgExSet] DownMsg msgExSet
         * @property {Array.<immessage.IMsgExtItem>|null} [msgExts] DownMsg msgExts
         * @property {Array.<immessage.IConverTag>|null} [converTags] DownMsg converTags
         * @property {Object.<string,immessage.ITransMsgContent>|null} [transMsgMap] DownMsg transMsgMap
         * @property {string|null} [SearchText] DownMsg SearchText
         * @property {immessage.IGrpMemberInfo|null} [grpMemberInfo] DownMsg grpMemberInfo
         */

        /**
         * Constructs a new DownMsg.
         * @memberof immessage
         * @classdesc Represents a DownMsg.
         * @implements IDownMsg
         * @constructor
         * @param {immessage.IDownMsg=} [properties] Properties to set
         */
        function DownMsg(properties) {
            this.streamMsgParts = [];
            this.msgExSet = [];
            this.msgExts = [];
            this.converTags = [];
            this.transMsgMap = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DownMsg targetId.
         * @member {string} targetId
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.targetId = "";

        /**
         * DownMsg channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.channelType = 0;

        /**
         * DownMsg msgType.
         * @member {string} msgType
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.msgType = "";

        /**
         * DownMsg senderId.
         * @member {string} senderId
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.senderId = "";

        /**
         * DownMsg msgId.
         * @member {string} msgId
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.msgId = "";

        /**
         * DownMsg msgSeqNo.
         * @member {number|Long} msgSeqNo
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.msgSeqNo = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DownMsg msgContent.
         * @member {Uint8Array} msgContent
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.msgContent = $util.newBuffer([]);

        /**
         * DownMsg msgTime.
         * @member {number|Long} msgTime
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.msgTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DownMsg flags.
         * @member {number} flags
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.flags = 0;

        /**
         * DownMsg isSend.
         * @member {boolean} isSend
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.isSend = false;

        /**
         * DownMsg platform.
         * @member {string} platform
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.platform = "";

        /**
         * DownMsg clientUid.
         * @member {string} clientUid
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.clientUid = "";

        /**
         * DownMsg pushData.
         * @member {immessage.IPushData|null|undefined} pushData
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.pushData = null;

        /**
         * DownMsg mentionInfo.
         * @member {immessage.IMentionInfo|null|undefined} mentionInfo
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.mentionInfo = null;

        /**
         * DownMsg isRead.
         * @member {boolean} isRead
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.isRead = false;

        /**
         * DownMsg referMsg.
         * @member {immessage.IDownMsg|null|undefined} referMsg
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.referMsg = null;

        /**
         * DownMsg targetUserInfo.
         * @member {immessage.IUserInfo|null|undefined} targetUserInfo
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.targetUserInfo = null;

        /**
         * DownMsg groupInfo.
         * @member {immessage.IGroupInfo|null|undefined} groupInfo
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.groupInfo = null;

        /**
         * DownMsg mergedMsgs.
         * @member {immessage.IMergedMsgs|null|undefined} mergedMsgs
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.mergedMsgs = null;

        /**
         * DownMsg undisturbType.
         * @member {number} undisturbType
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.undisturbType = 0;

        /**
         * DownMsg memberCount.
         * @member {number} memberCount
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.memberCount = 0;

        /**
         * DownMsg readCount.
         * @member {number} readCount
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.readCount = 0;

        /**
         * DownMsg unreadIndex.
         * @member {number|Long} unreadIndex
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.unreadIndex = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DownMsg streamMsgParts.
         * @member {Array.<immessage.IStreamMsgItem>} streamMsgParts
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.streamMsgParts = $util.emptyArray;

        /**
         * DownMsg msgExSet.
         * @member {Array.<immessage.IMsgExtItem>} msgExSet
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.msgExSet = $util.emptyArray;

        /**
         * DownMsg msgExts.
         * @member {Array.<immessage.IMsgExtItem>} msgExts
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.msgExts = $util.emptyArray;

        /**
         * DownMsg converTags.
         * @member {Array.<immessage.IConverTag>} converTags
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.converTags = $util.emptyArray;

        /**
         * DownMsg transMsgMap.
         * @member {Object.<string,immessage.ITransMsgContent>} transMsgMap
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.transMsgMap = $util.emptyObject;

        /**
         * DownMsg SearchText.
         * @member {string} SearchText
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.SearchText = "";

        /**
         * DownMsg grpMemberInfo.
         * @member {immessage.IGrpMemberInfo|null|undefined} grpMemberInfo
         * @memberof immessage.DownMsg
         * @instance
         */
        DownMsg.prototype.grpMemberInfo = null;

        /**
         * Creates a new DownMsg instance using the specified properties.
         * @function create
         * @memberof immessage.DownMsg
         * @static
         * @param {immessage.IDownMsg=} [properties] Properties to set
         * @returns {immessage.DownMsg} DownMsg instance
         */
        DownMsg.create = function create(properties) {
            return new DownMsg(properties);
        };

        /**
         * Encodes the specified DownMsg message. Does not implicitly {@link immessage.DownMsg.verify|verify} messages.
         * @function encode
         * @memberof immessage.DownMsg
         * @static
         * @param {immessage.IDownMsg} message DownMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DownMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.msgType != null && Object.hasOwnProperty.call(message, "msgType"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.msgType);
            if (message.senderId != null && Object.hasOwnProperty.call(message, "senderId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.senderId);
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.msgId);
            if (message.msgSeqNo != null && Object.hasOwnProperty.call(message, "msgSeqNo"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.msgSeqNo);
            if (message.msgContent != null && Object.hasOwnProperty.call(message, "msgContent"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.msgContent);
            if (message.msgTime != null && Object.hasOwnProperty.call(message, "msgTime"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.msgTime);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.flags);
            if (message.isSend != null && Object.hasOwnProperty.call(message, "isSend"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.isSend);
            if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.platform);
            if (message.clientUid != null && Object.hasOwnProperty.call(message, "clientUid"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.clientUid);
            if (message.pushData != null && Object.hasOwnProperty.call(message, "pushData"))
                $root.immessage.PushData.encode(message.pushData, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.mentionInfo != null && Object.hasOwnProperty.call(message, "mentionInfo"))
                $root.immessage.MentionInfo.encode(message.mentionInfo, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.isRead != null && Object.hasOwnProperty.call(message, "isRead"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.isRead);
            if (message.referMsg != null && Object.hasOwnProperty.call(message, "referMsg"))
                $root.immessage.DownMsg.encode(message.referMsg, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.targetUserInfo != null && Object.hasOwnProperty.call(message, "targetUserInfo"))
                $root.immessage.UserInfo.encode(message.targetUserInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.groupInfo != null && Object.hasOwnProperty.call(message, "groupInfo"))
                $root.immessage.GroupInfo.encode(message.groupInfo, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.mergedMsgs != null && Object.hasOwnProperty.call(message, "mergedMsgs"))
                $root.immessage.MergedMsgs.encode(message.mergedMsgs, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.undisturbType != null && Object.hasOwnProperty.call(message, "undisturbType"))
                writer.uint32(/* id 20, wireType 0 =*/160).int32(message.undisturbType);
            if (message.memberCount != null && Object.hasOwnProperty.call(message, "memberCount"))
                writer.uint32(/* id 21, wireType 0 =*/168).int32(message.memberCount);
            if (message.readCount != null && Object.hasOwnProperty.call(message, "readCount"))
                writer.uint32(/* id 22, wireType 0 =*/176).int32(message.readCount);
            if (message.unreadIndex != null && Object.hasOwnProperty.call(message, "unreadIndex"))
                writer.uint32(/* id 23, wireType 0 =*/184).int64(message.unreadIndex);
            if (message.streamMsgParts != null && message.streamMsgParts.length)
                for (let i = 0; i < message.streamMsgParts.length; ++i)
                    $root.immessage.StreamMsgItem.encode(message.streamMsgParts[i], writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.msgExSet != null && message.msgExSet.length)
                for (let i = 0; i < message.msgExSet.length; ++i)
                    $root.immessage.MsgExtItem.encode(message.msgExSet[i], writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            if (message.msgExts != null && message.msgExts.length)
                for (let i = 0; i < message.msgExts.length; ++i)
                    $root.immessage.MsgExtItem.encode(message.msgExts[i], writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.converTags != null && message.converTags.length)
                for (let i = 0; i < message.converTags.length; ++i)
                    $root.immessage.ConverTag.encode(message.converTags[i], writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
            if (message.transMsgMap != null && Object.hasOwnProperty.call(message, "transMsgMap"))
                for (let keys = Object.keys(message.transMsgMap), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 28, wireType 2 =*/226).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.immessage.TransMsgContent.encode(message.transMsgMap[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.SearchText != null && Object.hasOwnProperty.call(message, "SearchText"))
                writer.uint32(/* id 29, wireType 2 =*/234).string(message.SearchText);
            if (message.grpMemberInfo != null && Object.hasOwnProperty.call(message, "grpMemberInfo"))
                $root.immessage.GrpMemberInfo.encode(message.grpMemberInfo, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DownMsg message, length delimited. Does not implicitly {@link immessage.DownMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.DownMsg
         * @static
         * @param {immessage.IDownMsg} message DownMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DownMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DownMsg message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.DownMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.DownMsg} DownMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DownMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.DownMsg(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        message.msgType = reader.string();
                        break;
                    }
                case 4: {
                        message.senderId = reader.string();
                        break;
                    }
                case 5: {
                        message.msgId = reader.string();
                        break;
                    }
                case 6: {
                        message.msgSeqNo = reader.int64();
                        break;
                    }
                case 7: {
                        message.msgContent = reader.bytes();
                        break;
                    }
                case 8: {
                        message.msgTime = reader.int64();
                        break;
                    }
                case 9: {
                        message.flags = reader.int32();
                        break;
                    }
                case 10: {
                        message.isSend = reader.bool();
                        break;
                    }
                case 11: {
                        message.platform = reader.string();
                        break;
                    }
                case 12: {
                        message.clientUid = reader.string();
                        break;
                    }
                case 13: {
                        message.pushData = $root.immessage.PushData.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.mentionInfo = $root.immessage.MentionInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 15: {
                        message.isRead = reader.bool();
                        break;
                    }
                case 16: {
                        message.referMsg = $root.immessage.DownMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 17: {
                        message.targetUserInfo = $root.immessage.UserInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 18: {
                        message.groupInfo = $root.immessage.GroupInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 19: {
                        message.mergedMsgs = $root.immessage.MergedMsgs.decode(reader, reader.uint32());
                        break;
                    }
                case 20: {
                        message.undisturbType = reader.int32();
                        break;
                    }
                case 21: {
                        message.memberCount = reader.int32();
                        break;
                    }
                case 22: {
                        message.readCount = reader.int32();
                        break;
                    }
                case 23: {
                        message.unreadIndex = reader.int64();
                        break;
                    }
                case 24: {
                        if (!(message.streamMsgParts && message.streamMsgParts.length))
                            message.streamMsgParts = [];
                        message.streamMsgParts.push($root.immessage.StreamMsgItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 25: {
                        if (!(message.msgExSet && message.msgExSet.length))
                            message.msgExSet = [];
                        message.msgExSet.push($root.immessage.MsgExtItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 26: {
                        if (!(message.msgExts && message.msgExts.length))
                            message.msgExts = [];
                        message.msgExts.push($root.immessage.MsgExtItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 27: {
                        if (!(message.converTags && message.converTags.length))
                            message.converTags = [];
                        message.converTags.push($root.immessage.ConverTag.decode(reader, reader.uint32()));
                        break;
                    }
                case 28: {
                        if (message.transMsgMap === $util.emptyObject)
                            message.transMsgMap = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.immessage.TransMsgContent.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.transMsgMap[key] = value;
                        break;
                    }
                case 29: {
                        message.SearchText = reader.string();
                        break;
                    }
                case 30: {
                        message.grpMemberInfo = $root.immessage.GrpMemberInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DownMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.DownMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.DownMsg} DownMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DownMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DownMsg message.
         * @function verify
         * @memberof immessage.DownMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DownMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.msgType != null && message.hasOwnProperty("msgType"))
                if (!$util.isString(message.msgType))
                    return "msgType: string expected";
            if (message.senderId != null && message.hasOwnProperty("senderId"))
                if (!$util.isString(message.senderId))
                    return "senderId: string expected";
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            if (message.msgSeqNo != null && message.hasOwnProperty("msgSeqNo"))
                if (!$util.isInteger(message.msgSeqNo) && !(message.msgSeqNo && $util.isInteger(message.msgSeqNo.low) && $util.isInteger(message.msgSeqNo.high)))
                    return "msgSeqNo: integer|Long expected";
            if (message.msgContent != null && message.hasOwnProperty("msgContent"))
                if (!(message.msgContent && typeof message.msgContent.length === "number" || $util.isString(message.msgContent)))
                    return "msgContent: buffer expected";
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (!$util.isInteger(message.msgTime) && !(message.msgTime && $util.isInteger(message.msgTime.low) && $util.isInteger(message.msgTime.high)))
                    return "msgTime: integer|Long expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.isSend != null && message.hasOwnProperty("isSend"))
                if (typeof message.isSend !== "boolean")
                    return "isSend: boolean expected";
            if (message.platform != null && message.hasOwnProperty("platform"))
                if (!$util.isString(message.platform))
                    return "platform: string expected";
            if (message.clientUid != null && message.hasOwnProperty("clientUid"))
                if (!$util.isString(message.clientUid))
                    return "clientUid: string expected";
            if (message.pushData != null && message.hasOwnProperty("pushData")) {
                let error = $root.immessage.PushData.verify(message.pushData);
                if (error)
                    return "pushData." + error;
            }
            if (message.mentionInfo != null && message.hasOwnProperty("mentionInfo")) {
                let error = $root.immessage.MentionInfo.verify(message.mentionInfo);
                if (error)
                    return "mentionInfo." + error;
            }
            if (message.isRead != null && message.hasOwnProperty("isRead"))
                if (typeof message.isRead !== "boolean")
                    return "isRead: boolean expected";
            if (message.referMsg != null && message.hasOwnProperty("referMsg")) {
                let error = $root.immessage.DownMsg.verify(message.referMsg);
                if (error)
                    return "referMsg." + error;
            }
            if (message.targetUserInfo != null && message.hasOwnProperty("targetUserInfo")) {
                let error = $root.immessage.UserInfo.verify(message.targetUserInfo);
                if (error)
                    return "targetUserInfo." + error;
            }
            if (message.groupInfo != null && message.hasOwnProperty("groupInfo")) {
                let error = $root.immessage.GroupInfo.verify(message.groupInfo);
                if (error)
                    return "groupInfo." + error;
            }
            if (message.mergedMsgs != null && message.hasOwnProperty("mergedMsgs")) {
                let error = $root.immessage.MergedMsgs.verify(message.mergedMsgs);
                if (error)
                    return "mergedMsgs." + error;
            }
            if (message.undisturbType != null && message.hasOwnProperty("undisturbType"))
                if (!$util.isInteger(message.undisturbType))
                    return "undisturbType: integer expected";
            if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                if (!$util.isInteger(message.memberCount))
                    return "memberCount: integer expected";
            if (message.readCount != null && message.hasOwnProperty("readCount"))
                if (!$util.isInteger(message.readCount))
                    return "readCount: integer expected";
            if (message.unreadIndex != null && message.hasOwnProperty("unreadIndex"))
                if (!$util.isInteger(message.unreadIndex) && !(message.unreadIndex && $util.isInteger(message.unreadIndex.low) && $util.isInteger(message.unreadIndex.high)))
                    return "unreadIndex: integer|Long expected";
            if (message.streamMsgParts != null && message.hasOwnProperty("streamMsgParts")) {
                if (!Array.isArray(message.streamMsgParts))
                    return "streamMsgParts: array expected";
                for (let i = 0; i < message.streamMsgParts.length; ++i) {
                    let error = $root.immessage.StreamMsgItem.verify(message.streamMsgParts[i]);
                    if (error)
                        return "streamMsgParts." + error;
                }
            }
            if (message.msgExSet != null && message.hasOwnProperty("msgExSet")) {
                if (!Array.isArray(message.msgExSet))
                    return "msgExSet: array expected";
                for (let i = 0; i < message.msgExSet.length; ++i) {
                    let error = $root.immessage.MsgExtItem.verify(message.msgExSet[i]);
                    if (error)
                        return "msgExSet." + error;
                }
            }
            if (message.msgExts != null && message.hasOwnProperty("msgExts")) {
                if (!Array.isArray(message.msgExts))
                    return "msgExts: array expected";
                for (let i = 0; i < message.msgExts.length; ++i) {
                    let error = $root.immessage.MsgExtItem.verify(message.msgExts[i]);
                    if (error)
                        return "msgExts." + error;
                }
            }
            if (message.converTags != null && message.hasOwnProperty("converTags")) {
                if (!Array.isArray(message.converTags))
                    return "converTags: array expected";
                for (let i = 0; i < message.converTags.length; ++i) {
                    let error = $root.immessage.ConverTag.verify(message.converTags[i]);
                    if (error)
                        return "converTags." + error;
                }
            }
            if (message.transMsgMap != null && message.hasOwnProperty("transMsgMap")) {
                if (!$util.isObject(message.transMsgMap))
                    return "transMsgMap: object expected";
                let key = Object.keys(message.transMsgMap);
                for (let i = 0; i < key.length; ++i) {
                    let error = $root.immessage.TransMsgContent.verify(message.transMsgMap[key[i]]);
                    if (error)
                        return "transMsgMap." + error;
                }
            }
            if (message.SearchText != null && message.hasOwnProperty("SearchText"))
                if (!$util.isString(message.SearchText))
                    return "SearchText: string expected";
            if (message.grpMemberInfo != null && message.hasOwnProperty("grpMemberInfo")) {
                let error = $root.immessage.GrpMemberInfo.verify(message.grpMemberInfo);
                if (error)
                    return "grpMemberInfo." + error;
            }
            return null;
        };

        /**
         * Creates a DownMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.DownMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.DownMsg} DownMsg
         */
        DownMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.DownMsg)
                return object;
            let message = new $root.immessage.DownMsg();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.msgType != null)
                message.msgType = String(object.msgType);
            if (object.senderId != null)
                message.senderId = String(object.senderId);
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            if (object.msgSeqNo != null)
                if ($util.Long)
                    (message.msgSeqNo = $util.Long.fromValue(object.msgSeqNo)).unsigned = false;
                else if (typeof object.msgSeqNo === "string")
                    message.msgSeqNo = parseInt(object.msgSeqNo, 10);
                else if (typeof object.msgSeqNo === "number")
                    message.msgSeqNo = object.msgSeqNo;
                else if (typeof object.msgSeqNo === "object")
                    message.msgSeqNo = new $util.LongBits(object.msgSeqNo.low >>> 0, object.msgSeqNo.high >>> 0).toNumber();
            if (object.msgContent != null)
                if (typeof object.msgContent === "string")
                    $util.base64.decode(object.msgContent, message.msgContent = $util.newBuffer($util.base64.length(object.msgContent)), 0);
                else if (object.msgContent.length >= 0)
                    message.msgContent = object.msgContent;
            if (object.msgTime != null)
                if ($util.Long)
                    (message.msgTime = $util.Long.fromValue(object.msgTime)).unsigned = false;
                else if (typeof object.msgTime === "string")
                    message.msgTime = parseInt(object.msgTime, 10);
                else if (typeof object.msgTime === "number")
                    message.msgTime = object.msgTime;
                else if (typeof object.msgTime === "object")
                    message.msgTime = new $util.LongBits(object.msgTime.low >>> 0, object.msgTime.high >>> 0).toNumber();
            if (object.flags != null)
                message.flags = object.flags | 0;
            if (object.isSend != null)
                message.isSend = Boolean(object.isSend);
            if (object.platform != null)
                message.platform = String(object.platform);
            if (object.clientUid != null)
                message.clientUid = String(object.clientUid);
            if (object.pushData != null) {
                if (typeof object.pushData !== "object")
                    throw TypeError(".immessage.DownMsg.pushData: object expected");
                message.pushData = $root.immessage.PushData.fromObject(object.pushData);
            }
            if (object.mentionInfo != null) {
                if (typeof object.mentionInfo !== "object")
                    throw TypeError(".immessage.DownMsg.mentionInfo: object expected");
                message.mentionInfo = $root.immessage.MentionInfo.fromObject(object.mentionInfo);
            }
            if (object.isRead != null)
                message.isRead = Boolean(object.isRead);
            if (object.referMsg != null) {
                if (typeof object.referMsg !== "object")
                    throw TypeError(".immessage.DownMsg.referMsg: object expected");
                message.referMsg = $root.immessage.DownMsg.fromObject(object.referMsg);
            }
            if (object.targetUserInfo != null) {
                if (typeof object.targetUserInfo !== "object")
                    throw TypeError(".immessage.DownMsg.targetUserInfo: object expected");
                message.targetUserInfo = $root.immessage.UserInfo.fromObject(object.targetUserInfo);
            }
            if (object.groupInfo != null) {
                if (typeof object.groupInfo !== "object")
                    throw TypeError(".immessage.DownMsg.groupInfo: object expected");
                message.groupInfo = $root.immessage.GroupInfo.fromObject(object.groupInfo);
            }
            if (object.mergedMsgs != null) {
                if (typeof object.mergedMsgs !== "object")
                    throw TypeError(".immessage.DownMsg.mergedMsgs: object expected");
                message.mergedMsgs = $root.immessage.MergedMsgs.fromObject(object.mergedMsgs);
            }
            if (object.undisturbType != null)
                message.undisturbType = object.undisturbType | 0;
            if (object.memberCount != null)
                message.memberCount = object.memberCount | 0;
            if (object.readCount != null)
                message.readCount = object.readCount | 0;
            if (object.unreadIndex != null)
                if ($util.Long)
                    (message.unreadIndex = $util.Long.fromValue(object.unreadIndex)).unsigned = false;
                else if (typeof object.unreadIndex === "string")
                    message.unreadIndex = parseInt(object.unreadIndex, 10);
                else if (typeof object.unreadIndex === "number")
                    message.unreadIndex = object.unreadIndex;
                else if (typeof object.unreadIndex === "object")
                    message.unreadIndex = new $util.LongBits(object.unreadIndex.low >>> 0, object.unreadIndex.high >>> 0).toNumber();
            if (object.streamMsgParts) {
                if (!Array.isArray(object.streamMsgParts))
                    throw TypeError(".immessage.DownMsg.streamMsgParts: array expected");
                message.streamMsgParts = [];
                for (let i = 0; i < object.streamMsgParts.length; ++i) {
                    if (typeof object.streamMsgParts[i] !== "object")
                        throw TypeError(".immessage.DownMsg.streamMsgParts: object expected");
                    message.streamMsgParts[i] = $root.immessage.StreamMsgItem.fromObject(object.streamMsgParts[i]);
                }
            }
            if (object.msgExSet) {
                if (!Array.isArray(object.msgExSet))
                    throw TypeError(".immessage.DownMsg.msgExSet: array expected");
                message.msgExSet = [];
                for (let i = 0; i < object.msgExSet.length; ++i) {
                    if (typeof object.msgExSet[i] !== "object")
                        throw TypeError(".immessage.DownMsg.msgExSet: object expected");
                    message.msgExSet[i] = $root.immessage.MsgExtItem.fromObject(object.msgExSet[i]);
                }
            }
            if (object.msgExts) {
                if (!Array.isArray(object.msgExts))
                    throw TypeError(".immessage.DownMsg.msgExts: array expected");
                message.msgExts = [];
                for (let i = 0; i < object.msgExts.length; ++i) {
                    if (typeof object.msgExts[i] !== "object")
                        throw TypeError(".immessage.DownMsg.msgExts: object expected");
                    message.msgExts[i] = $root.immessage.MsgExtItem.fromObject(object.msgExts[i]);
                }
            }
            if (object.converTags) {
                if (!Array.isArray(object.converTags))
                    throw TypeError(".immessage.DownMsg.converTags: array expected");
                message.converTags = [];
                for (let i = 0; i < object.converTags.length; ++i) {
                    if (typeof object.converTags[i] !== "object")
                        throw TypeError(".immessage.DownMsg.converTags: object expected");
                    message.converTags[i] = $root.immessage.ConverTag.fromObject(object.converTags[i]);
                }
            }
            if (object.transMsgMap) {
                if (typeof object.transMsgMap !== "object")
                    throw TypeError(".immessage.DownMsg.transMsgMap: object expected");
                message.transMsgMap = {};
                for (let keys = Object.keys(object.transMsgMap), i = 0; i < keys.length; ++i) {
                    if (typeof object.transMsgMap[keys[i]] !== "object")
                        throw TypeError(".immessage.DownMsg.transMsgMap: object expected");
                    message.transMsgMap[keys[i]] = $root.immessage.TransMsgContent.fromObject(object.transMsgMap[keys[i]]);
                }
            }
            if (object.SearchText != null)
                message.SearchText = String(object.SearchText);
            if (object.grpMemberInfo != null) {
                if (typeof object.grpMemberInfo !== "object")
                    throw TypeError(".immessage.DownMsg.grpMemberInfo: object expected");
                message.grpMemberInfo = $root.immessage.GrpMemberInfo.fromObject(object.grpMemberInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a DownMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.DownMsg
         * @static
         * @param {immessage.DownMsg} message DownMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DownMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.streamMsgParts = [];
                object.msgExSet = [];
                object.msgExts = [];
                object.converTags = [];
            }
            if (options.objects || options.defaults)
                object.transMsgMap = {};
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                object.msgType = "";
                object.senderId = "";
                object.msgId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.msgSeqNo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msgSeqNo = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.msgContent = "";
                else {
                    object.msgContent = [];
                    if (options.bytes !== Array)
                        object.msgContent = $util.newBuffer(object.msgContent);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.msgTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msgTime = options.longs === String ? "0" : 0;
                object.flags = 0;
                object.isSend = false;
                object.platform = "";
                object.clientUid = "";
                object.pushData = null;
                object.mentionInfo = null;
                object.isRead = false;
                object.referMsg = null;
                object.targetUserInfo = null;
                object.groupInfo = null;
                object.mergedMsgs = null;
                object.undisturbType = 0;
                object.memberCount = 0;
                object.readCount = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.unreadIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.unreadIndex = options.longs === String ? "0" : 0;
                object.SearchText = "";
                object.grpMemberInfo = null;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.msgType != null && message.hasOwnProperty("msgType"))
                object.msgType = message.msgType;
            if (message.senderId != null && message.hasOwnProperty("senderId"))
                object.senderId = message.senderId;
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            if (message.msgSeqNo != null && message.hasOwnProperty("msgSeqNo"))
                if (typeof message.msgSeqNo === "number")
                    object.msgSeqNo = options.longs === String ? String(message.msgSeqNo) : message.msgSeqNo;
                else
                    object.msgSeqNo = options.longs === String ? $util.Long.prototype.toString.call(message.msgSeqNo) : options.longs === Number ? new $util.LongBits(message.msgSeqNo.low >>> 0, message.msgSeqNo.high >>> 0).toNumber() : message.msgSeqNo;
            if (message.msgContent != null && message.hasOwnProperty("msgContent"))
                object.msgContent = options.bytes === String ? $util.base64.encode(message.msgContent, 0, message.msgContent.length) : options.bytes === Array ? Array.prototype.slice.call(message.msgContent) : message.msgContent;
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (typeof message.msgTime === "number")
                    object.msgTime = options.longs === String ? String(message.msgTime) : message.msgTime;
                else
                    object.msgTime = options.longs === String ? $util.Long.prototype.toString.call(message.msgTime) : options.longs === Number ? new $util.LongBits(message.msgTime.low >>> 0, message.msgTime.high >>> 0).toNumber() : message.msgTime;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.isSend != null && message.hasOwnProperty("isSend"))
                object.isSend = message.isSend;
            if (message.platform != null && message.hasOwnProperty("platform"))
                object.platform = message.platform;
            if (message.clientUid != null && message.hasOwnProperty("clientUid"))
                object.clientUid = message.clientUid;
            if (message.pushData != null && message.hasOwnProperty("pushData"))
                object.pushData = $root.immessage.PushData.toObject(message.pushData, options);
            if (message.mentionInfo != null && message.hasOwnProperty("mentionInfo"))
                object.mentionInfo = $root.immessage.MentionInfo.toObject(message.mentionInfo, options);
            if (message.isRead != null && message.hasOwnProperty("isRead"))
                object.isRead = message.isRead;
            if (message.referMsg != null && message.hasOwnProperty("referMsg"))
                object.referMsg = $root.immessage.DownMsg.toObject(message.referMsg, options);
            if (message.targetUserInfo != null && message.hasOwnProperty("targetUserInfo"))
                object.targetUserInfo = $root.immessage.UserInfo.toObject(message.targetUserInfo, options);
            if (message.groupInfo != null && message.hasOwnProperty("groupInfo"))
                object.groupInfo = $root.immessage.GroupInfo.toObject(message.groupInfo, options);
            if (message.mergedMsgs != null && message.hasOwnProperty("mergedMsgs"))
                object.mergedMsgs = $root.immessage.MergedMsgs.toObject(message.mergedMsgs, options);
            if (message.undisturbType != null && message.hasOwnProperty("undisturbType"))
                object.undisturbType = message.undisturbType;
            if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                object.memberCount = message.memberCount;
            if (message.readCount != null && message.hasOwnProperty("readCount"))
                object.readCount = message.readCount;
            if (message.unreadIndex != null && message.hasOwnProperty("unreadIndex"))
                if (typeof message.unreadIndex === "number")
                    object.unreadIndex = options.longs === String ? String(message.unreadIndex) : message.unreadIndex;
                else
                    object.unreadIndex = options.longs === String ? $util.Long.prototype.toString.call(message.unreadIndex) : options.longs === Number ? new $util.LongBits(message.unreadIndex.low >>> 0, message.unreadIndex.high >>> 0).toNumber() : message.unreadIndex;
            if (message.streamMsgParts && message.streamMsgParts.length) {
                object.streamMsgParts = [];
                for (let j = 0; j < message.streamMsgParts.length; ++j)
                    object.streamMsgParts[j] = $root.immessage.StreamMsgItem.toObject(message.streamMsgParts[j], options);
            }
            if (message.msgExSet && message.msgExSet.length) {
                object.msgExSet = [];
                for (let j = 0; j < message.msgExSet.length; ++j)
                    object.msgExSet[j] = $root.immessage.MsgExtItem.toObject(message.msgExSet[j], options);
            }
            if (message.msgExts && message.msgExts.length) {
                object.msgExts = [];
                for (let j = 0; j < message.msgExts.length; ++j)
                    object.msgExts[j] = $root.immessage.MsgExtItem.toObject(message.msgExts[j], options);
            }
            if (message.converTags && message.converTags.length) {
                object.converTags = [];
                for (let j = 0; j < message.converTags.length; ++j)
                    object.converTags[j] = $root.immessage.ConverTag.toObject(message.converTags[j], options);
            }
            let keys2;
            if (message.transMsgMap && (keys2 = Object.keys(message.transMsgMap)).length) {
                object.transMsgMap = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.transMsgMap[keys2[j]] = $root.immessage.TransMsgContent.toObject(message.transMsgMap[keys2[j]], options);
            }
            if (message.SearchText != null && message.hasOwnProperty("SearchText"))
                object.SearchText = message.SearchText;
            if (message.grpMemberInfo != null && message.hasOwnProperty("grpMemberInfo"))
                object.grpMemberInfo = $root.immessage.GrpMemberInfo.toObject(message.grpMemberInfo, options);
            return object;
        };

        /**
         * Converts this DownMsg to JSON.
         * @function toJSON
         * @memberof immessage.DownMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DownMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DownMsg
         * @function getTypeUrl
         * @memberof immessage.DownMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DownMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.DownMsg";
        };

        return DownMsg;
    })();

    immessage.TransMsgContent = (function() {

        /**
         * Properties of a TransMsgContent.
         * @memberof immessage
         * @interface ITransMsgContent
         * @property {string|null} [lang] TransMsgContent lang
         * @property {Uint8Array|null} [msgContent] TransMsgContent msgContent
         * @property {immessage.IPushData|null} [pushData] TransMsgContent pushData
         */

        /**
         * Constructs a new TransMsgContent.
         * @memberof immessage
         * @classdesc Represents a TransMsgContent.
         * @implements ITransMsgContent
         * @constructor
         * @param {immessage.ITransMsgContent=} [properties] Properties to set
         */
        function TransMsgContent(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransMsgContent lang.
         * @member {string} lang
         * @memberof immessage.TransMsgContent
         * @instance
         */
        TransMsgContent.prototype.lang = "";

        /**
         * TransMsgContent msgContent.
         * @member {Uint8Array} msgContent
         * @memberof immessage.TransMsgContent
         * @instance
         */
        TransMsgContent.prototype.msgContent = $util.newBuffer([]);

        /**
         * TransMsgContent pushData.
         * @member {immessage.IPushData|null|undefined} pushData
         * @memberof immessage.TransMsgContent
         * @instance
         */
        TransMsgContent.prototype.pushData = null;

        /**
         * Creates a new TransMsgContent instance using the specified properties.
         * @function create
         * @memberof immessage.TransMsgContent
         * @static
         * @param {immessage.ITransMsgContent=} [properties] Properties to set
         * @returns {immessage.TransMsgContent} TransMsgContent instance
         */
        TransMsgContent.create = function create(properties) {
            return new TransMsgContent(properties);
        };

        /**
         * Encodes the specified TransMsgContent message. Does not implicitly {@link immessage.TransMsgContent.verify|verify} messages.
         * @function encode
         * @memberof immessage.TransMsgContent
         * @static
         * @param {immessage.ITransMsgContent} message TransMsgContent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransMsgContent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lang != null && Object.hasOwnProperty.call(message, "lang"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.lang);
            if (message.msgContent != null && Object.hasOwnProperty.call(message, "msgContent"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.msgContent);
            if (message.pushData != null && Object.hasOwnProperty.call(message, "pushData"))
                $root.immessage.PushData.encode(message.pushData, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TransMsgContent message, length delimited. Does not implicitly {@link immessage.TransMsgContent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.TransMsgContent
         * @static
         * @param {immessage.ITransMsgContent} message TransMsgContent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransMsgContent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransMsgContent message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.TransMsgContent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.TransMsgContent} TransMsgContent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransMsgContent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.TransMsgContent();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.lang = reader.string();
                        break;
                    }
                case 2: {
                        message.msgContent = reader.bytes();
                        break;
                    }
                case 3: {
                        message.pushData = $root.immessage.PushData.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransMsgContent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.TransMsgContent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.TransMsgContent} TransMsgContent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransMsgContent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransMsgContent message.
         * @function verify
         * @memberof immessage.TransMsgContent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransMsgContent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lang != null && message.hasOwnProperty("lang"))
                if (!$util.isString(message.lang))
                    return "lang: string expected";
            if (message.msgContent != null && message.hasOwnProperty("msgContent"))
                if (!(message.msgContent && typeof message.msgContent.length === "number" || $util.isString(message.msgContent)))
                    return "msgContent: buffer expected";
            if (message.pushData != null && message.hasOwnProperty("pushData")) {
                let error = $root.immessage.PushData.verify(message.pushData);
                if (error)
                    return "pushData." + error;
            }
            return null;
        };

        /**
         * Creates a TransMsgContent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.TransMsgContent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.TransMsgContent} TransMsgContent
         */
        TransMsgContent.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.TransMsgContent)
                return object;
            let message = new $root.immessage.TransMsgContent();
            if (object.lang != null)
                message.lang = String(object.lang);
            if (object.msgContent != null)
                if (typeof object.msgContent === "string")
                    $util.base64.decode(object.msgContent, message.msgContent = $util.newBuffer($util.base64.length(object.msgContent)), 0);
                else if (object.msgContent.length >= 0)
                    message.msgContent = object.msgContent;
            if (object.pushData != null) {
                if (typeof object.pushData !== "object")
                    throw TypeError(".immessage.TransMsgContent.pushData: object expected");
                message.pushData = $root.immessage.PushData.fromObject(object.pushData);
            }
            return message;
        };

        /**
         * Creates a plain object from a TransMsgContent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.TransMsgContent
         * @static
         * @param {immessage.TransMsgContent} message TransMsgContent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransMsgContent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.lang = "";
                if (options.bytes === String)
                    object.msgContent = "";
                else {
                    object.msgContent = [];
                    if (options.bytes !== Array)
                        object.msgContent = $util.newBuffer(object.msgContent);
                }
                object.pushData = null;
            }
            if (message.lang != null && message.hasOwnProperty("lang"))
                object.lang = message.lang;
            if (message.msgContent != null && message.hasOwnProperty("msgContent"))
                object.msgContent = options.bytes === String ? $util.base64.encode(message.msgContent, 0, message.msgContent.length) : options.bytes === Array ? Array.prototype.slice.call(message.msgContent) : message.msgContent;
            if (message.pushData != null && message.hasOwnProperty("pushData"))
                object.pushData = $root.immessage.PushData.toObject(message.pushData, options);
            return object;
        };

        /**
         * Converts this TransMsgContent to JSON.
         * @function toJSON
         * @memberof immessage.TransMsgContent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransMsgContent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TransMsgContent
         * @function getTypeUrl
         * @memberof immessage.TransMsgContent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransMsgContent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.TransMsgContent";
        };

        return TransMsgContent;
    })();

    immessage.MsgAck = (function() {

        /**
         * Properties of a MsgAck.
         * @memberof immessage
         * @interface IMsgAck
         * @property {string|null} [msgId] MsgAck msgId
         * @property {number|Long|null} [msgTime] MsgAck msgTime
         */

        /**
         * Constructs a new MsgAck.
         * @memberof immessage
         * @classdesc Represents a MsgAck.
         * @implements IMsgAck
         * @constructor
         * @param {immessage.IMsgAck=} [properties] Properties to set
         */
        function MsgAck(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgAck msgId.
         * @member {string} msgId
         * @memberof immessage.MsgAck
         * @instance
         */
        MsgAck.prototype.msgId = "";

        /**
         * MsgAck msgTime.
         * @member {number|Long} msgTime
         * @memberof immessage.MsgAck
         * @instance
         */
        MsgAck.prototype.msgTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new MsgAck instance using the specified properties.
         * @function create
         * @memberof immessage.MsgAck
         * @static
         * @param {immessage.IMsgAck=} [properties] Properties to set
         * @returns {immessage.MsgAck} MsgAck instance
         */
        MsgAck.create = function create(properties) {
            return new MsgAck(properties);
        };

        /**
         * Encodes the specified MsgAck message. Does not implicitly {@link immessage.MsgAck.verify|verify} messages.
         * @function encode
         * @memberof immessage.MsgAck
         * @static
         * @param {immessage.IMsgAck} message MsgAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.msgId);
            if (message.msgTime != null && Object.hasOwnProperty.call(message, "msgTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.msgTime);
            return writer;
        };

        /**
         * Encodes the specified MsgAck message, length delimited. Does not implicitly {@link immessage.MsgAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.MsgAck
         * @static
         * @param {immessage.IMsgAck} message MsgAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgAck message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.MsgAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.MsgAck} MsgAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.MsgAck();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.msgId = reader.string();
                        break;
                    }
                case 2: {
                        message.msgTime = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MsgAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.MsgAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.MsgAck} MsgAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgAck message.
         * @function verify
         * @memberof immessage.MsgAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (!$util.isInteger(message.msgTime) && !(message.msgTime && $util.isInteger(message.msgTime.low) && $util.isInteger(message.msgTime.high)))
                    return "msgTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a MsgAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.MsgAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.MsgAck} MsgAck
         */
        MsgAck.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.MsgAck)
                return object;
            let message = new $root.immessage.MsgAck();
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            if (object.msgTime != null)
                if ($util.Long)
                    (message.msgTime = $util.Long.fromValue(object.msgTime)).unsigned = false;
                else if (typeof object.msgTime === "string")
                    message.msgTime = parseInt(object.msgTime, 10);
                else if (typeof object.msgTime === "number")
                    message.msgTime = object.msgTime;
                else if (typeof object.msgTime === "object")
                    message.msgTime = new $util.LongBits(object.msgTime.low >>> 0, object.msgTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a MsgAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.MsgAck
         * @static
         * @param {immessage.MsgAck} message MsgAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.msgId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.msgTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msgTime = options.longs === String ? "0" : 0;
            }
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (typeof message.msgTime === "number")
                    object.msgTime = options.longs === String ? String(message.msgTime) : message.msgTime;
                else
                    object.msgTime = options.longs === String ? $util.Long.prototype.toString.call(message.msgTime) : options.longs === Number ? new $util.LongBits(message.msgTime.low >>> 0, message.msgTime.high >>> 0).toNumber() : message.msgTime;
            return object;
        };

        /**
         * Converts this MsgAck to JSON.
         * @function toJSON
         * @memberof immessage.MsgAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MsgAck
         * @function getTypeUrl
         * @memberof immessage.MsgAck
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MsgAck.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.MsgAck";
        };

        return MsgAck;
    })();

    immessage.StreamMsgItem = (function() {

        /**
         * Properties of a StreamMsgItem.
         * @memberof immessage
         * @interface IStreamMsgItem
         * @property {immessage.StreamEvent|null} [event] StreamMsgItem event
         * @property {number|Long|null} [subSeq] StreamMsgItem subSeq
         * @property {Uint8Array|null} [partialContent] StreamMsgItem partialContent
         */

        /**
         * Constructs a new StreamMsgItem.
         * @memberof immessage
         * @classdesc Represents a StreamMsgItem.
         * @implements IStreamMsgItem
         * @constructor
         * @param {immessage.IStreamMsgItem=} [properties] Properties to set
         */
        function StreamMsgItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamMsgItem event.
         * @member {immessage.StreamEvent} event
         * @memberof immessage.StreamMsgItem
         * @instance
         */
        StreamMsgItem.prototype.event = 0;

        /**
         * StreamMsgItem subSeq.
         * @member {number|Long} subSeq
         * @memberof immessage.StreamMsgItem
         * @instance
         */
        StreamMsgItem.prototype.subSeq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StreamMsgItem partialContent.
         * @member {Uint8Array} partialContent
         * @memberof immessage.StreamMsgItem
         * @instance
         */
        StreamMsgItem.prototype.partialContent = $util.newBuffer([]);

        /**
         * Creates a new StreamMsgItem instance using the specified properties.
         * @function create
         * @memberof immessage.StreamMsgItem
         * @static
         * @param {immessage.IStreamMsgItem=} [properties] Properties to set
         * @returns {immessage.StreamMsgItem} StreamMsgItem instance
         */
        StreamMsgItem.create = function create(properties) {
            return new StreamMsgItem(properties);
        };

        /**
         * Encodes the specified StreamMsgItem message. Does not implicitly {@link immessage.StreamMsgItem.verify|verify} messages.
         * @function encode
         * @memberof immessage.StreamMsgItem
         * @static
         * @param {immessage.IStreamMsgItem} message StreamMsgItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamMsgItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.event);
            if (message.subSeq != null && Object.hasOwnProperty.call(message, "subSeq"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.subSeq);
            if (message.partialContent != null && Object.hasOwnProperty.call(message, "partialContent"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.partialContent);
            return writer;
        };

        /**
         * Encodes the specified StreamMsgItem message, length delimited. Does not implicitly {@link immessage.StreamMsgItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.StreamMsgItem
         * @static
         * @param {immessage.IStreamMsgItem} message StreamMsgItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamMsgItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StreamMsgItem message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.StreamMsgItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.StreamMsgItem} StreamMsgItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamMsgItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.StreamMsgItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.event = reader.int32();
                        break;
                    }
                case 2: {
                        message.subSeq = reader.int64();
                        break;
                    }
                case 3: {
                        message.partialContent = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StreamMsgItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.StreamMsgItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.StreamMsgItem} StreamMsgItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamMsgItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StreamMsgItem message.
         * @function verify
         * @memberof immessage.StreamMsgItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StreamMsgItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event != null && message.hasOwnProperty("event"))
                switch (message.event) {
                default:
                    return "event: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.subSeq != null && message.hasOwnProperty("subSeq"))
                if (!$util.isInteger(message.subSeq) && !(message.subSeq && $util.isInteger(message.subSeq.low) && $util.isInteger(message.subSeq.high)))
                    return "subSeq: integer|Long expected";
            if (message.partialContent != null && message.hasOwnProperty("partialContent"))
                if (!(message.partialContent && typeof message.partialContent.length === "number" || $util.isString(message.partialContent)))
                    return "partialContent: buffer expected";
            return null;
        };

        /**
         * Creates a StreamMsgItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.StreamMsgItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.StreamMsgItem} StreamMsgItem
         */
        StreamMsgItem.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.StreamMsgItem)
                return object;
            let message = new $root.immessage.StreamMsgItem();
            switch (object.event) {
            default:
                if (typeof object.event === "number") {
                    message.event = object.event;
                    break;
                }
                break;
            case "DefaultStreamEvent":
            case 0:
                message.event = 0;
                break;
            case "StreamMessage":
            case 1:
                message.event = 1;
                break;
            case "StreamComplete":
            case 2:
                message.event = 2;
                break;
            }
            if (object.subSeq != null)
                if ($util.Long)
                    (message.subSeq = $util.Long.fromValue(object.subSeq)).unsigned = false;
                else if (typeof object.subSeq === "string")
                    message.subSeq = parseInt(object.subSeq, 10);
                else if (typeof object.subSeq === "number")
                    message.subSeq = object.subSeq;
                else if (typeof object.subSeq === "object")
                    message.subSeq = new $util.LongBits(object.subSeq.low >>> 0, object.subSeq.high >>> 0).toNumber();
            if (object.partialContent != null)
                if (typeof object.partialContent === "string")
                    $util.base64.decode(object.partialContent, message.partialContent = $util.newBuffer($util.base64.length(object.partialContent)), 0);
                else if (object.partialContent.length >= 0)
                    message.partialContent = object.partialContent;
            return message;
        };

        /**
         * Creates a plain object from a StreamMsgItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.StreamMsgItem
         * @static
         * @param {immessage.StreamMsgItem} message StreamMsgItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StreamMsgItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.event = options.enums === String ? "DefaultStreamEvent" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.subSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.subSeq = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.partialContent = "";
                else {
                    object.partialContent = [];
                    if (options.bytes !== Array)
                        object.partialContent = $util.newBuffer(object.partialContent);
                }
            }
            if (message.event != null && message.hasOwnProperty("event"))
                object.event = options.enums === String ? $root.immessage.StreamEvent[message.event] === undefined ? message.event : $root.immessage.StreamEvent[message.event] : message.event;
            if (message.subSeq != null && message.hasOwnProperty("subSeq"))
                if (typeof message.subSeq === "number")
                    object.subSeq = options.longs === String ? String(message.subSeq) : message.subSeq;
                else
                    object.subSeq = options.longs === String ? $util.Long.prototype.toString.call(message.subSeq) : options.longs === Number ? new $util.LongBits(message.subSeq.low >>> 0, message.subSeq.high >>> 0).toNumber() : message.subSeq;
            if (message.partialContent != null && message.hasOwnProperty("partialContent"))
                object.partialContent = options.bytes === String ? $util.base64.encode(message.partialContent, 0, message.partialContent.length) : options.bytes === Array ? Array.prototype.slice.call(message.partialContent) : message.partialContent;
            return object;
        };

        /**
         * Converts this StreamMsgItem to JSON.
         * @function toJSON
         * @memberof immessage.StreamMsgItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StreamMsgItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for StreamMsgItem
         * @function getTypeUrl
         * @memberof immessage.StreamMsgItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        StreamMsgItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.StreamMsgItem";
        };

        return StreamMsgItem;
    })();

    immessage.StreamDownMsg = (function() {

        /**
         * Properties of a StreamDownMsg.
         * @memberof immessage
         * @interface IStreamDownMsg
         * @property {string|null} [targetId] StreamDownMsg targetId
         * @property {immessage.ChannelType|null} [channelType] StreamDownMsg channelType
         * @property {string|null} [msgId] StreamDownMsg msgId
         * @property {Array.<immessage.IStreamMsgItem>|null} [msgItems] StreamDownMsg msgItems
         * @property {string|null} [msgType] StreamDownMsg msgType
         */

        /**
         * Constructs a new StreamDownMsg.
         * @memberof immessage
         * @classdesc Represents a StreamDownMsg.
         * @implements IStreamDownMsg
         * @constructor
         * @param {immessage.IStreamDownMsg=} [properties] Properties to set
         */
        function StreamDownMsg(properties) {
            this.msgItems = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamDownMsg targetId.
         * @member {string} targetId
         * @memberof immessage.StreamDownMsg
         * @instance
         */
        StreamDownMsg.prototype.targetId = "";

        /**
         * StreamDownMsg channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.StreamDownMsg
         * @instance
         */
        StreamDownMsg.prototype.channelType = 0;

        /**
         * StreamDownMsg msgId.
         * @member {string} msgId
         * @memberof immessage.StreamDownMsg
         * @instance
         */
        StreamDownMsg.prototype.msgId = "";

        /**
         * StreamDownMsg msgItems.
         * @member {Array.<immessage.IStreamMsgItem>} msgItems
         * @memberof immessage.StreamDownMsg
         * @instance
         */
        StreamDownMsg.prototype.msgItems = $util.emptyArray;

        /**
         * StreamDownMsg msgType.
         * @member {string} msgType
         * @memberof immessage.StreamDownMsg
         * @instance
         */
        StreamDownMsg.prototype.msgType = "";

        /**
         * Creates a new StreamDownMsg instance using the specified properties.
         * @function create
         * @memberof immessage.StreamDownMsg
         * @static
         * @param {immessage.IStreamDownMsg=} [properties] Properties to set
         * @returns {immessage.StreamDownMsg} StreamDownMsg instance
         */
        StreamDownMsg.create = function create(properties) {
            return new StreamDownMsg(properties);
        };

        /**
         * Encodes the specified StreamDownMsg message. Does not implicitly {@link immessage.StreamDownMsg.verify|verify} messages.
         * @function encode
         * @memberof immessage.StreamDownMsg
         * @static
         * @param {immessage.IStreamDownMsg} message StreamDownMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamDownMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.msgId);
            if (message.msgItems != null && message.msgItems.length)
                for (let i = 0; i < message.msgItems.length; ++i)
                    $root.immessage.StreamMsgItem.encode(message.msgItems[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.msgType != null && Object.hasOwnProperty.call(message, "msgType"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.msgType);
            return writer;
        };

        /**
         * Encodes the specified StreamDownMsg message, length delimited. Does not implicitly {@link immessage.StreamDownMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.StreamDownMsg
         * @static
         * @param {immessage.IStreamDownMsg} message StreamDownMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamDownMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StreamDownMsg message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.StreamDownMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.StreamDownMsg} StreamDownMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamDownMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.StreamDownMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        message.msgId = reader.string();
                        break;
                    }
                case 4: {
                        if (!(message.msgItems && message.msgItems.length))
                            message.msgItems = [];
                        message.msgItems.push($root.immessage.StreamMsgItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.msgType = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StreamDownMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.StreamDownMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.StreamDownMsg} StreamDownMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamDownMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StreamDownMsg message.
         * @function verify
         * @memberof immessage.StreamDownMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StreamDownMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            if (message.msgItems != null && message.hasOwnProperty("msgItems")) {
                if (!Array.isArray(message.msgItems))
                    return "msgItems: array expected";
                for (let i = 0; i < message.msgItems.length; ++i) {
                    let error = $root.immessage.StreamMsgItem.verify(message.msgItems[i]);
                    if (error)
                        return "msgItems." + error;
                }
            }
            if (message.msgType != null && message.hasOwnProperty("msgType"))
                if (!$util.isString(message.msgType))
                    return "msgType: string expected";
            return null;
        };

        /**
         * Creates a StreamDownMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.StreamDownMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.StreamDownMsg} StreamDownMsg
         */
        StreamDownMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.StreamDownMsg)
                return object;
            let message = new $root.immessage.StreamDownMsg();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            if (object.msgItems) {
                if (!Array.isArray(object.msgItems))
                    throw TypeError(".immessage.StreamDownMsg.msgItems: array expected");
                message.msgItems = [];
                for (let i = 0; i < object.msgItems.length; ++i) {
                    if (typeof object.msgItems[i] !== "object")
                        throw TypeError(".immessage.StreamDownMsg.msgItems: object expected");
                    message.msgItems[i] = $root.immessage.StreamMsgItem.fromObject(object.msgItems[i]);
                }
            }
            if (object.msgType != null)
                message.msgType = String(object.msgType);
            return message;
        };

        /**
         * Creates a plain object from a StreamDownMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.StreamDownMsg
         * @static
         * @param {immessage.StreamDownMsg} message StreamDownMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StreamDownMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.msgItems = [];
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                object.msgId = "";
                object.msgType = "";
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            if (message.msgItems && message.msgItems.length) {
                object.msgItems = [];
                for (let j = 0; j < message.msgItems.length; ++j)
                    object.msgItems[j] = $root.immessage.StreamMsgItem.toObject(message.msgItems[j], options);
            }
            if (message.msgType != null && message.hasOwnProperty("msgType"))
                object.msgType = message.msgType;
            return object;
        };

        /**
         * Converts this StreamDownMsg to JSON.
         * @function toJSON
         * @memberof immessage.StreamDownMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StreamDownMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for StreamDownMsg
         * @function getTypeUrl
         * @memberof immessage.StreamDownMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        StreamDownMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.StreamDownMsg";
        };

        return StreamDownMsg;
    })();

    /**
     * StreamEvent enum.
     * @name immessage.StreamEvent
     * @enum {number}
     * @property {number} DefaultStreamEvent=0 DefaultStreamEvent value
     * @property {number} StreamMessage=1 StreamMessage value
     * @property {number} StreamComplete=2 StreamComplete value
     */
    immessage.StreamEvent = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DefaultStreamEvent"] = 0;
        values[valuesById[1] = "StreamMessage"] = 1;
        values[valuesById[2] = "StreamComplete"] = 2;
        return values;
    })();

    /**
     * ChannelType enum.
     * @name immessage.ChannelType
     * @enum {number}
     * @property {number} Unknown=0 Unknown value
     * @property {number} Private=1 Private value
     * @property {number} Group=2 Group value
     * @property {number} Chatroom=3 Chatroom value
     * @property {number} System=4 System value
     * @property {number} GroupCast=5 GroupCast value
     * @property {number} BroadCast=6 BroadCast value
     */
    immessage.ChannelType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Unknown"] = 0;
        values[valuesById[1] = "Private"] = 1;
        values[valuesById[2] = "Group"] = 2;
        values[valuesById[3] = "Chatroom"] = 3;
        values[valuesById[4] = "System"] = 4;
        values[valuesById[5] = "GroupCast"] = 5;
        values[valuesById[6] = "BroadCast"] = 6;
        return values;
    })();

    immessage.Notify = (function() {

        /**
         * Properties of a Notify.
         * @memberof immessage
         * @interface INotify
         * @property {immessage.NotifyType|null} [type] Notify type
         * @property {number|Long|null} [syncTime] Notify syncTime
         * @property {string|null} [chatroomId] Notify chatroomId
         */

        /**
         * Constructs a new Notify.
         * @memberof immessage
         * @classdesc Represents a Notify.
         * @implements INotify
         * @constructor
         * @param {immessage.INotify=} [properties] Properties to set
         */
        function Notify(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Notify type.
         * @member {immessage.NotifyType} type
         * @memberof immessage.Notify
         * @instance
         */
        Notify.prototype.type = 0;

        /**
         * Notify syncTime.
         * @member {number|Long} syncTime
         * @memberof immessage.Notify
         * @instance
         */
        Notify.prototype.syncTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Notify chatroomId.
         * @member {string} chatroomId
         * @memberof immessage.Notify
         * @instance
         */
        Notify.prototype.chatroomId = "";

        /**
         * Creates a new Notify instance using the specified properties.
         * @function create
         * @memberof immessage.Notify
         * @static
         * @param {immessage.INotify=} [properties] Properties to set
         * @returns {immessage.Notify} Notify instance
         */
        Notify.create = function create(properties) {
            return new Notify(properties);
        };

        /**
         * Encodes the specified Notify message. Does not implicitly {@link immessage.Notify.verify|verify} messages.
         * @function encode
         * @memberof immessage.Notify
         * @static
         * @param {immessage.INotify} message Notify message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Notify.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.syncTime != null && Object.hasOwnProperty.call(message, "syncTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.syncTime);
            if (message.chatroomId != null && Object.hasOwnProperty.call(message, "chatroomId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.chatroomId);
            return writer;
        };

        /**
         * Encodes the specified Notify message, length delimited. Does not implicitly {@link immessage.Notify.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.Notify
         * @static
         * @param {immessage.INotify} message Notify message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Notify.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Notify message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.Notify
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.Notify} Notify
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Notify.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.Notify();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.syncTime = reader.int64();
                        break;
                    }
                case 3: {
                        message.chatroomId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Notify message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.Notify
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.Notify} Notify
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Notify.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Notify message.
         * @function verify
         * @memberof immessage.Notify
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Notify.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.syncTime != null && message.hasOwnProperty("syncTime"))
                if (!$util.isInteger(message.syncTime) && !(message.syncTime && $util.isInteger(message.syncTime.low) && $util.isInteger(message.syncTime.high)))
                    return "syncTime: integer|Long expected";
            if (message.chatroomId != null && message.hasOwnProperty("chatroomId"))
                if (!$util.isString(message.chatroomId))
                    return "chatroomId: string expected";
            return null;
        };

        /**
         * Creates a Notify message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.Notify
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.Notify} Notify
         */
        Notify.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.Notify)
                return object;
            let message = new $root.immessage.Notify();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "Default":
            case 0:
                message.type = 0;
                break;
            case "Msg":
            case 1:
                message.type = 1;
                break;
            case "ChatroomMsg":
            case 2:
                message.type = 2;
                break;
            case "ChatroomAtt":
            case 3:
                message.type = 3;
                break;
            case "ChatroomEvent":
            case 4:
                message.type = 4;
                break;
            case "ChatroomDestroy":
            case 5:
                message.type = 5;
                break;
            }
            if (object.syncTime != null)
                if ($util.Long)
                    (message.syncTime = $util.Long.fromValue(object.syncTime)).unsigned = false;
                else if (typeof object.syncTime === "string")
                    message.syncTime = parseInt(object.syncTime, 10);
                else if (typeof object.syncTime === "number")
                    message.syncTime = object.syncTime;
                else if (typeof object.syncTime === "object")
                    message.syncTime = new $util.LongBits(object.syncTime.low >>> 0, object.syncTime.high >>> 0).toNumber();
            if (object.chatroomId != null)
                message.chatroomId = String(object.chatroomId);
            return message;
        };

        /**
         * Creates a plain object from a Notify message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.Notify
         * @static
         * @param {immessage.Notify} message Notify
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Notify.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "Default" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.syncTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.syncTime = options.longs === String ? "0" : 0;
                object.chatroomId = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.immessage.NotifyType[message.type] === undefined ? message.type : $root.immessage.NotifyType[message.type] : message.type;
            if (message.syncTime != null && message.hasOwnProperty("syncTime"))
                if (typeof message.syncTime === "number")
                    object.syncTime = options.longs === String ? String(message.syncTime) : message.syncTime;
                else
                    object.syncTime = options.longs === String ? $util.Long.prototype.toString.call(message.syncTime) : options.longs === Number ? new $util.LongBits(message.syncTime.low >>> 0, message.syncTime.high >>> 0).toNumber() : message.syncTime;
            if (message.chatroomId != null && message.hasOwnProperty("chatroomId"))
                object.chatroomId = message.chatroomId;
            return object;
        };

        /**
         * Converts this Notify to JSON.
         * @function toJSON
         * @memberof immessage.Notify
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Notify.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Notify
         * @function getTypeUrl
         * @memberof immessage.Notify
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Notify.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.Notify";
        };

        return Notify;
    })();

    /**
     * NotifyType enum.
     * @name immessage.NotifyType
     * @enum {number}
     * @property {number} Default=0 Default value
     * @property {number} Msg=1 Msg value
     * @property {number} ChatroomMsg=2 ChatroomMsg value
     * @property {number} ChatroomAtt=3 ChatroomAtt value
     * @property {number} ChatroomEvent=4 ChatroomEvent value
     * @property {number} ChatroomDestroy=5 ChatroomDestroy value
     */
    immessage.NotifyType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Default"] = 0;
        values[valuesById[1] = "Msg"] = 1;
        values[valuesById[2] = "ChatroomMsg"] = 2;
        values[valuesById[3] = "ChatroomAtt"] = 3;
        values[valuesById[4] = "ChatroomEvent"] = 4;
        values[valuesById[5] = "ChatroomDestroy"] = 5;
        return values;
    })();

    immessage.SyncMsgReq = (function() {

        /**
         * Properties of a SyncMsgReq.
         * @memberof immessage
         * @interface ISyncMsgReq
         * @property {number|Long|null} [syncTime] SyncMsgReq syncTime
         * @property {boolean|null} [containsSendBox] SyncMsgReq containsSendBox
         * @property {number|Long|null} [sendBoxSyncTime] SyncMsgReq sendBoxSyncTime
         * @property {Array.<immessage.IPermitConver>|null} [permitConvers] SyncMsgReq permitConvers
         */

        /**
         * Constructs a new SyncMsgReq.
         * @memberof immessage
         * @classdesc Represents a SyncMsgReq.
         * @implements ISyncMsgReq
         * @constructor
         * @param {immessage.ISyncMsgReq=} [properties] Properties to set
         */
        function SyncMsgReq(properties) {
            this.permitConvers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncMsgReq syncTime.
         * @member {number|Long} syncTime
         * @memberof immessage.SyncMsgReq
         * @instance
         */
        SyncMsgReq.prototype.syncTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SyncMsgReq containsSendBox.
         * @member {boolean} containsSendBox
         * @memberof immessage.SyncMsgReq
         * @instance
         */
        SyncMsgReq.prototype.containsSendBox = false;

        /**
         * SyncMsgReq sendBoxSyncTime.
         * @member {number|Long} sendBoxSyncTime
         * @memberof immessage.SyncMsgReq
         * @instance
         */
        SyncMsgReq.prototype.sendBoxSyncTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SyncMsgReq permitConvers.
         * @member {Array.<immessage.IPermitConver>} permitConvers
         * @memberof immessage.SyncMsgReq
         * @instance
         */
        SyncMsgReq.prototype.permitConvers = $util.emptyArray;

        /**
         * Creates a new SyncMsgReq instance using the specified properties.
         * @function create
         * @memberof immessage.SyncMsgReq
         * @static
         * @param {immessage.ISyncMsgReq=} [properties] Properties to set
         * @returns {immessage.SyncMsgReq} SyncMsgReq instance
         */
        SyncMsgReq.create = function create(properties) {
            return new SyncMsgReq(properties);
        };

        /**
         * Encodes the specified SyncMsgReq message. Does not implicitly {@link immessage.SyncMsgReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.SyncMsgReq
         * @static
         * @param {immessage.ISyncMsgReq} message SyncMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncMsgReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.syncTime != null && Object.hasOwnProperty.call(message, "syncTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.syncTime);
            if (message.containsSendBox != null && Object.hasOwnProperty.call(message, "containsSendBox"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.containsSendBox);
            if (message.sendBoxSyncTime != null && Object.hasOwnProperty.call(message, "sendBoxSyncTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.sendBoxSyncTime);
            if (message.permitConvers != null && message.permitConvers.length)
                for (let i = 0; i < message.permitConvers.length; ++i)
                    $root.immessage.PermitConver.encode(message.permitConvers[i], writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SyncMsgReq message, length delimited. Does not implicitly {@link immessage.SyncMsgReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.SyncMsgReq
         * @static
         * @param {immessage.ISyncMsgReq} message SyncMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncMsgReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncMsgReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.SyncMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.SyncMsgReq} SyncMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncMsgReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.SyncMsgReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.syncTime = reader.int64();
                        break;
                    }
                case 2: {
                        message.containsSendBox = reader.bool();
                        break;
                    }
                case 3: {
                        message.sendBoxSyncTime = reader.int64();
                        break;
                    }
                case 51: {
                        if (!(message.permitConvers && message.permitConvers.length))
                            message.permitConvers = [];
                        message.permitConvers.push($root.immessage.PermitConver.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncMsgReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.SyncMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.SyncMsgReq} SyncMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncMsgReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncMsgReq message.
         * @function verify
         * @memberof immessage.SyncMsgReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncMsgReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.syncTime != null && message.hasOwnProperty("syncTime"))
                if (!$util.isInteger(message.syncTime) && !(message.syncTime && $util.isInteger(message.syncTime.low) && $util.isInteger(message.syncTime.high)))
                    return "syncTime: integer|Long expected";
            if (message.containsSendBox != null && message.hasOwnProperty("containsSendBox"))
                if (typeof message.containsSendBox !== "boolean")
                    return "containsSendBox: boolean expected";
            if (message.sendBoxSyncTime != null && message.hasOwnProperty("sendBoxSyncTime"))
                if (!$util.isInteger(message.sendBoxSyncTime) && !(message.sendBoxSyncTime && $util.isInteger(message.sendBoxSyncTime.low) && $util.isInteger(message.sendBoxSyncTime.high)))
                    return "sendBoxSyncTime: integer|Long expected";
            if (message.permitConvers != null && message.hasOwnProperty("permitConvers")) {
                if (!Array.isArray(message.permitConvers))
                    return "permitConvers: array expected";
                for (let i = 0; i < message.permitConvers.length; ++i) {
                    let error = $root.immessage.PermitConver.verify(message.permitConvers[i]);
                    if (error)
                        return "permitConvers." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SyncMsgReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.SyncMsgReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.SyncMsgReq} SyncMsgReq
         */
        SyncMsgReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.SyncMsgReq)
                return object;
            let message = new $root.immessage.SyncMsgReq();
            if (object.syncTime != null)
                if ($util.Long)
                    (message.syncTime = $util.Long.fromValue(object.syncTime)).unsigned = false;
                else if (typeof object.syncTime === "string")
                    message.syncTime = parseInt(object.syncTime, 10);
                else if (typeof object.syncTime === "number")
                    message.syncTime = object.syncTime;
                else if (typeof object.syncTime === "object")
                    message.syncTime = new $util.LongBits(object.syncTime.low >>> 0, object.syncTime.high >>> 0).toNumber();
            if (object.containsSendBox != null)
                message.containsSendBox = Boolean(object.containsSendBox);
            if (object.sendBoxSyncTime != null)
                if ($util.Long)
                    (message.sendBoxSyncTime = $util.Long.fromValue(object.sendBoxSyncTime)).unsigned = false;
                else if (typeof object.sendBoxSyncTime === "string")
                    message.sendBoxSyncTime = parseInt(object.sendBoxSyncTime, 10);
                else if (typeof object.sendBoxSyncTime === "number")
                    message.sendBoxSyncTime = object.sendBoxSyncTime;
                else if (typeof object.sendBoxSyncTime === "object")
                    message.sendBoxSyncTime = new $util.LongBits(object.sendBoxSyncTime.low >>> 0, object.sendBoxSyncTime.high >>> 0).toNumber();
            if (object.permitConvers) {
                if (!Array.isArray(object.permitConvers))
                    throw TypeError(".immessage.SyncMsgReq.permitConvers: array expected");
                message.permitConvers = [];
                for (let i = 0; i < object.permitConvers.length; ++i) {
                    if (typeof object.permitConvers[i] !== "object")
                        throw TypeError(".immessage.SyncMsgReq.permitConvers: object expected");
                    message.permitConvers[i] = $root.immessage.PermitConver.fromObject(object.permitConvers[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SyncMsgReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.SyncMsgReq
         * @static
         * @param {immessage.SyncMsgReq} message SyncMsgReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncMsgReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.permitConvers = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.syncTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.syncTime = options.longs === String ? "0" : 0;
                object.containsSendBox = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.sendBoxSyncTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sendBoxSyncTime = options.longs === String ? "0" : 0;
            }
            if (message.syncTime != null && message.hasOwnProperty("syncTime"))
                if (typeof message.syncTime === "number")
                    object.syncTime = options.longs === String ? String(message.syncTime) : message.syncTime;
                else
                    object.syncTime = options.longs === String ? $util.Long.prototype.toString.call(message.syncTime) : options.longs === Number ? new $util.LongBits(message.syncTime.low >>> 0, message.syncTime.high >>> 0).toNumber() : message.syncTime;
            if (message.containsSendBox != null && message.hasOwnProperty("containsSendBox"))
                object.containsSendBox = message.containsSendBox;
            if (message.sendBoxSyncTime != null && message.hasOwnProperty("sendBoxSyncTime"))
                if (typeof message.sendBoxSyncTime === "number")
                    object.sendBoxSyncTime = options.longs === String ? String(message.sendBoxSyncTime) : message.sendBoxSyncTime;
                else
                    object.sendBoxSyncTime = options.longs === String ? $util.Long.prototype.toString.call(message.sendBoxSyncTime) : options.longs === Number ? new $util.LongBits(message.sendBoxSyncTime.low >>> 0, message.sendBoxSyncTime.high >>> 0).toNumber() : message.sendBoxSyncTime;
            if (message.permitConvers && message.permitConvers.length) {
                object.permitConvers = [];
                for (let j = 0; j < message.permitConvers.length; ++j)
                    object.permitConvers[j] = $root.immessage.PermitConver.toObject(message.permitConvers[j], options);
            }
            return object;
        };

        /**
         * Converts this SyncMsgReq to JSON.
         * @function toJSON
         * @memberof immessage.SyncMsgReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncMsgReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SyncMsgReq
         * @function getTypeUrl
         * @memberof immessage.SyncMsgReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SyncMsgReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.SyncMsgReq";
        };

        return SyncMsgReq;
    })();

    immessage.DownMsgSet = (function() {

        /**
         * Properties of a DownMsgSet.
         * @memberof immessage
         * @interface IDownMsgSet
         * @property {Array.<immessage.IDownMsg>|null} [msgs] DownMsgSet msgs
         * @property {number|Long|null} [syncTime] DownMsgSet syncTime
         * @property {boolean|null} [isFinished] DownMsgSet isFinished
         * @property {immessage.IUserInfo|null} [targetUserInfo] DownMsgSet targetUserInfo
         * @property {immessage.IGroupInfo|null} [groupInfo] DownMsgSet groupInfo
         */

        /**
         * Constructs a new DownMsgSet.
         * @memberof immessage
         * @classdesc Represents a DownMsgSet.
         * @implements IDownMsgSet
         * @constructor
         * @param {immessage.IDownMsgSet=} [properties] Properties to set
         */
        function DownMsgSet(properties) {
            this.msgs = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DownMsgSet msgs.
         * @member {Array.<immessage.IDownMsg>} msgs
         * @memberof immessage.DownMsgSet
         * @instance
         */
        DownMsgSet.prototype.msgs = $util.emptyArray;

        /**
         * DownMsgSet syncTime.
         * @member {number|Long} syncTime
         * @memberof immessage.DownMsgSet
         * @instance
         */
        DownMsgSet.prototype.syncTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DownMsgSet isFinished.
         * @member {boolean} isFinished
         * @memberof immessage.DownMsgSet
         * @instance
         */
        DownMsgSet.prototype.isFinished = false;

        /**
         * DownMsgSet targetUserInfo.
         * @member {immessage.IUserInfo|null|undefined} targetUserInfo
         * @memberof immessage.DownMsgSet
         * @instance
         */
        DownMsgSet.prototype.targetUserInfo = null;

        /**
         * DownMsgSet groupInfo.
         * @member {immessage.IGroupInfo|null|undefined} groupInfo
         * @memberof immessage.DownMsgSet
         * @instance
         */
        DownMsgSet.prototype.groupInfo = null;

        /**
         * Creates a new DownMsgSet instance using the specified properties.
         * @function create
         * @memberof immessage.DownMsgSet
         * @static
         * @param {immessage.IDownMsgSet=} [properties] Properties to set
         * @returns {immessage.DownMsgSet} DownMsgSet instance
         */
        DownMsgSet.create = function create(properties) {
            return new DownMsgSet(properties);
        };

        /**
         * Encodes the specified DownMsgSet message. Does not implicitly {@link immessage.DownMsgSet.verify|verify} messages.
         * @function encode
         * @memberof immessage.DownMsgSet
         * @static
         * @param {immessage.IDownMsgSet} message DownMsgSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DownMsgSet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msgs != null && message.msgs.length)
                for (let i = 0; i < message.msgs.length; ++i)
                    $root.immessage.DownMsg.encode(message.msgs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.syncTime != null && Object.hasOwnProperty.call(message, "syncTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.syncTime);
            if (message.isFinished != null && Object.hasOwnProperty.call(message, "isFinished"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isFinished);
            if (message.targetUserInfo != null && Object.hasOwnProperty.call(message, "targetUserInfo"))
                $root.immessage.UserInfo.encode(message.targetUserInfo, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.groupInfo != null && Object.hasOwnProperty.call(message, "groupInfo"))
                $root.immessage.GroupInfo.encode(message.groupInfo, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DownMsgSet message, length delimited. Does not implicitly {@link immessage.DownMsgSet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.DownMsgSet
         * @static
         * @param {immessage.IDownMsgSet} message DownMsgSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DownMsgSet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DownMsgSet message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.DownMsgSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.DownMsgSet} DownMsgSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DownMsgSet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.DownMsgSet();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.msgs && message.msgs.length))
                            message.msgs = [];
                        message.msgs.push($root.immessage.DownMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.syncTime = reader.int64();
                        break;
                    }
                case 3: {
                        message.isFinished = reader.bool();
                        break;
                    }
                case 4: {
                        message.targetUserInfo = $root.immessage.UserInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.groupInfo = $root.immessage.GroupInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DownMsgSet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.DownMsgSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.DownMsgSet} DownMsgSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DownMsgSet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DownMsgSet message.
         * @function verify
         * @memberof immessage.DownMsgSet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DownMsgSet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msgs != null && message.hasOwnProperty("msgs")) {
                if (!Array.isArray(message.msgs))
                    return "msgs: array expected";
                for (let i = 0; i < message.msgs.length; ++i) {
                    let error = $root.immessage.DownMsg.verify(message.msgs[i]);
                    if (error)
                        return "msgs." + error;
                }
            }
            if (message.syncTime != null && message.hasOwnProperty("syncTime"))
                if (!$util.isInteger(message.syncTime) && !(message.syncTime && $util.isInteger(message.syncTime.low) && $util.isInteger(message.syncTime.high)))
                    return "syncTime: integer|Long expected";
            if (message.isFinished != null && message.hasOwnProperty("isFinished"))
                if (typeof message.isFinished !== "boolean")
                    return "isFinished: boolean expected";
            if (message.targetUserInfo != null && message.hasOwnProperty("targetUserInfo")) {
                let error = $root.immessage.UserInfo.verify(message.targetUserInfo);
                if (error)
                    return "targetUserInfo." + error;
            }
            if (message.groupInfo != null && message.hasOwnProperty("groupInfo")) {
                let error = $root.immessage.GroupInfo.verify(message.groupInfo);
                if (error)
                    return "groupInfo." + error;
            }
            return null;
        };

        /**
         * Creates a DownMsgSet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.DownMsgSet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.DownMsgSet} DownMsgSet
         */
        DownMsgSet.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.DownMsgSet)
                return object;
            let message = new $root.immessage.DownMsgSet();
            if (object.msgs) {
                if (!Array.isArray(object.msgs))
                    throw TypeError(".immessage.DownMsgSet.msgs: array expected");
                message.msgs = [];
                for (let i = 0; i < object.msgs.length; ++i) {
                    if (typeof object.msgs[i] !== "object")
                        throw TypeError(".immessage.DownMsgSet.msgs: object expected");
                    message.msgs[i] = $root.immessage.DownMsg.fromObject(object.msgs[i]);
                }
            }
            if (object.syncTime != null)
                if ($util.Long)
                    (message.syncTime = $util.Long.fromValue(object.syncTime)).unsigned = false;
                else if (typeof object.syncTime === "string")
                    message.syncTime = parseInt(object.syncTime, 10);
                else if (typeof object.syncTime === "number")
                    message.syncTime = object.syncTime;
                else if (typeof object.syncTime === "object")
                    message.syncTime = new $util.LongBits(object.syncTime.low >>> 0, object.syncTime.high >>> 0).toNumber();
            if (object.isFinished != null)
                message.isFinished = Boolean(object.isFinished);
            if (object.targetUserInfo != null) {
                if (typeof object.targetUserInfo !== "object")
                    throw TypeError(".immessage.DownMsgSet.targetUserInfo: object expected");
                message.targetUserInfo = $root.immessage.UserInfo.fromObject(object.targetUserInfo);
            }
            if (object.groupInfo != null) {
                if (typeof object.groupInfo !== "object")
                    throw TypeError(".immessage.DownMsgSet.groupInfo: object expected");
                message.groupInfo = $root.immessage.GroupInfo.fromObject(object.groupInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a DownMsgSet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.DownMsgSet
         * @static
         * @param {immessage.DownMsgSet} message DownMsgSet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DownMsgSet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.msgs = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.syncTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.syncTime = options.longs === String ? "0" : 0;
                object.isFinished = false;
                object.targetUserInfo = null;
                object.groupInfo = null;
            }
            if (message.msgs && message.msgs.length) {
                object.msgs = [];
                for (let j = 0; j < message.msgs.length; ++j)
                    object.msgs[j] = $root.immessage.DownMsg.toObject(message.msgs[j], options);
            }
            if (message.syncTime != null && message.hasOwnProperty("syncTime"))
                if (typeof message.syncTime === "number")
                    object.syncTime = options.longs === String ? String(message.syncTime) : message.syncTime;
                else
                    object.syncTime = options.longs === String ? $util.Long.prototype.toString.call(message.syncTime) : options.longs === Number ? new $util.LongBits(message.syncTime.low >>> 0, message.syncTime.high >>> 0).toNumber() : message.syncTime;
            if (message.isFinished != null && message.hasOwnProperty("isFinished"))
                object.isFinished = message.isFinished;
            if (message.targetUserInfo != null && message.hasOwnProperty("targetUserInfo"))
                object.targetUserInfo = $root.immessage.UserInfo.toObject(message.targetUserInfo, options);
            if (message.groupInfo != null && message.hasOwnProperty("groupInfo"))
                object.groupInfo = $root.immessage.GroupInfo.toObject(message.groupInfo, options);
            return object;
        };

        /**
         * Converts this DownMsgSet to JSON.
         * @function toJSON
         * @memberof immessage.DownMsgSet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DownMsgSet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DownMsgSet
         * @function getTypeUrl
         * @memberof immessage.DownMsgSet
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DownMsgSet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.DownMsgSet";
        };

        return DownMsgSet;
    })();

    immessage.KvItem = (function() {

        /**
         * Properties of a KvItem.
         * @memberof immessage
         * @interface IKvItem
         * @property {string|null} [key] KvItem key
         * @property {string|null} [value] KvItem value
         * @property {number|Long|null} [updTime] KvItem updTime
         */

        /**
         * Constructs a new KvItem.
         * @memberof immessage
         * @classdesc Represents a KvItem.
         * @implements IKvItem
         * @constructor
         * @param {immessage.IKvItem=} [properties] Properties to set
         */
        function KvItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KvItem key.
         * @member {string} key
         * @memberof immessage.KvItem
         * @instance
         */
        KvItem.prototype.key = "";

        /**
         * KvItem value.
         * @member {string} value
         * @memberof immessage.KvItem
         * @instance
         */
        KvItem.prototype.value = "";

        /**
         * KvItem updTime.
         * @member {number|Long} updTime
         * @memberof immessage.KvItem
         * @instance
         */
        KvItem.prototype.updTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new KvItem instance using the specified properties.
         * @function create
         * @memberof immessage.KvItem
         * @static
         * @param {immessage.IKvItem=} [properties] Properties to set
         * @returns {immessage.KvItem} KvItem instance
         */
        KvItem.create = function create(properties) {
            return new KvItem(properties);
        };

        /**
         * Encodes the specified KvItem message. Does not implicitly {@link immessage.KvItem.verify|verify} messages.
         * @function encode
         * @memberof immessage.KvItem
         * @static
         * @param {immessage.IKvItem} message KvItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KvItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            if (message.updTime != null && Object.hasOwnProperty.call(message, "updTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.updTime);
            return writer;
        };

        /**
         * Encodes the specified KvItem message, length delimited. Does not implicitly {@link immessage.KvItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.KvItem
         * @static
         * @param {immessage.IKvItem} message KvItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KvItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KvItem message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.KvItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.KvItem} KvItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KvItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.KvItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.key = reader.string();
                        break;
                    }
                case 2: {
                        message.value = reader.string();
                        break;
                    }
                case 3: {
                        message.updTime = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KvItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.KvItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.KvItem} KvItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KvItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KvItem message.
         * @function verify
         * @memberof immessage.KvItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KvItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            if (message.updTime != null && message.hasOwnProperty("updTime"))
                if (!$util.isInteger(message.updTime) && !(message.updTime && $util.isInteger(message.updTime.low) && $util.isInteger(message.updTime.high)))
                    return "updTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a KvItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.KvItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.KvItem} KvItem
         */
        KvItem.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.KvItem)
                return object;
            let message = new $root.immessage.KvItem();
            if (object.key != null)
                message.key = String(object.key);
            if (object.value != null)
                message.value = String(object.value);
            if (object.updTime != null)
                if ($util.Long)
                    (message.updTime = $util.Long.fromValue(object.updTime)).unsigned = false;
                else if (typeof object.updTime === "string")
                    message.updTime = parseInt(object.updTime, 10);
                else if (typeof object.updTime === "number")
                    message.updTime = object.updTime;
                else if (typeof object.updTime === "object")
                    message.updTime = new $util.LongBits(object.updTime.low >>> 0, object.updTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a KvItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.KvItem
         * @static
         * @param {immessage.KvItem} message KvItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KvItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.key = "";
                object.value = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.updTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.updTime = options.longs === String ? "0" : 0;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.updTime != null && message.hasOwnProperty("updTime"))
                if (typeof message.updTime === "number")
                    object.updTime = options.longs === String ? String(message.updTime) : message.updTime;
                else
                    object.updTime = options.longs === String ? $util.Long.prototype.toString.call(message.updTime) : options.longs === Number ? new $util.LongBits(message.updTime.low >>> 0, message.updTime.high >>> 0).toNumber() : message.updTime;
            return object;
        };

        /**
         * Converts this KvItem to JSON.
         * @function toJSON
         * @memberof immessage.KvItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KvItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for KvItem
         * @function getTypeUrl
         * @memberof immessage.KvItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        KvItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.KvItem";
        };

        return KvItem;
    })();

    immessage.PushSwitch = (function() {

        /**
         * Properties of a PushSwitch.
         * @memberof immessage
         * @interface IPushSwitch
         * @property {number|null} ["switch"] PushSwitch switch
         */

        /**
         * Constructs a new PushSwitch.
         * @memberof immessage
         * @classdesc Represents a PushSwitch.
         * @implements IPushSwitch
         * @constructor
         * @param {immessage.IPushSwitch=} [properties] Properties to set
         */
        function PushSwitch(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushSwitch switch.
         * @member {number} switch
         * @memberof immessage.PushSwitch
         * @instance
         */
        PushSwitch.prototype["switch"] = 0;

        /**
         * Creates a new PushSwitch instance using the specified properties.
         * @function create
         * @memberof immessage.PushSwitch
         * @static
         * @param {immessage.IPushSwitch=} [properties] Properties to set
         * @returns {immessage.PushSwitch} PushSwitch instance
         */
        PushSwitch.create = function create(properties) {
            return new PushSwitch(properties);
        };

        /**
         * Encodes the specified PushSwitch message. Does not implicitly {@link immessage.PushSwitch.verify|verify} messages.
         * @function encode
         * @memberof immessage.PushSwitch
         * @static
         * @param {immessage.IPushSwitch} message PushSwitch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushSwitch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message["switch"] != null && Object.hasOwnProperty.call(message, "switch"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message["switch"]);
            return writer;
        };

        /**
         * Encodes the specified PushSwitch message, length delimited. Does not implicitly {@link immessage.PushSwitch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.PushSwitch
         * @static
         * @param {immessage.IPushSwitch} message PushSwitch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushSwitch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PushSwitch message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.PushSwitch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.PushSwitch} PushSwitch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushSwitch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.PushSwitch();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message["switch"] = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PushSwitch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.PushSwitch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.PushSwitch} PushSwitch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushSwitch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PushSwitch message.
         * @function verify
         * @memberof immessage.PushSwitch
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PushSwitch.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["switch"] != null && message.hasOwnProperty("switch"))
                if (!$util.isInteger(message["switch"]))
                    return "switch: integer expected";
            return null;
        };

        /**
         * Creates a PushSwitch message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.PushSwitch
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.PushSwitch} PushSwitch
         */
        PushSwitch.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.PushSwitch)
                return object;
            let message = new $root.immessage.PushSwitch();
            if (object["switch"] != null)
                message["switch"] = object["switch"] | 0;
            return message;
        };

        /**
         * Creates a plain object from a PushSwitch message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.PushSwitch
         * @static
         * @param {immessage.PushSwitch} message PushSwitch
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PushSwitch.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object["switch"] = 0;
            if (message["switch"] != null && message.hasOwnProperty("switch"))
                object["switch"] = message["switch"];
            return object;
        };

        /**
         * Converts this PushSwitch to JSON.
         * @function toJSON
         * @memberof immessage.PushSwitch
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PushSwitch.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PushSwitch
         * @function getTypeUrl
         * @memberof immessage.PushSwitch
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PushSwitch.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.PushSwitch";
        };

        return PushSwitch;
    })();

    immessage.AddGrpAssistantReq = (function() {

        /**
         * Properties of an AddGrpAssistantReq.
         * @memberof immessage
         * @interface IAddGrpAssistantReq
         * @property {string|null} [assistantId] AddGrpAssistantReq assistantId
         * @property {Array.<immessage.ISimpleConversation>|null} [targets] AddGrpAssistantReq targets
         */

        /**
         * Constructs a new AddGrpAssistantReq.
         * @memberof immessage
         * @classdesc Represents an AddGrpAssistantReq.
         * @implements IAddGrpAssistantReq
         * @constructor
         * @param {immessage.IAddGrpAssistantReq=} [properties] Properties to set
         */
        function AddGrpAssistantReq(properties) {
            this.targets = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddGrpAssistantReq assistantId.
         * @member {string} assistantId
         * @memberof immessage.AddGrpAssistantReq
         * @instance
         */
        AddGrpAssistantReq.prototype.assistantId = "";

        /**
         * AddGrpAssistantReq targets.
         * @member {Array.<immessage.ISimpleConversation>} targets
         * @memberof immessage.AddGrpAssistantReq
         * @instance
         */
        AddGrpAssistantReq.prototype.targets = $util.emptyArray;

        /**
         * Creates a new AddGrpAssistantReq instance using the specified properties.
         * @function create
         * @memberof immessage.AddGrpAssistantReq
         * @static
         * @param {immessage.IAddGrpAssistantReq=} [properties] Properties to set
         * @returns {immessage.AddGrpAssistantReq} AddGrpAssistantReq instance
         */
        AddGrpAssistantReq.create = function create(properties) {
            return new AddGrpAssistantReq(properties);
        };

        /**
         * Encodes the specified AddGrpAssistantReq message. Does not implicitly {@link immessage.AddGrpAssistantReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.AddGrpAssistantReq
         * @static
         * @param {immessage.IAddGrpAssistantReq} message AddGrpAssistantReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddGrpAssistantReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.assistantId != null && Object.hasOwnProperty.call(message, "assistantId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.assistantId);
            if (message.targets != null && message.targets.length)
                for (let i = 0; i < message.targets.length; ++i)
                    $root.immessage.SimpleConversation.encode(message.targets[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AddGrpAssistantReq message, length delimited. Does not implicitly {@link immessage.AddGrpAssistantReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.AddGrpAssistantReq
         * @static
         * @param {immessage.IAddGrpAssistantReq} message AddGrpAssistantReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddGrpAssistantReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddGrpAssistantReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.AddGrpAssistantReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.AddGrpAssistantReq} AddGrpAssistantReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddGrpAssistantReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.AddGrpAssistantReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.assistantId = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.targets && message.targets.length))
                            message.targets = [];
                        message.targets.push($root.immessage.SimpleConversation.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddGrpAssistantReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.AddGrpAssistantReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.AddGrpAssistantReq} AddGrpAssistantReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddGrpAssistantReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddGrpAssistantReq message.
         * @function verify
         * @memberof immessage.AddGrpAssistantReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddGrpAssistantReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.assistantId != null && message.hasOwnProperty("assistantId"))
                if (!$util.isString(message.assistantId))
                    return "assistantId: string expected";
            if (message.targets != null && message.hasOwnProperty("targets")) {
                if (!Array.isArray(message.targets))
                    return "targets: array expected";
                for (let i = 0; i < message.targets.length; ++i) {
                    let error = $root.immessage.SimpleConversation.verify(message.targets[i]);
                    if (error)
                        return "targets." + error;
                }
            }
            return null;
        };

        /**
         * Creates an AddGrpAssistantReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.AddGrpAssistantReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.AddGrpAssistantReq} AddGrpAssistantReq
         */
        AddGrpAssistantReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.AddGrpAssistantReq)
                return object;
            let message = new $root.immessage.AddGrpAssistantReq();
            if (object.assistantId != null)
                message.assistantId = String(object.assistantId);
            if (object.targets) {
                if (!Array.isArray(object.targets))
                    throw TypeError(".immessage.AddGrpAssistantReq.targets: array expected");
                message.targets = [];
                for (let i = 0; i < object.targets.length; ++i) {
                    if (typeof object.targets[i] !== "object")
                        throw TypeError(".immessage.AddGrpAssistantReq.targets: object expected");
                    message.targets[i] = $root.immessage.SimpleConversation.fromObject(object.targets[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an AddGrpAssistantReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.AddGrpAssistantReq
         * @static
         * @param {immessage.AddGrpAssistantReq} message AddGrpAssistantReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddGrpAssistantReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.targets = [];
            if (options.defaults)
                object.assistantId = "";
            if (message.assistantId != null && message.hasOwnProperty("assistantId"))
                object.assistantId = message.assistantId;
            if (message.targets && message.targets.length) {
                object.targets = [];
                for (let j = 0; j < message.targets.length; ++j)
                    object.targets[j] = $root.immessage.SimpleConversation.toObject(message.targets[j], options);
            }
            return object;
        };

        /**
         * Converts this AddGrpAssistantReq to JSON.
         * @function toJSON
         * @memberof immessage.AddGrpAssistantReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddGrpAssistantReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AddGrpAssistantReq
         * @function getTypeUrl
         * @memberof immessage.AddGrpAssistantReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AddGrpAssistantReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.AddGrpAssistantReq";
        };

        return AddGrpAssistantReq;
    })();

    immessage.SimpleConversation = (function() {

        /**
         * Properties of a SimpleConversation.
         * @memberof immessage
         * @interface ISimpleConversation
         * @property {string|null} [targetId] SimpleConversation targetId
         * @property {immessage.ChannelType|null} [channelType] SimpleConversation channelType
         * @property {number|Long|null} [msgTime] SimpleConversation msgTime
         * @property {number|Long|null} [msgSeq] SimpleConversation msgSeq
         */

        /**
         * Constructs a new SimpleConversation.
         * @memberof immessage
         * @classdesc Represents a SimpleConversation.
         * @implements ISimpleConversation
         * @constructor
         * @param {immessage.ISimpleConversation=} [properties] Properties to set
         */
        function SimpleConversation(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SimpleConversation targetId.
         * @member {string} targetId
         * @memberof immessage.SimpleConversation
         * @instance
         */
        SimpleConversation.prototype.targetId = "";

        /**
         * SimpleConversation channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.SimpleConversation
         * @instance
         */
        SimpleConversation.prototype.channelType = 0;

        /**
         * SimpleConversation msgTime.
         * @member {number|Long} msgTime
         * @memberof immessage.SimpleConversation
         * @instance
         */
        SimpleConversation.prototype.msgTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SimpleConversation msgSeq.
         * @member {number|Long} msgSeq
         * @memberof immessage.SimpleConversation
         * @instance
         */
        SimpleConversation.prototype.msgSeq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SimpleConversation instance using the specified properties.
         * @function create
         * @memberof immessage.SimpleConversation
         * @static
         * @param {immessage.ISimpleConversation=} [properties] Properties to set
         * @returns {immessage.SimpleConversation} SimpleConversation instance
         */
        SimpleConversation.create = function create(properties) {
            return new SimpleConversation(properties);
        };

        /**
         * Encodes the specified SimpleConversation message. Does not implicitly {@link immessage.SimpleConversation.verify|verify} messages.
         * @function encode
         * @memberof immessage.SimpleConversation
         * @static
         * @param {immessage.ISimpleConversation} message SimpleConversation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleConversation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.msgTime != null && Object.hasOwnProperty.call(message, "msgTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.msgTime);
            if (message.msgSeq != null && Object.hasOwnProperty.call(message, "msgSeq"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.msgSeq);
            return writer;
        };

        /**
         * Encodes the specified SimpleConversation message, length delimited. Does not implicitly {@link immessage.SimpleConversation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.SimpleConversation
         * @static
         * @param {immessage.ISimpleConversation} message SimpleConversation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleConversation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SimpleConversation message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.SimpleConversation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.SimpleConversation} SimpleConversation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleConversation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.SimpleConversation();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        message.msgTime = reader.int64();
                        break;
                    }
                case 4: {
                        message.msgSeq = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SimpleConversation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.SimpleConversation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.SimpleConversation} SimpleConversation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleConversation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SimpleConversation message.
         * @function verify
         * @memberof immessage.SimpleConversation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SimpleConversation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (!$util.isInteger(message.msgTime) && !(message.msgTime && $util.isInteger(message.msgTime.low) && $util.isInteger(message.msgTime.high)))
                    return "msgTime: integer|Long expected";
            if (message.msgSeq != null && message.hasOwnProperty("msgSeq"))
                if (!$util.isInteger(message.msgSeq) && !(message.msgSeq && $util.isInteger(message.msgSeq.low) && $util.isInteger(message.msgSeq.high)))
                    return "msgSeq: integer|Long expected";
            return null;
        };

        /**
         * Creates a SimpleConversation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.SimpleConversation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.SimpleConversation} SimpleConversation
         */
        SimpleConversation.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.SimpleConversation)
                return object;
            let message = new $root.immessage.SimpleConversation();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.msgTime != null)
                if ($util.Long)
                    (message.msgTime = $util.Long.fromValue(object.msgTime)).unsigned = false;
                else if (typeof object.msgTime === "string")
                    message.msgTime = parseInt(object.msgTime, 10);
                else if (typeof object.msgTime === "number")
                    message.msgTime = object.msgTime;
                else if (typeof object.msgTime === "object")
                    message.msgTime = new $util.LongBits(object.msgTime.low >>> 0, object.msgTime.high >>> 0).toNumber();
            if (object.msgSeq != null)
                if ($util.Long)
                    (message.msgSeq = $util.Long.fromValue(object.msgSeq)).unsigned = false;
                else if (typeof object.msgSeq === "string")
                    message.msgSeq = parseInt(object.msgSeq, 10);
                else if (typeof object.msgSeq === "number")
                    message.msgSeq = object.msgSeq;
                else if (typeof object.msgSeq === "object")
                    message.msgSeq = new $util.LongBits(object.msgSeq.low >>> 0, object.msgSeq.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SimpleConversation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.SimpleConversation
         * @static
         * @param {immessage.SimpleConversation} message SimpleConversation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SimpleConversation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.msgTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msgTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.msgSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msgSeq = options.longs === String ? "0" : 0;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (typeof message.msgTime === "number")
                    object.msgTime = options.longs === String ? String(message.msgTime) : message.msgTime;
                else
                    object.msgTime = options.longs === String ? $util.Long.prototype.toString.call(message.msgTime) : options.longs === Number ? new $util.LongBits(message.msgTime.low >>> 0, message.msgTime.high >>> 0).toNumber() : message.msgTime;
            if (message.msgSeq != null && message.hasOwnProperty("msgSeq"))
                if (typeof message.msgSeq === "number")
                    object.msgSeq = options.longs === String ? String(message.msgSeq) : message.msgSeq;
                else
                    object.msgSeq = options.longs === String ? $util.Long.prototype.toString.call(message.msgSeq) : options.longs === Number ? new $util.LongBits(message.msgSeq.low >>> 0, message.msgSeq.high >>> 0).toNumber() : message.msgSeq;
            return object;
        };

        /**
         * Converts this SimpleConversation to JSON.
         * @function toJSON
         * @memberof immessage.SimpleConversation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SimpleConversation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SimpleConversation
         * @function getTypeUrl
         * @memberof immessage.SimpleConversation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SimpleConversation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.SimpleConversation";
        };

        return SimpleConversation;
    })();

    immessage.AssistantMsgResp = (function() {

        /**
         * Properties of an AssistantMsgResp.
         * @memberof immessage
         * @interface IAssistantMsgResp
         * @property {string|null} [msgId] AssistantMsgResp msgId
         * @property {number|Long|null} [msgTime] AssistantMsgResp msgTime
         * @property {number|Long|null} [msgSeq] AssistantMsgResp msgSeq
         * @property {Array.<immessage.ISimpleConversation>|null} [convers] AssistantMsgResp convers
         */

        /**
         * Constructs a new AssistantMsgResp.
         * @memberof immessage
         * @classdesc Represents an AssistantMsgResp.
         * @implements IAssistantMsgResp
         * @constructor
         * @param {immessage.IAssistantMsgResp=} [properties] Properties to set
         */
        function AssistantMsgResp(properties) {
            this.convers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AssistantMsgResp msgId.
         * @member {string} msgId
         * @memberof immessage.AssistantMsgResp
         * @instance
         */
        AssistantMsgResp.prototype.msgId = "";

        /**
         * AssistantMsgResp msgTime.
         * @member {number|Long} msgTime
         * @memberof immessage.AssistantMsgResp
         * @instance
         */
        AssistantMsgResp.prototype.msgTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AssistantMsgResp msgSeq.
         * @member {number|Long} msgSeq
         * @memberof immessage.AssistantMsgResp
         * @instance
         */
        AssistantMsgResp.prototype.msgSeq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AssistantMsgResp convers.
         * @member {Array.<immessage.ISimpleConversation>} convers
         * @memberof immessage.AssistantMsgResp
         * @instance
         */
        AssistantMsgResp.prototype.convers = $util.emptyArray;

        /**
         * Creates a new AssistantMsgResp instance using the specified properties.
         * @function create
         * @memberof immessage.AssistantMsgResp
         * @static
         * @param {immessage.IAssistantMsgResp=} [properties] Properties to set
         * @returns {immessage.AssistantMsgResp} AssistantMsgResp instance
         */
        AssistantMsgResp.create = function create(properties) {
            return new AssistantMsgResp(properties);
        };

        /**
         * Encodes the specified AssistantMsgResp message. Does not implicitly {@link immessage.AssistantMsgResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.AssistantMsgResp
         * @static
         * @param {immessage.IAssistantMsgResp} message AssistantMsgResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AssistantMsgResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.msgId);
            if (message.msgTime != null && Object.hasOwnProperty.call(message, "msgTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.msgTime);
            if (message.msgSeq != null && Object.hasOwnProperty.call(message, "msgSeq"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.msgSeq);
            if (message.convers != null && message.convers.length)
                for (let i = 0; i < message.convers.length; ++i)
                    $root.immessage.SimpleConversation.encode(message.convers[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AssistantMsgResp message, length delimited. Does not implicitly {@link immessage.AssistantMsgResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.AssistantMsgResp
         * @static
         * @param {immessage.IAssistantMsgResp} message AssistantMsgResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AssistantMsgResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AssistantMsgResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.AssistantMsgResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.AssistantMsgResp} AssistantMsgResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AssistantMsgResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.AssistantMsgResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.msgId = reader.string();
                        break;
                    }
                case 2: {
                        message.msgTime = reader.int64();
                        break;
                    }
                case 3: {
                        message.msgSeq = reader.int64();
                        break;
                    }
                case 4: {
                        if (!(message.convers && message.convers.length))
                            message.convers = [];
                        message.convers.push($root.immessage.SimpleConversation.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AssistantMsgResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.AssistantMsgResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.AssistantMsgResp} AssistantMsgResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AssistantMsgResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AssistantMsgResp message.
         * @function verify
         * @memberof immessage.AssistantMsgResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AssistantMsgResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (!$util.isInteger(message.msgTime) && !(message.msgTime && $util.isInteger(message.msgTime.low) && $util.isInteger(message.msgTime.high)))
                    return "msgTime: integer|Long expected";
            if (message.msgSeq != null && message.hasOwnProperty("msgSeq"))
                if (!$util.isInteger(message.msgSeq) && !(message.msgSeq && $util.isInteger(message.msgSeq.low) && $util.isInteger(message.msgSeq.high)))
                    return "msgSeq: integer|Long expected";
            if (message.convers != null && message.hasOwnProperty("convers")) {
                if (!Array.isArray(message.convers))
                    return "convers: array expected";
                for (let i = 0; i < message.convers.length; ++i) {
                    let error = $root.immessage.SimpleConversation.verify(message.convers[i]);
                    if (error)
                        return "convers." + error;
                }
            }
            return null;
        };

        /**
         * Creates an AssistantMsgResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.AssistantMsgResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.AssistantMsgResp} AssistantMsgResp
         */
        AssistantMsgResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.AssistantMsgResp)
                return object;
            let message = new $root.immessage.AssistantMsgResp();
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            if (object.msgTime != null)
                if ($util.Long)
                    (message.msgTime = $util.Long.fromValue(object.msgTime)).unsigned = false;
                else if (typeof object.msgTime === "string")
                    message.msgTime = parseInt(object.msgTime, 10);
                else if (typeof object.msgTime === "number")
                    message.msgTime = object.msgTime;
                else if (typeof object.msgTime === "object")
                    message.msgTime = new $util.LongBits(object.msgTime.low >>> 0, object.msgTime.high >>> 0).toNumber();
            if (object.msgSeq != null)
                if ($util.Long)
                    (message.msgSeq = $util.Long.fromValue(object.msgSeq)).unsigned = false;
                else if (typeof object.msgSeq === "string")
                    message.msgSeq = parseInt(object.msgSeq, 10);
                else if (typeof object.msgSeq === "number")
                    message.msgSeq = object.msgSeq;
                else if (typeof object.msgSeq === "object")
                    message.msgSeq = new $util.LongBits(object.msgSeq.low >>> 0, object.msgSeq.high >>> 0).toNumber();
            if (object.convers) {
                if (!Array.isArray(object.convers))
                    throw TypeError(".immessage.AssistantMsgResp.convers: array expected");
                message.convers = [];
                for (let i = 0; i < object.convers.length; ++i) {
                    if (typeof object.convers[i] !== "object")
                        throw TypeError(".immessage.AssistantMsgResp.convers: object expected");
                    message.convers[i] = $root.immessage.SimpleConversation.fromObject(object.convers[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an AssistantMsgResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.AssistantMsgResp
         * @static
         * @param {immessage.AssistantMsgResp} message AssistantMsgResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AssistantMsgResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.convers = [];
            if (options.defaults) {
                object.msgId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.msgTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msgTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.msgSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msgSeq = options.longs === String ? "0" : 0;
            }
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (typeof message.msgTime === "number")
                    object.msgTime = options.longs === String ? String(message.msgTime) : message.msgTime;
                else
                    object.msgTime = options.longs === String ? $util.Long.prototype.toString.call(message.msgTime) : options.longs === Number ? new $util.LongBits(message.msgTime.low >>> 0, message.msgTime.high >>> 0).toNumber() : message.msgTime;
            if (message.msgSeq != null && message.hasOwnProperty("msgSeq"))
                if (typeof message.msgSeq === "number")
                    object.msgSeq = options.longs === String ? String(message.msgSeq) : message.msgSeq;
                else
                    object.msgSeq = options.longs === String ? $util.Long.prototype.toString.call(message.msgSeq) : options.longs === Number ? new $util.LongBits(message.msgSeq.low >>> 0, message.msgSeq.high >>> 0).toNumber() : message.msgSeq;
            if (message.convers && message.convers.length) {
                object.convers = [];
                for (let j = 0; j < message.convers.length; ++j)
                    object.convers[j] = $root.immessage.SimpleConversation.toObject(message.convers[j], options);
            }
            return object;
        };

        /**
         * Converts this AssistantMsgResp to JSON.
         * @function toJSON
         * @memberof immessage.AssistantMsgResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AssistantMsgResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AssistantMsgResp
         * @function getTypeUrl
         * @memberof immessage.AssistantMsgResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AssistantMsgResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.AssistantMsgResp";
        };

        return AssistantMsgResp;
    })();

    immessage.AddHisMsgReq = (function() {

        /**
         * Properties of an AddHisMsgReq.
         * @memberof immessage
         * @interface IAddHisMsgReq
         * @property {string|null} [senderId] AddHisMsgReq senderId
         * @property {string|null} [targetId] AddHisMsgReq targetId
         * @property {immessage.ChannelType|null} [channelType] AddHisMsgReq channelType
         * @property {number|Long|null} [sendTime] AddHisMsgReq sendTime
         * @property {immessage.IDownMsg|null} [msg] AddHisMsgReq msg
         * @property {number|null} [GroupMemberCount] AddHisMsgReq GroupMemberCount
         */

        /**
         * Constructs a new AddHisMsgReq.
         * @memberof immessage
         * @classdesc Represents an AddHisMsgReq.
         * @implements IAddHisMsgReq
         * @constructor
         * @param {immessage.IAddHisMsgReq=} [properties] Properties to set
         */
        function AddHisMsgReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddHisMsgReq senderId.
         * @member {string} senderId
         * @memberof immessage.AddHisMsgReq
         * @instance
         */
        AddHisMsgReq.prototype.senderId = "";

        /**
         * AddHisMsgReq targetId.
         * @member {string} targetId
         * @memberof immessage.AddHisMsgReq
         * @instance
         */
        AddHisMsgReq.prototype.targetId = "";

        /**
         * AddHisMsgReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.AddHisMsgReq
         * @instance
         */
        AddHisMsgReq.prototype.channelType = 0;

        /**
         * AddHisMsgReq sendTime.
         * @member {number|Long} sendTime
         * @memberof immessage.AddHisMsgReq
         * @instance
         */
        AddHisMsgReq.prototype.sendTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AddHisMsgReq msg.
         * @member {immessage.IDownMsg|null|undefined} msg
         * @memberof immessage.AddHisMsgReq
         * @instance
         */
        AddHisMsgReq.prototype.msg = null;

        /**
         * AddHisMsgReq GroupMemberCount.
         * @member {number} GroupMemberCount
         * @memberof immessage.AddHisMsgReq
         * @instance
         */
        AddHisMsgReq.prototype.GroupMemberCount = 0;

        /**
         * Creates a new AddHisMsgReq instance using the specified properties.
         * @function create
         * @memberof immessage.AddHisMsgReq
         * @static
         * @param {immessage.IAddHisMsgReq=} [properties] Properties to set
         * @returns {immessage.AddHisMsgReq} AddHisMsgReq instance
         */
        AddHisMsgReq.create = function create(properties) {
            return new AddHisMsgReq(properties);
        };

        /**
         * Encodes the specified AddHisMsgReq message. Does not implicitly {@link immessage.AddHisMsgReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.AddHisMsgReq
         * @static
         * @param {immessage.IAddHisMsgReq} message AddHisMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddHisMsgReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.senderId != null && Object.hasOwnProperty.call(message, "senderId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.senderId);
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.channelType);
            if (message.sendTime != null && Object.hasOwnProperty.call(message, "sendTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.sendTime);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                $root.immessage.DownMsg.encode(message.msg, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.GroupMemberCount != null && Object.hasOwnProperty.call(message, "GroupMemberCount"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.GroupMemberCount);
            return writer;
        };

        /**
         * Encodes the specified AddHisMsgReq message, length delimited. Does not implicitly {@link immessage.AddHisMsgReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.AddHisMsgReq
         * @static
         * @param {immessage.IAddHisMsgReq} message AddHisMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddHisMsgReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddHisMsgReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.AddHisMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.AddHisMsgReq} AddHisMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddHisMsgReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.AddHisMsgReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.senderId = reader.string();
                        break;
                    }
                case 2: {
                        message.targetId = reader.string();
                        break;
                    }
                case 3: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 4: {
                        message.sendTime = reader.int64();
                        break;
                    }
                case 5: {
                        message.msg = $root.immessage.DownMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.GroupMemberCount = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddHisMsgReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.AddHisMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.AddHisMsgReq} AddHisMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddHisMsgReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddHisMsgReq message.
         * @function verify
         * @memberof immessage.AddHisMsgReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddHisMsgReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.senderId != null && message.hasOwnProperty("senderId"))
                if (!$util.isString(message.senderId))
                    return "senderId: string expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.sendTime != null && message.hasOwnProperty("sendTime"))
                if (!$util.isInteger(message.sendTime) && !(message.sendTime && $util.isInteger(message.sendTime.low) && $util.isInteger(message.sendTime.high)))
                    return "sendTime: integer|Long expected";
            if (message.msg != null && message.hasOwnProperty("msg")) {
                let error = $root.immessage.DownMsg.verify(message.msg);
                if (error)
                    return "msg." + error;
            }
            if (message.GroupMemberCount != null && message.hasOwnProperty("GroupMemberCount"))
                if (!$util.isInteger(message.GroupMemberCount))
                    return "GroupMemberCount: integer expected";
            return null;
        };

        /**
         * Creates an AddHisMsgReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.AddHisMsgReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.AddHisMsgReq} AddHisMsgReq
         */
        AddHisMsgReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.AddHisMsgReq)
                return object;
            let message = new $root.immessage.AddHisMsgReq();
            if (object.senderId != null)
                message.senderId = String(object.senderId);
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.sendTime != null)
                if ($util.Long)
                    (message.sendTime = $util.Long.fromValue(object.sendTime)).unsigned = false;
                else if (typeof object.sendTime === "string")
                    message.sendTime = parseInt(object.sendTime, 10);
                else if (typeof object.sendTime === "number")
                    message.sendTime = object.sendTime;
                else if (typeof object.sendTime === "object")
                    message.sendTime = new $util.LongBits(object.sendTime.low >>> 0, object.sendTime.high >>> 0).toNumber();
            if (object.msg != null) {
                if (typeof object.msg !== "object")
                    throw TypeError(".immessage.AddHisMsgReq.msg: object expected");
                message.msg = $root.immessage.DownMsg.fromObject(object.msg);
            }
            if (object.GroupMemberCount != null)
                message.GroupMemberCount = object.GroupMemberCount | 0;
            return message;
        };

        /**
         * Creates a plain object from an AddHisMsgReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.AddHisMsgReq
         * @static
         * @param {immessage.AddHisMsgReq} message AddHisMsgReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddHisMsgReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.senderId = "";
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.sendTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sendTime = options.longs === String ? "0" : 0;
                object.msg = null;
                object.GroupMemberCount = 0;
            }
            if (message.senderId != null && message.hasOwnProperty("senderId"))
                object.senderId = message.senderId;
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.sendTime != null && message.hasOwnProperty("sendTime"))
                if (typeof message.sendTime === "number")
                    object.sendTime = options.longs === String ? String(message.sendTime) : message.sendTime;
                else
                    object.sendTime = options.longs === String ? $util.Long.prototype.toString.call(message.sendTime) : options.longs === Number ? new $util.LongBits(message.sendTime.low >>> 0, message.sendTime.high >>> 0).toNumber() : message.sendTime;
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = $root.immessage.DownMsg.toObject(message.msg, options);
            if (message.GroupMemberCount != null && message.hasOwnProperty("GroupMemberCount"))
                object.GroupMemberCount = message.GroupMemberCount;
            return object;
        };

        /**
         * Converts this AddHisMsgReq to JSON.
         * @function toJSON
         * @memberof immessage.AddHisMsgReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddHisMsgReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AddHisMsgReq
         * @function getTypeUrl
         * @memberof immessage.AddHisMsgReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AddHisMsgReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.AddHisMsgReq";
        };

        return AddHisMsgReq;
    })();

    immessage.DelHisMsgsReq = (function() {

        /**
         * Properties of a DelHisMsgsReq.
         * @memberof immessage
         * @interface IDelHisMsgsReq
         * @property {string|null} [targetId] DelHisMsgsReq targetId
         * @property {immessage.ChannelType|null} [channelType] DelHisMsgsReq channelType
         * @property {Array.<immessage.ISimpleMsg>|null} [msgs] DelHisMsgsReq msgs
         * @property {number|null} [delScope] DelHisMsgsReq delScope
         */

        /**
         * Constructs a new DelHisMsgsReq.
         * @memberof immessage
         * @classdesc Represents a DelHisMsgsReq.
         * @implements IDelHisMsgsReq
         * @constructor
         * @param {immessage.IDelHisMsgsReq=} [properties] Properties to set
         */
        function DelHisMsgsReq(properties) {
            this.msgs = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelHisMsgsReq targetId.
         * @member {string} targetId
         * @memberof immessage.DelHisMsgsReq
         * @instance
         */
        DelHisMsgsReq.prototype.targetId = "";

        /**
         * DelHisMsgsReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.DelHisMsgsReq
         * @instance
         */
        DelHisMsgsReq.prototype.channelType = 0;

        /**
         * DelHisMsgsReq msgs.
         * @member {Array.<immessage.ISimpleMsg>} msgs
         * @memberof immessage.DelHisMsgsReq
         * @instance
         */
        DelHisMsgsReq.prototype.msgs = $util.emptyArray;

        /**
         * DelHisMsgsReq delScope.
         * @member {number} delScope
         * @memberof immessage.DelHisMsgsReq
         * @instance
         */
        DelHisMsgsReq.prototype.delScope = 0;

        /**
         * Creates a new DelHisMsgsReq instance using the specified properties.
         * @function create
         * @memberof immessage.DelHisMsgsReq
         * @static
         * @param {immessage.IDelHisMsgsReq=} [properties] Properties to set
         * @returns {immessage.DelHisMsgsReq} DelHisMsgsReq instance
         */
        DelHisMsgsReq.create = function create(properties) {
            return new DelHisMsgsReq(properties);
        };

        /**
         * Encodes the specified DelHisMsgsReq message. Does not implicitly {@link immessage.DelHisMsgsReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.DelHisMsgsReq
         * @static
         * @param {immessage.IDelHisMsgsReq} message DelHisMsgsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelHisMsgsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.channelType);
            if (message.msgs != null && message.msgs.length)
                for (let i = 0; i < message.msgs.length; ++i)
                    $root.immessage.SimpleMsg.encode(message.msgs[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.delScope != null && Object.hasOwnProperty.call(message, "delScope"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.delScope);
            return writer;
        };

        /**
         * Encodes the specified DelHisMsgsReq message, length delimited. Does not implicitly {@link immessage.DelHisMsgsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.DelHisMsgsReq
         * @static
         * @param {immessage.IDelHisMsgsReq} message DelHisMsgsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelHisMsgsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelHisMsgsReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.DelHisMsgsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.DelHisMsgsReq} DelHisMsgsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelHisMsgsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.DelHisMsgsReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        message.targetId = reader.string();
                        break;
                    }
                case 3: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.msgs && message.msgs.length))
                            message.msgs = [];
                        message.msgs.push($root.immessage.SimpleMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.delScope = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelHisMsgsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.DelHisMsgsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.DelHisMsgsReq} DelHisMsgsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelHisMsgsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelHisMsgsReq message.
         * @function verify
         * @memberof immessage.DelHisMsgsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelHisMsgsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.msgs != null && message.hasOwnProperty("msgs")) {
                if (!Array.isArray(message.msgs))
                    return "msgs: array expected";
                for (let i = 0; i < message.msgs.length; ++i) {
                    let error = $root.immessage.SimpleMsg.verify(message.msgs[i]);
                    if (error)
                        return "msgs." + error;
                }
            }
            if (message.delScope != null && message.hasOwnProperty("delScope"))
                if (!$util.isInteger(message.delScope))
                    return "delScope: integer expected";
            return null;
        };

        /**
         * Creates a DelHisMsgsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.DelHisMsgsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.DelHisMsgsReq} DelHisMsgsReq
         */
        DelHisMsgsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.DelHisMsgsReq)
                return object;
            let message = new $root.immessage.DelHisMsgsReq();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.msgs) {
                if (!Array.isArray(object.msgs))
                    throw TypeError(".immessage.DelHisMsgsReq.msgs: array expected");
                message.msgs = [];
                for (let i = 0; i < object.msgs.length; ++i) {
                    if (typeof object.msgs[i] !== "object")
                        throw TypeError(".immessage.DelHisMsgsReq.msgs: object expected");
                    message.msgs[i] = $root.immessage.SimpleMsg.fromObject(object.msgs[i]);
                }
            }
            if (object.delScope != null)
                message.delScope = object.delScope | 0;
            return message;
        };

        /**
         * Creates a plain object from a DelHisMsgsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.DelHisMsgsReq
         * @static
         * @param {immessage.DelHisMsgsReq} message DelHisMsgsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelHisMsgsReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.msgs = [];
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                object.delScope = 0;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.msgs && message.msgs.length) {
                object.msgs = [];
                for (let j = 0; j < message.msgs.length; ++j)
                    object.msgs[j] = $root.immessage.SimpleMsg.toObject(message.msgs[j], options);
            }
            if (message.delScope != null && message.hasOwnProperty("delScope"))
                object.delScope = message.delScope;
            return object;
        };

        /**
         * Converts this DelHisMsgsReq to JSON.
         * @function toJSON
         * @memberof immessage.DelHisMsgsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelHisMsgsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DelHisMsgsReq
         * @function getTypeUrl
         * @memberof immessage.DelHisMsgsReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DelHisMsgsReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.DelHisMsgsReq";
        };

        return DelHisMsgsReq;
    })();

    immessage.QryLatestMsgReq = (function() {

        /**
         * Properties of a QryLatestMsgReq.
         * @memberof immessage
         * @interface IQryLatestMsgReq
         * @property {string|null} [converId] QryLatestMsgReq converId
         * @property {immessage.ChannelType|null} [channelType] QryLatestMsgReq channelType
         */

        /**
         * Constructs a new QryLatestMsgReq.
         * @memberof immessage
         * @classdesc Represents a QryLatestMsgReq.
         * @implements IQryLatestMsgReq
         * @constructor
         * @param {immessage.IQryLatestMsgReq=} [properties] Properties to set
         */
        function QryLatestMsgReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryLatestMsgReq converId.
         * @member {string} converId
         * @memberof immessage.QryLatestMsgReq
         * @instance
         */
        QryLatestMsgReq.prototype.converId = "";

        /**
         * QryLatestMsgReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.QryLatestMsgReq
         * @instance
         */
        QryLatestMsgReq.prototype.channelType = 0;

        /**
         * Creates a new QryLatestMsgReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryLatestMsgReq
         * @static
         * @param {immessage.IQryLatestMsgReq=} [properties] Properties to set
         * @returns {immessage.QryLatestMsgReq} QryLatestMsgReq instance
         */
        QryLatestMsgReq.create = function create(properties) {
            return new QryLatestMsgReq(properties);
        };

        /**
         * Encodes the specified QryLatestMsgReq message. Does not implicitly {@link immessage.QryLatestMsgReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryLatestMsgReq
         * @static
         * @param {immessage.IQryLatestMsgReq} message QryLatestMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryLatestMsgReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.converId != null && Object.hasOwnProperty.call(message, "converId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.converId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            return writer;
        };

        /**
         * Encodes the specified QryLatestMsgReq message, length delimited. Does not implicitly {@link immessage.QryLatestMsgReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryLatestMsgReq
         * @static
         * @param {immessage.IQryLatestMsgReq} message QryLatestMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryLatestMsgReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryLatestMsgReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryLatestMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryLatestMsgReq} QryLatestMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryLatestMsgReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryLatestMsgReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.converId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryLatestMsgReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryLatestMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryLatestMsgReq} QryLatestMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryLatestMsgReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryLatestMsgReq message.
         * @function verify
         * @memberof immessage.QryLatestMsgReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryLatestMsgReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.converId != null && message.hasOwnProperty("converId"))
                if (!$util.isString(message.converId))
                    return "converId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            return null;
        };

        /**
         * Creates a QryLatestMsgReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryLatestMsgReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryLatestMsgReq} QryLatestMsgReq
         */
        QryLatestMsgReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryLatestMsgReq)
                return object;
            let message = new $root.immessage.QryLatestMsgReq();
            if (object.converId != null)
                message.converId = String(object.converId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a QryLatestMsgReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryLatestMsgReq
         * @static
         * @param {immessage.QryLatestMsgReq} message QryLatestMsgReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryLatestMsgReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.converId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
            }
            if (message.converId != null && message.hasOwnProperty("converId"))
                object.converId = message.converId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            return object;
        };

        /**
         * Converts this QryLatestMsgReq to JSON.
         * @function toJSON
         * @memberof immessage.QryLatestMsgReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryLatestMsgReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryLatestMsgReq
         * @function getTypeUrl
         * @memberof immessage.QryLatestMsgReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryLatestMsgReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryLatestMsgReq";
        };

        return QryLatestMsgReq;
    })();

    immessage.QryLatestMsgResp = (function() {

        /**
         * Properties of a QryLatestMsgResp.
         * @memberof immessage
         * @interface IQryLatestMsgResp
         * @property {string|null} [converId] QryLatestMsgResp converId
         * @property {immessage.ChannelType|null} [ChannelType] QryLatestMsgResp ChannelType
         * @property {number|Long|null} [msgSeqNo] QryLatestMsgResp msgSeqNo
         * @property {number|Long|null} [msgTime] QryLatestMsgResp msgTime
         * @property {string|null} [msgId] QryLatestMsgResp msgId
         */

        /**
         * Constructs a new QryLatestMsgResp.
         * @memberof immessage
         * @classdesc Represents a QryLatestMsgResp.
         * @implements IQryLatestMsgResp
         * @constructor
         * @param {immessage.IQryLatestMsgResp=} [properties] Properties to set
         */
        function QryLatestMsgResp(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryLatestMsgResp converId.
         * @member {string} converId
         * @memberof immessage.QryLatestMsgResp
         * @instance
         */
        QryLatestMsgResp.prototype.converId = "";

        /**
         * QryLatestMsgResp ChannelType.
         * @member {immessage.ChannelType} ChannelType
         * @memberof immessage.QryLatestMsgResp
         * @instance
         */
        QryLatestMsgResp.prototype.ChannelType = 0;

        /**
         * QryLatestMsgResp msgSeqNo.
         * @member {number|Long} msgSeqNo
         * @memberof immessage.QryLatestMsgResp
         * @instance
         */
        QryLatestMsgResp.prototype.msgSeqNo = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QryLatestMsgResp msgTime.
         * @member {number|Long} msgTime
         * @memberof immessage.QryLatestMsgResp
         * @instance
         */
        QryLatestMsgResp.prototype.msgTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QryLatestMsgResp msgId.
         * @member {string} msgId
         * @memberof immessage.QryLatestMsgResp
         * @instance
         */
        QryLatestMsgResp.prototype.msgId = "";

        /**
         * Creates a new QryLatestMsgResp instance using the specified properties.
         * @function create
         * @memberof immessage.QryLatestMsgResp
         * @static
         * @param {immessage.IQryLatestMsgResp=} [properties] Properties to set
         * @returns {immessage.QryLatestMsgResp} QryLatestMsgResp instance
         */
        QryLatestMsgResp.create = function create(properties) {
            return new QryLatestMsgResp(properties);
        };

        /**
         * Encodes the specified QryLatestMsgResp message. Does not implicitly {@link immessage.QryLatestMsgResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryLatestMsgResp
         * @static
         * @param {immessage.IQryLatestMsgResp} message QryLatestMsgResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryLatestMsgResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.converId != null && Object.hasOwnProperty.call(message, "converId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.converId);
            if (message.ChannelType != null && Object.hasOwnProperty.call(message, "ChannelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ChannelType);
            if (message.msgSeqNo != null && Object.hasOwnProperty.call(message, "msgSeqNo"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.msgSeqNo);
            if (message.msgTime != null && Object.hasOwnProperty.call(message, "msgTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.msgTime);
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.msgId);
            return writer;
        };

        /**
         * Encodes the specified QryLatestMsgResp message, length delimited. Does not implicitly {@link immessage.QryLatestMsgResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryLatestMsgResp
         * @static
         * @param {immessage.IQryLatestMsgResp} message QryLatestMsgResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryLatestMsgResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryLatestMsgResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryLatestMsgResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryLatestMsgResp} QryLatestMsgResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryLatestMsgResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryLatestMsgResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.converId = reader.string();
                        break;
                    }
                case 2: {
                        message.ChannelType = reader.int32();
                        break;
                    }
                case 3: {
                        message.msgSeqNo = reader.int64();
                        break;
                    }
                case 4: {
                        message.msgTime = reader.int64();
                        break;
                    }
                case 5: {
                        message.msgId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryLatestMsgResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryLatestMsgResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryLatestMsgResp} QryLatestMsgResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryLatestMsgResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryLatestMsgResp message.
         * @function verify
         * @memberof immessage.QryLatestMsgResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryLatestMsgResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.converId != null && message.hasOwnProperty("converId"))
                if (!$util.isString(message.converId))
                    return "converId: string expected";
            if (message.ChannelType != null && message.hasOwnProperty("ChannelType"))
                switch (message.ChannelType) {
                default:
                    return "ChannelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.msgSeqNo != null && message.hasOwnProperty("msgSeqNo"))
                if (!$util.isInteger(message.msgSeqNo) && !(message.msgSeqNo && $util.isInteger(message.msgSeqNo.low) && $util.isInteger(message.msgSeqNo.high)))
                    return "msgSeqNo: integer|Long expected";
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (!$util.isInteger(message.msgTime) && !(message.msgTime && $util.isInteger(message.msgTime.low) && $util.isInteger(message.msgTime.high)))
                    return "msgTime: integer|Long expected";
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            return null;
        };

        /**
         * Creates a QryLatestMsgResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryLatestMsgResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryLatestMsgResp} QryLatestMsgResp
         */
        QryLatestMsgResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryLatestMsgResp)
                return object;
            let message = new $root.immessage.QryLatestMsgResp();
            if (object.converId != null)
                message.converId = String(object.converId);
            switch (object.ChannelType) {
            default:
                if (typeof object.ChannelType === "number") {
                    message.ChannelType = object.ChannelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.ChannelType = 0;
                break;
            case "Private":
            case 1:
                message.ChannelType = 1;
                break;
            case "Group":
            case 2:
                message.ChannelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.ChannelType = 3;
                break;
            case "System":
            case 4:
                message.ChannelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.ChannelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.ChannelType = 6;
                break;
            }
            if (object.msgSeqNo != null)
                if ($util.Long)
                    (message.msgSeqNo = $util.Long.fromValue(object.msgSeqNo)).unsigned = false;
                else if (typeof object.msgSeqNo === "string")
                    message.msgSeqNo = parseInt(object.msgSeqNo, 10);
                else if (typeof object.msgSeqNo === "number")
                    message.msgSeqNo = object.msgSeqNo;
                else if (typeof object.msgSeqNo === "object")
                    message.msgSeqNo = new $util.LongBits(object.msgSeqNo.low >>> 0, object.msgSeqNo.high >>> 0).toNumber();
            if (object.msgTime != null)
                if ($util.Long)
                    (message.msgTime = $util.Long.fromValue(object.msgTime)).unsigned = false;
                else if (typeof object.msgTime === "string")
                    message.msgTime = parseInt(object.msgTime, 10);
                else if (typeof object.msgTime === "number")
                    message.msgTime = object.msgTime;
                else if (typeof object.msgTime === "object")
                    message.msgTime = new $util.LongBits(object.msgTime.low >>> 0, object.msgTime.high >>> 0).toNumber();
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            return message;
        };

        /**
         * Creates a plain object from a QryLatestMsgResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryLatestMsgResp
         * @static
         * @param {immessage.QryLatestMsgResp} message QryLatestMsgResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryLatestMsgResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.converId = "";
                object.ChannelType = options.enums === String ? "Unknown" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.msgSeqNo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msgSeqNo = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.msgTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msgTime = options.longs === String ? "0" : 0;
                object.msgId = "";
            }
            if (message.converId != null && message.hasOwnProperty("converId"))
                object.converId = message.converId;
            if (message.ChannelType != null && message.hasOwnProperty("ChannelType"))
                object.ChannelType = options.enums === String ? $root.immessage.ChannelType[message.ChannelType] === undefined ? message.ChannelType : $root.immessage.ChannelType[message.ChannelType] : message.ChannelType;
            if (message.msgSeqNo != null && message.hasOwnProperty("msgSeqNo"))
                if (typeof message.msgSeqNo === "number")
                    object.msgSeqNo = options.longs === String ? String(message.msgSeqNo) : message.msgSeqNo;
                else
                    object.msgSeqNo = options.longs === String ? $util.Long.prototype.toString.call(message.msgSeqNo) : options.longs === Number ? new $util.LongBits(message.msgSeqNo.low >>> 0, message.msgSeqNo.high >>> 0).toNumber() : message.msgSeqNo;
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (typeof message.msgTime === "number")
                    object.msgTime = options.longs === String ? String(message.msgTime) : message.msgTime;
                else
                    object.msgTime = options.longs === String ? $util.Long.prototype.toString.call(message.msgTime) : options.longs === Number ? new $util.LongBits(message.msgTime.low >>> 0, message.msgTime.high >>> 0).toNumber() : message.msgTime;
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            return object;
        };

        /**
         * Converts this QryLatestMsgResp to JSON.
         * @function toJSON
         * @memberof immessage.QryLatestMsgResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryLatestMsgResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryLatestMsgResp
         * @function getTypeUrl
         * @memberof immessage.QryLatestMsgResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryLatestMsgResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryLatestMsgResp";
        };

        return QryLatestMsgResp;
    })();

    immessage.QryHisMsgsReq = (function() {

        /**
         * Properties of a QryHisMsgsReq.
         * @memberof immessage
         * @interface IQryHisMsgsReq
         * @property {string|null} [targetId] QryHisMsgsReq targetId
         * @property {immessage.ChannelType|null} [channelType] QryHisMsgsReq channelType
         * @property {number|Long|null} [startTime] QryHisMsgsReq startTime
         * @property {number|null} [count] QryHisMsgsReq count
         * @property {number|null} [order] QryHisMsgsReq order
         * @property {Array.<string>|null} [msgTypes] QryHisMsgsReq msgTypes
         * @property {number|null} [maxHisMsgCount] QryHisMsgsReq maxHisMsgCount
         * @property {string|null} [targetIdAlias] QryHisMsgsReq targetIdAlias
         */

        /**
         * Constructs a new QryHisMsgsReq.
         * @memberof immessage
         * @classdesc Represents a QryHisMsgsReq.
         * @implements IQryHisMsgsReq
         * @constructor
         * @param {immessage.IQryHisMsgsReq=} [properties] Properties to set
         */
        function QryHisMsgsReq(properties) {
            this.msgTypes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryHisMsgsReq targetId.
         * @member {string} targetId
         * @memberof immessage.QryHisMsgsReq
         * @instance
         */
        QryHisMsgsReq.prototype.targetId = "";

        /**
         * QryHisMsgsReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.QryHisMsgsReq
         * @instance
         */
        QryHisMsgsReq.prototype.channelType = 0;

        /**
         * QryHisMsgsReq startTime.
         * @member {number|Long} startTime
         * @memberof immessage.QryHisMsgsReq
         * @instance
         */
        QryHisMsgsReq.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QryHisMsgsReq count.
         * @member {number} count
         * @memberof immessage.QryHisMsgsReq
         * @instance
         */
        QryHisMsgsReq.prototype.count = 0;

        /**
         * QryHisMsgsReq order.
         * @member {number} order
         * @memberof immessage.QryHisMsgsReq
         * @instance
         */
        QryHisMsgsReq.prototype.order = 0;

        /**
         * QryHisMsgsReq msgTypes.
         * @member {Array.<string>} msgTypes
         * @memberof immessage.QryHisMsgsReq
         * @instance
         */
        QryHisMsgsReq.prototype.msgTypes = $util.emptyArray;

        /**
         * QryHisMsgsReq maxHisMsgCount.
         * @member {number} maxHisMsgCount
         * @memberof immessage.QryHisMsgsReq
         * @instance
         */
        QryHisMsgsReq.prototype.maxHisMsgCount = 0;

        /**
         * QryHisMsgsReq targetIdAlias.
         * @member {string} targetIdAlias
         * @memberof immessage.QryHisMsgsReq
         * @instance
         */
        QryHisMsgsReq.prototype.targetIdAlias = "";

        /**
         * Creates a new QryHisMsgsReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryHisMsgsReq
         * @static
         * @param {immessage.IQryHisMsgsReq=} [properties] Properties to set
         * @returns {immessage.QryHisMsgsReq} QryHisMsgsReq instance
         */
        QryHisMsgsReq.create = function create(properties) {
            return new QryHisMsgsReq(properties);
        };

        /**
         * Encodes the specified QryHisMsgsReq message. Does not implicitly {@link immessage.QryHisMsgsReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryHisMsgsReq
         * @static
         * @param {immessage.IQryHisMsgsReq} message QryHisMsgsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryHisMsgsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.startTime);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.count);
            if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.order);
            if (message.msgTypes != null && message.msgTypes.length)
                for (let i = 0; i < message.msgTypes.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.msgTypes[i]);
            if (message.maxHisMsgCount != null && Object.hasOwnProperty.call(message, "maxHisMsgCount"))
                writer.uint32(/* id 51, wireType 0 =*/408).int32(message.maxHisMsgCount);
            if (message.targetIdAlias != null && Object.hasOwnProperty.call(message, "targetIdAlias"))
                writer.uint32(/* id 52, wireType 2 =*/418).string(message.targetIdAlias);
            return writer;
        };

        /**
         * Encodes the specified QryHisMsgsReq message, length delimited. Does not implicitly {@link immessage.QryHisMsgsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryHisMsgsReq
         * @static
         * @param {immessage.IQryHisMsgsReq} message QryHisMsgsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryHisMsgsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryHisMsgsReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryHisMsgsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryHisMsgsReq} QryHisMsgsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryHisMsgsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryHisMsgsReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        message.startTime = reader.int64();
                        break;
                    }
                case 4: {
                        message.count = reader.int32();
                        break;
                    }
                case 5: {
                        message.order = reader.int32();
                        break;
                    }
                case 6: {
                        if (!(message.msgTypes && message.msgTypes.length))
                            message.msgTypes = [];
                        message.msgTypes.push(reader.string());
                        break;
                    }
                case 51: {
                        message.maxHisMsgCount = reader.int32();
                        break;
                    }
                case 52: {
                        message.targetIdAlias = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryHisMsgsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryHisMsgsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryHisMsgsReq} QryHisMsgsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryHisMsgsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryHisMsgsReq message.
         * @function verify
         * @memberof immessage.QryHisMsgsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryHisMsgsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            if (message.order != null && message.hasOwnProperty("order"))
                if (!$util.isInteger(message.order))
                    return "order: integer expected";
            if (message.msgTypes != null && message.hasOwnProperty("msgTypes")) {
                if (!Array.isArray(message.msgTypes))
                    return "msgTypes: array expected";
                for (let i = 0; i < message.msgTypes.length; ++i)
                    if (!$util.isString(message.msgTypes[i]))
                        return "msgTypes: string[] expected";
            }
            if (message.maxHisMsgCount != null && message.hasOwnProperty("maxHisMsgCount"))
                if (!$util.isInteger(message.maxHisMsgCount))
                    return "maxHisMsgCount: integer expected";
            if (message.targetIdAlias != null && message.hasOwnProperty("targetIdAlias"))
                if (!$util.isString(message.targetIdAlias))
                    return "targetIdAlias: string expected";
            return null;
        };

        /**
         * Creates a QryHisMsgsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryHisMsgsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryHisMsgsReq} QryHisMsgsReq
         */
        QryHisMsgsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryHisMsgsReq)
                return object;
            let message = new $root.immessage.QryHisMsgsReq();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = false;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber();
            if (object.count != null)
                message.count = object.count | 0;
            if (object.order != null)
                message.order = object.order | 0;
            if (object.msgTypes) {
                if (!Array.isArray(object.msgTypes))
                    throw TypeError(".immessage.QryHisMsgsReq.msgTypes: array expected");
                message.msgTypes = [];
                for (let i = 0; i < object.msgTypes.length; ++i)
                    message.msgTypes[i] = String(object.msgTypes[i]);
            }
            if (object.maxHisMsgCount != null)
                message.maxHisMsgCount = object.maxHisMsgCount | 0;
            if (object.targetIdAlias != null)
                message.targetIdAlias = String(object.targetIdAlias);
            return message;
        };

        /**
         * Creates a plain object from a QryHisMsgsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryHisMsgsReq
         * @static
         * @param {immessage.QryHisMsgsReq} message QryHisMsgsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryHisMsgsReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.msgTypes = [];
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTime = options.longs === String ? "0" : 0;
                object.count = 0;
                object.order = 0;
                object.maxHisMsgCount = 0;
                object.targetIdAlias = "";
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (typeof message.startTime === "number")
                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                else
                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber() : message.startTime;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            if (message.order != null && message.hasOwnProperty("order"))
                object.order = message.order;
            if (message.msgTypes && message.msgTypes.length) {
                object.msgTypes = [];
                for (let j = 0; j < message.msgTypes.length; ++j)
                    object.msgTypes[j] = message.msgTypes[j];
            }
            if (message.maxHisMsgCount != null && message.hasOwnProperty("maxHisMsgCount"))
                object.maxHisMsgCount = message.maxHisMsgCount;
            if (message.targetIdAlias != null && message.hasOwnProperty("targetIdAlias"))
                object.targetIdAlias = message.targetIdAlias;
            return object;
        };

        /**
         * Converts this QryHisMsgsReq to JSON.
         * @function toJSON
         * @memberof immessage.QryHisMsgsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryHisMsgsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryHisMsgsReq
         * @function getTypeUrl
         * @memberof immessage.QryHisMsgsReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryHisMsgsReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryHisMsgsReq";
        };

        return QryHisMsgsReq;
    })();

    immessage.QryFirstUnreadMsgReq = (function() {

        /**
         * Properties of a QryFirstUnreadMsgReq.
         * @memberof immessage
         * @interface IQryFirstUnreadMsgReq
         * @property {string|null} [targetId] QryFirstUnreadMsgReq targetId
         * @property {immessage.ChannelType|null} [channelType] QryFirstUnreadMsgReq channelType
         */

        /**
         * Constructs a new QryFirstUnreadMsgReq.
         * @memberof immessage
         * @classdesc Represents a QryFirstUnreadMsgReq.
         * @implements IQryFirstUnreadMsgReq
         * @constructor
         * @param {immessage.IQryFirstUnreadMsgReq=} [properties] Properties to set
         */
        function QryFirstUnreadMsgReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryFirstUnreadMsgReq targetId.
         * @member {string} targetId
         * @memberof immessage.QryFirstUnreadMsgReq
         * @instance
         */
        QryFirstUnreadMsgReq.prototype.targetId = "";

        /**
         * QryFirstUnreadMsgReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.QryFirstUnreadMsgReq
         * @instance
         */
        QryFirstUnreadMsgReq.prototype.channelType = 0;

        /**
         * Creates a new QryFirstUnreadMsgReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryFirstUnreadMsgReq
         * @static
         * @param {immessage.IQryFirstUnreadMsgReq=} [properties] Properties to set
         * @returns {immessage.QryFirstUnreadMsgReq} QryFirstUnreadMsgReq instance
         */
        QryFirstUnreadMsgReq.create = function create(properties) {
            return new QryFirstUnreadMsgReq(properties);
        };

        /**
         * Encodes the specified QryFirstUnreadMsgReq message. Does not implicitly {@link immessage.QryFirstUnreadMsgReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryFirstUnreadMsgReq
         * @static
         * @param {immessage.IQryFirstUnreadMsgReq} message QryFirstUnreadMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryFirstUnreadMsgReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            return writer;
        };

        /**
         * Encodes the specified QryFirstUnreadMsgReq message, length delimited. Does not implicitly {@link immessage.QryFirstUnreadMsgReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryFirstUnreadMsgReq
         * @static
         * @param {immessage.IQryFirstUnreadMsgReq} message QryFirstUnreadMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryFirstUnreadMsgReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryFirstUnreadMsgReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryFirstUnreadMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryFirstUnreadMsgReq} QryFirstUnreadMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryFirstUnreadMsgReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryFirstUnreadMsgReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryFirstUnreadMsgReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryFirstUnreadMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryFirstUnreadMsgReq} QryFirstUnreadMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryFirstUnreadMsgReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryFirstUnreadMsgReq message.
         * @function verify
         * @memberof immessage.QryFirstUnreadMsgReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryFirstUnreadMsgReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            return null;
        };

        /**
         * Creates a QryFirstUnreadMsgReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryFirstUnreadMsgReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryFirstUnreadMsgReq} QryFirstUnreadMsgReq
         */
        QryFirstUnreadMsgReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryFirstUnreadMsgReq)
                return object;
            let message = new $root.immessage.QryFirstUnreadMsgReq();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a QryFirstUnreadMsgReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryFirstUnreadMsgReq
         * @static
         * @param {immessage.QryFirstUnreadMsgReq} message QryFirstUnreadMsgReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryFirstUnreadMsgReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            return object;
        };

        /**
         * Converts this QryFirstUnreadMsgReq to JSON.
         * @function toJSON
         * @memberof immessage.QryFirstUnreadMsgReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryFirstUnreadMsgReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryFirstUnreadMsgReq
         * @function getTypeUrl
         * @memberof immessage.QryFirstUnreadMsgReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryFirstUnreadMsgReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryFirstUnreadMsgReq";
        };

        return QryFirstUnreadMsgReq;
    })();

    immessage.QryHisMsgByIdsReq = (function() {

        /**
         * Properties of a QryHisMsgByIdsReq.
         * @memberof immessage
         * @interface IQryHisMsgByIdsReq
         * @property {string|null} [targetId] QryHisMsgByIdsReq targetId
         * @property {immessage.ChannelType|null} [channelType] QryHisMsgByIdsReq channelType
         * @property {Array.<string>|null} [msgIds] QryHisMsgByIdsReq msgIds
         */

        /**
         * Constructs a new QryHisMsgByIdsReq.
         * @memberof immessage
         * @classdesc Represents a QryHisMsgByIdsReq.
         * @implements IQryHisMsgByIdsReq
         * @constructor
         * @param {immessage.IQryHisMsgByIdsReq=} [properties] Properties to set
         */
        function QryHisMsgByIdsReq(properties) {
            this.msgIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryHisMsgByIdsReq targetId.
         * @member {string} targetId
         * @memberof immessage.QryHisMsgByIdsReq
         * @instance
         */
        QryHisMsgByIdsReq.prototype.targetId = "";

        /**
         * QryHisMsgByIdsReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.QryHisMsgByIdsReq
         * @instance
         */
        QryHisMsgByIdsReq.prototype.channelType = 0;

        /**
         * QryHisMsgByIdsReq msgIds.
         * @member {Array.<string>} msgIds
         * @memberof immessage.QryHisMsgByIdsReq
         * @instance
         */
        QryHisMsgByIdsReq.prototype.msgIds = $util.emptyArray;

        /**
         * Creates a new QryHisMsgByIdsReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryHisMsgByIdsReq
         * @static
         * @param {immessage.IQryHisMsgByIdsReq=} [properties] Properties to set
         * @returns {immessage.QryHisMsgByIdsReq} QryHisMsgByIdsReq instance
         */
        QryHisMsgByIdsReq.create = function create(properties) {
            return new QryHisMsgByIdsReq(properties);
        };

        /**
         * Encodes the specified QryHisMsgByIdsReq message. Does not implicitly {@link immessage.QryHisMsgByIdsReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryHisMsgByIdsReq
         * @static
         * @param {immessage.IQryHisMsgByIdsReq} message QryHisMsgByIdsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryHisMsgByIdsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.msgIds != null && message.msgIds.length)
                for (let i = 0; i < message.msgIds.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.msgIds[i]);
            return writer;
        };

        /**
         * Encodes the specified QryHisMsgByIdsReq message, length delimited. Does not implicitly {@link immessage.QryHisMsgByIdsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryHisMsgByIdsReq
         * @static
         * @param {immessage.IQryHisMsgByIdsReq} message QryHisMsgByIdsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryHisMsgByIdsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryHisMsgByIdsReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryHisMsgByIdsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryHisMsgByIdsReq} QryHisMsgByIdsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryHisMsgByIdsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryHisMsgByIdsReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.msgIds && message.msgIds.length))
                            message.msgIds = [];
                        message.msgIds.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryHisMsgByIdsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryHisMsgByIdsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryHisMsgByIdsReq} QryHisMsgByIdsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryHisMsgByIdsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryHisMsgByIdsReq message.
         * @function verify
         * @memberof immessage.QryHisMsgByIdsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryHisMsgByIdsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.msgIds != null && message.hasOwnProperty("msgIds")) {
                if (!Array.isArray(message.msgIds))
                    return "msgIds: array expected";
                for (let i = 0; i < message.msgIds.length; ++i)
                    if (!$util.isString(message.msgIds[i]))
                        return "msgIds: string[] expected";
            }
            return null;
        };

        /**
         * Creates a QryHisMsgByIdsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryHisMsgByIdsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryHisMsgByIdsReq} QryHisMsgByIdsReq
         */
        QryHisMsgByIdsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryHisMsgByIdsReq)
                return object;
            let message = new $root.immessage.QryHisMsgByIdsReq();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.msgIds) {
                if (!Array.isArray(object.msgIds))
                    throw TypeError(".immessage.QryHisMsgByIdsReq.msgIds: array expected");
                message.msgIds = [];
                for (let i = 0; i < object.msgIds.length; ++i)
                    message.msgIds[i] = String(object.msgIds[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a QryHisMsgByIdsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryHisMsgByIdsReq
         * @static
         * @param {immessage.QryHisMsgByIdsReq} message QryHisMsgByIdsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryHisMsgByIdsReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.msgIds = [];
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.msgIds && message.msgIds.length) {
                object.msgIds = [];
                for (let j = 0; j < message.msgIds.length; ++j)
                    object.msgIds[j] = message.msgIds[j];
            }
            return object;
        };

        /**
         * Converts this QryHisMsgByIdsReq to JSON.
         * @function toJSON
         * @memberof immessage.QryHisMsgByIdsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryHisMsgByIdsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryHisMsgByIdsReq
         * @function getTypeUrl
         * @memberof immessage.QryHisMsgByIdsReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryHisMsgByIdsReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryHisMsgByIdsReq";
        };

        return QryHisMsgByIdsReq;
    })();

    immessage.RecallMsgReq = (function() {

        /**
         * Properties of a RecallMsgReq.
         * @memberof immessage
         * @interface IRecallMsgReq
         * @property {string|null} [targetId] RecallMsgReq targetId
         * @property {immessage.ChannelType|null} [channelType] RecallMsgReq channelType
         * @property {string|null} [msgId] RecallMsgReq msgId
         * @property {number|Long|null} [msgTime] RecallMsgReq msgTime
         * @property {Array.<immessage.IKvItem>|null} [exts] RecallMsgReq exts
         */

        /**
         * Constructs a new RecallMsgReq.
         * @memberof immessage
         * @classdesc Represents a RecallMsgReq.
         * @implements IRecallMsgReq
         * @constructor
         * @param {immessage.IRecallMsgReq=} [properties] Properties to set
         */
        function RecallMsgReq(properties) {
            this.exts = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecallMsgReq targetId.
         * @member {string} targetId
         * @memberof immessage.RecallMsgReq
         * @instance
         */
        RecallMsgReq.prototype.targetId = "";

        /**
         * RecallMsgReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.RecallMsgReq
         * @instance
         */
        RecallMsgReq.prototype.channelType = 0;

        /**
         * RecallMsgReq msgId.
         * @member {string} msgId
         * @memberof immessage.RecallMsgReq
         * @instance
         */
        RecallMsgReq.prototype.msgId = "";

        /**
         * RecallMsgReq msgTime.
         * @member {number|Long} msgTime
         * @memberof immessage.RecallMsgReq
         * @instance
         */
        RecallMsgReq.prototype.msgTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RecallMsgReq exts.
         * @member {Array.<immessage.IKvItem>} exts
         * @memberof immessage.RecallMsgReq
         * @instance
         */
        RecallMsgReq.prototype.exts = $util.emptyArray;

        /**
         * Creates a new RecallMsgReq instance using the specified properties.
         * @function create
         * @memberof immessage.RecallMsgReq
         * @static
         * @param {immessage.IRecallMsgReq=} [properties] Properties to set
         * @returns {immessage.RecallMsgReq} RecallMsgReq instance
         */
        RecallMsgReq.create = function create(properties) {
            return new RecallMsgReq(properties);
        };

        /**
         * Encodes the specified RecallMsgReq message. Does not implicitly {@link immessage.RecallMsgReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.RecallMsgReq
         * @static
         * @param {immessage.IRecallMsgReq} message RecallMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecallMsgReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.msgId);
            if (message.msgTime != null && Object.hasOwnProperty.call(message, "msgTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.msgTime);
            if (message.exts != null && message.exts.length)
                for (let i = 0; i < message.exts.length; ++i)
                    $root.immessage.KvItem.encode(message.exts[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RecallMsgReq message, length delimited. Does not implicitly {@link immessage.RecallMsgReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.RecallMsgReq
         * @static
         * @param {immessage.IRecallMsgReq} message RecallMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecallMsgReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecallMsgReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.RecallMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.RecallMsgReq} RecallMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecallMsgReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.RecallMsgReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        message.msgId = reader.string();
                        break;
                    }
                case 4: {
                        message.msgTime = reader.int64();
                        break;
                    }
                case 5: {
                        if (!(message.exts && message.exts.length))
                            message.exts = [];
                        message.exts.push($root.immessage.KvItem.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecallMsgReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.RecallMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.RecallMsgReq} RecallMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecallMsgReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecallMsgReq message.
         * @function verify
         * @memberof immessage.RecallMsgReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecallMsgReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (!$util.isInteger(message.msgTime) && !(message.msgTime && $util.isInteger(message.msgTime.low) && $util.isInteger(message.msgTime.high)))
                    return "msgTime: integer|Long expected";
            if (message.exts != null && message.hasOwnProperty("exts")) {
                if (!Array.isArray(message.exts))
                    return "exts: array expected";
                for (let i = 0; i < message.exts.length; ++i) {
                    let error = $root.immessage.KvItem.verify(message.exts[i]);
                    if (error)
                        return "exts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RecallMsgReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.RecallMsgReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.RecallMsgReq} RecallMsgReq
         */
        RecallMsgReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.RecallMsgReq)
                return object;
            let message = new $root.immessage.RecallMsgReq();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            if (object.msgTime != null)
                if ($util.Long)
                    (message.msgTime = $util.Long.fromValue(object.msgTime)).unsigned = false;
                else if (typeof object.msgTime === "string")
                    message.msgTime = parseInt(object.msgTime, 10);
                else if (typeof object.msgTime === "number")
                    message.msgTime = object.msgTime;
                else if (typeof object.msgTime === "object")
                    message.msgTime = new $util.LongBits(object.msgTime.low >>> 0, object.msgTime.high >>> 0).toNumber();
            if (object.exts) {
                if (!Array.isArray(object.exts))
                    throw TypeError(".immessage.RecallMsgReq.exts: array expected");
                message.exts = [];
                for (let i = 0; i < object.exts.length; ++i) {
                    if (typeof object.exts[i] !== "object")
                        throw TypeError(".immessage.RecallMsgReq.exts: object expected");
                    message.exts[i] = $root.immessage.KvItem.fromObject(object.exts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RecallMsgReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.RecallMsgReq
         * @static
         * @param {immessage.RecallMsgReq} message RecallMsgReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecallMsgReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.exts = [];
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                object.msgId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.msgTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msgTime = options.longs === String ? "0" : 0;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (typeof message.msgTime === "number")
                    object.msgTime = options.longs === String ? String(message.msgTime) : message.msgTime;
                else
                    object.msgTime = options.longs === String ? $util.Long.prototype.toString.call(message.msgTime) : options.longs === Number ? new $util.LongBits(message.msgTime.low >>> 0, message.msgTime.high >>> 0).toNumber() : message.msgTime;
            if (message.exts && message.exts.length) {
                object.exts = [];
                for (let j = 0; j < message.exts.length; ++j)
                    object.exts[j] = $root.immessage.KvItem.toObject(message.exts[j], options);
            }
            return object;
        };

        /**
         * Converts this RecallMsgReq to JSON.
         * @function toJSON
         * @memberof immessage.RecallMsgReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecallMsgReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RecallMsgReq
         * @function getTypeUrl
         * @memberof immessage.RecallMsgReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RecallMsgReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.RecallMsgReq";
        };

        return RecallMsgReq;
    })();

    immessage.MarkReadReq = (function() {

        /**
         * Properties of a MarkReadReq.
         * @memberof immessage
         * @interface IMarkReadReq
         * @property {string|null} [targetId] MarkReadReq targetId
         * @property {immessage.ChannelType|null} [channelType] MarkReadReq channelType
         * @property {Array.<immessage.ISimpleMsg>|null} [msgs] MarkReadReq msgs
         * @property {Array.<immessage.IIndexScope>|null} [indexScopes] MarkReadReq indexScopes
         */

        /**
         * Constructs a new MarkReadReq.
         * @memberof immessage
         * @classdesc Represents a MarkReadReq.
         * @implements IMarkReadReq
         * @constructor
         * @param {immessage.IMarkReadReq=} [properties] Properties to set
         */
        function MarkReadReq(properties) {
            this.msgs = [];
            this.indexScopes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MarkReadReq targetId.
         * @member {string} targetId
         * @memberof immessage.MarkReadReq
         * @instance
         */
        MarkReadReq.prototype.targetId = "";

        /**
         * MarkReadReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.MarkReadReq
         * @instance
         */
        MarkReadReq.prototype.channelType = 0;

        /**
         * MarkReadReq msgs.
         * @member {Array.<immessage.ISimpleMsg>} msgs
         * @memberof immessage.MarkReadReq
         * @instance
         */
        MarkReadReq.prototype.msgs = $util.emptyArray;

        /**
         * MarkReadReq indexScopes.
         * @member {Array.<immessage.IIndexScope>} indexScopes
         * @memberof immessage.MarkReadReq
         * @instance
         */
        MarkReadReq.prototype.indexScopes = $util.emptyArray;

        /**
         * Creates a new MarkReadReq instance using the specified properties.
         * @function create
         * @memberof immessage.MarkReadReq
         * @static
         * @param {immessage.IMarkReadReq=} [properties] Properties to set
         * @returns {immessage.MarkReadReq} MarkReadReq instance
         */
        MarkReadReq.create = function create(properties) {
            return new MarkReadReq(properties);
        };

        /**
         * Encodes the specified MarkReadReq message. Does not implicitly {@link immessage.MarkReadReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.MarkReadReq
         * @static
         * @param {immessage.IMarkReadReq} message MarkReadReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MarkReadReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.msgs != null && message.msgs.length)
                for (let i = 0; i < message.msgs.length; ++i)
                    $root.immessage.SimpleMsg.encode(message.msgs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.indexScopes != null && message.indexScopes.length)
                for (let i = 0; i < message.indexScopes.length; ++i)
                    $root.immessage.IndexScope.encode(message.indexScopes[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MarkReadReq message, length delimited. Does not implicitly {@link immessage.MarkReadReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.MarkReadReq
         * @static
         * @param {immessage.IMarkReadReq} message MarkReadReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MarkReadReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MarkReadReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.MarkReadReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.MarkReadReq} MarkReadReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MarkReadReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.MarkReadReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.msgs && message.msgs.length))
                            message.msgs = [];
                        message.msgs.push($root.immessage.SimpleMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (!(message.indexScopes && message.indexScopes.length))
                            message.indexScopes = [];
                        message.indexScopes.push($root.immessage.IndexScope.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MarkReadReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.MarkReadReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.MarkReadReq} MarkReadReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MarkReadReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MarkReadReq message.
         * @function verify
         * @memberof immessage.MarkReadReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MarkReadReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.msgs != null && message.hasOwnProperty("msgs")) {
                if (!Array.isArray(message.msgs))
                    return "msgs: array expected";
                for (let i = 0; i < message.msgs.length; ++i) {
                    let error = $root.immessage.SimpleMsg.verify(message.msgs[i]);
                    if (error)
                        return "msgs." + error;
                }
            }
            if (message.indexScopes != null && message.hasOwnProperty("indexScopes")) {
                if (!Array.isArray(message.indexScopes))
                    return "indexScopes: array expected";
                for (let i = 0; i < message.indexScopes.length; ++i) {
                    let error = $root.immessage.IndexScope.verify(message.indexScopes[i]);
                    if (error)
                        return "indexScopes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MarkReadReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.MarkReadReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.MarkReadReq} MarkReadReq
         */
        MarkReadReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.MarkReadReq)
                return object;
            let message = new $root.immessage.MarkReadReq();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.msgs) {
                if (!Array.isArray(object.msgs))
                    throw TypeError(".immessage.MarkReadReq.msgs: array expected");
                message.msgs = [];
                for (let i = 0; i < object.msgs.length; ++i) {
                    if (typeof object.msgs[i] !== "object")
                        throw TypeError(".immessage.MarkReadReq.msgs: object expected");
                    message.msgs[i] = $root.immessage.SimpleMsg.fromObject(object.msgs[i]);
                }
            }
            if (object.indexScopes) {
                if (!Array.isArray(object.indexScopes))
                    throw TypeError(".immessage.MarkReadReq.indexScopes: array expected");
                message.indexScopes = [];
                for (let i = 0; i < object.indexScopes.length; ++i) {
                    if (typeof object.indexScopes[i] !== "object")
                        throw TypeError(".immessage.MarkReadReq.indexScopes: object expected");
                    message.indexScopes[i] = $root.immessage.IndexScope.fromObject(object.indexScopes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MarkReadReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.MarkReadReq
         * @static
         * @param {immessage.MarkReadReq} message MarkReadReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MarkReadReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.msgs = [];
                object.indexScopes = [];
            }
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.msgs && message.msgs.length) {
                object.msgs = [];
                for (let j = 0; j < message.msgs.length; ++j)
                    object.msgs[j] = $root.immessage.SimpleMsg.toObject(message.msgs[j], options);
            }
            if (message.indexScopes && message.indexScopes.length) {
                object.indexScopes = [];
                for (let j = 0; j < message.indexScopes.length; ++j)
                    object.indexScopes[j] = $root.immessage.IndexScope.toObject(message.indexScopes[j], options);
            }
            return object;
        };

        /**
         * Converts this MarkReadReq to JSON.
         * @function toJSON
         * @memberof immessage.MarkReadReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MarkReadReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MarkReadReq
         * @function getTypeUrl
         * @memberof immessage.MarkReadReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MarkReadReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.MarkReadReq";
        };

        return MarkReadReq;
    })();

    immessage.MarkGrpMsgReadReq = (function() {

        /**
         * Properties of a MarkGrpMsgReadReq.
         * @memberof immessage
         * @interface IMarkGrpMsgReadReq
         * @property {string|null} [groupId] MarkGrpMsgReadReq groupId
         * @property {immessage.ChannelType|null} [channelType] MarkGrpMsgReadReq channelType
         * @property {Array.<string>|null} [msgIds] MarkGrpMsgReadReq msgIds
         */

        /**
         * Constructs a new MarkGrpMsgReadReq.
         * @memberof immessage
         * @classdesc Represents a MarkGrpMsgReadReq.
         * @implements IMarkGrpMsgReadReq
         * @constructor
         * @param {immessage.IMarkGrpMsgReadReq=} [properties] Properties to set
         */
        function MarkGrpMsgReadReq(properties) {
            this.msgIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MarkGrpMsgReadReq groupId.
         * @member {string} groupId
         * @memberof immessage.MarkGrpMsgReadReq
         * @instance
         */
        MarkGrpMsgReadReq.prototype.groupId = "";

        /**
         * MarkGrpMsgReadReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.MarkGrpMsgReadReq
         * @instance
         */
        MarkGrpMsgReadReq.prototype.channelType = 0;

        /**
         * MarkGrpMsgReadReq msgIds.
         * @member {Array.<string>} msgIds
         * @memberof immessage.MarkGrpMsgReadReq
         * @instance
         */
        MarkGrpMsgReadReq.prototype.msgIds = $util.emptyArray;

        /**
         * Creates a new MarkGrpMsgReadReq instance using the specified properties.
         * @function create
         * @memberof immessage.MarkGrpMsgReadReq
         * @static
         * @param {immessage.IMarkGrpMsgReadReq=} [properties] Properties to set
         * @returns {immessage.MarkGrpMsgReadReq} MarkGrpMsgReadReq instance
         */
        MarkGrpMsgReadReq.create = function create(properties) {
            return new MarkGrpMsgReadReq(properties);
        };

        /**
         * Encodes the specified MarkGrpMsgReadReq message. Does not implicitly {@link immessage.MarkGrpMsgReadReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.MarkGrpMsgReadReq
         * @static
         * @param {immessage.IMarkGrpMsgReadReq} message MarkGrpMsgReadReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MarkGrpMsgReadReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.msgIds != null && message.msgIds.length)
                for (let i = 0; i < message.msgIds.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.msgIds[i]);
            return writer;
        };

        /**
         * Encodes the specified MarkGrpMsgReadReq message, length delimited. Does not implicitly {@link immessage.MarkGrpMsgReadReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.MarkGrpMsgReadReq
         * @static
         * @param {immessage.IMarkGrpMsgReadReq} message MarkGrpMsgReadReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MarkGrpMsgReadReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MarkGrpMsgReadReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.MarkGrpMsgReadReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.MarkGrpMsgReadReq} MarkGrpMsgReadReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MarkGrpMsgReadReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.MarkGrpMsgReadReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.groupId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.msgIds && message.msgIds.length))
                            message.msgIds = [];
                        message.msgIds.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MarkGrpMsgReadReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.MarkGrpMsgReadReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.MarkGrpMsgReadReq} MarkGrpMsgReadReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MarkGrpMsgReadReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MarkGrpMsgReadReq message.
         * @function verify
         * @memberof immessage.MarkGrpMsgReadReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MarkGrpMsgReadReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isString(message.groupId))
                    return "groupId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.msgIds != null && message.hasOwnProperty("msgIds")) {
                if (!Array.isArray(message.msgIds))
                    return "msgIds: array expected";
                for (let i = 0; i < message.msgIds.length; ++i)
                    if (!$util.isString(message.msgIds[i]))
                        return "msgIds: string[] expected";
            }
            return null;
        };

        /**
         * Creates a MarkGrpMsgReadReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.MarkGrpMsgReadReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.MarkGrpMsgReadReq} MarkGrpMsgReadReq
         */
        MarkGrpMsgReadReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.MarkGrpMsgReadReq)
                return object;
            let message = new $root.immessage.MarkGrpMsgReadReq();
            if (object.groupId != null)
                message.groupId = String(object.groupId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.msgIds) {
                if (!Array.isArray(object.msgIds))
                    throw TypeError(".immessage.MarkGrpMsgReadReq.msgIds: array expected");
                message.msgIds = [];
                for (let i = 0; i < object.msgIds.length; ++i)
                    message.msgIds[i] = String(object.msgIds[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a MarkGrpMsgReadReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.MarkGrpMsgReadReq
         * @static
         * @param {immessage.MarkGrpMsgReadReq} message MarkGrpMsgReadReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MarkGrpMsgReadReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.msgIds = [];
            if (options.defaults) {
                object.groupId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
            }
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = message.groupId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.msgIds && message.msgIds.length) {
                object.msgIds = [];
                for (let j = 0; j < message.msgIds.length; ++j)
                    object.msgIds[j] = message.msgIds[j];
            }
            return object;
        };

        /**
         * Converts this MarkGrpMsgReadReq to JSON.
         * @function toJSON
         * @memberof immessage.MarkGrpMsgReadReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MarkGrpMsgReadReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MarkGrpMsgReadReq
         * @function getTypeUrl
         * @memberof immessage.MarkGrpMsgReadReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MarkGrpMsgReadReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.MarkGrpMsgReadReq";
        };

        return MarkGrpMsgReadReq;
    })();

    immessage.CleanHisMsgReq = (function() {

        /**
         * Properties of a CleanHisMsgReq.
         * @memberof immessage
         * @interface ICleanHisMsgReq
         * @property {string|null} [targetId] CleanHisMsgReq targetId
         * @property {immessage.ChannelType|null} [channelType] CleanHisMsgReq channelType
         * @property {number|Long|null} [cleanMsgTime] CleanHisMsgReq cleanMsgTime
         * @property {number|null} [cleanScope] CleanHisMsgReq cleanScope
         * @property {string|null} [senderId] CleanHisMsgReq senderId
         * @property {number|Long|null} [cleanTimeOffset] CleanHisMsgReq cleanTimeOffset
         */

        /**
         * Constructs a new CleanHisMsgReq.
         * @memberof immessage
         * @classdesc Represents a CleanHisMsgReq.
         * @implements ICleanHisMsgReq
         * @constructor
         * @param {immessage.ICleanHisMsgReq=} [properties] Properties to set
         */
        function CleanHisMsgReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CleanHisMsgReq targetId.
         * @member {string} targetId
         * @memberof immessage.CleanHisMsgReq
         * @instance
         */
        CleanHisMsgReq.prototype.targetId = "";

        /**
         * CleanHisMsgReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.CleanHisMsgReq
         * @instance
         */
        CleanHisMsgReq.prototype.channelType = 0;

        /**
         * CleanHisMsgReq cleanMsgTime.
         * @member {number|Long} cleanMsgTime
         * @memberof immessage.CleanHisMsgReq
         * @instance
         */
        CleanHisMsgReq.prototype.cleanMsgTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CleanHisMsgReq cleanScope.
         * @member {number} cleanScope
         * @memberof immessage.CleanHisMsgReq
         * @instance
         */
        CleanHisMsgReq.prototype.cleanScope = 0;

        /**
         * CleanHisMsgReq senderId.
         * @member {string} senderId
         * @memberof immessage.CleanHisMsgReq
         * @instance
         */
        CleanHisMsgReq.prototype.senderId = "";

        /**
         * CleanHisMsgReq cleanTimeOffset.
         * @member {number|Long} cleanTimeOffset
         * @memberof immessage.CleanHisMsgReq
         * @instance
         */
        CleanHisMsgReq.prototype.cleanTimeOffset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new CleanHisMsgReq instance using the specified properties.
         * @function create
         * @memberof immessage.CleanHisMsgReq
         * @static
         * @param {immessage.ICleanHisMsgReq=} [properties] Properties to set
         * @returns {immessage.CleanHisMsgReq} CleanHisMsgReq instance
         */
        CleanHisMsgReq.create = function create(properties) {
            return new CleanHisMsgReq(properties);
        };

        /**
         * Encodes the specified CleanHisMsgReq message. Does not implicitly {@link immessage.CleanHisMsgReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.CleanHisMsgReq
         * @static
         * @param {immessage.ICleanHisMsgReq} message CleanHisMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CleanHisMsgReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.cleanMsgTime != null && Object.hasOwnProperty.call(message, "cleanMsgTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.cleanMsgTime);
            if (message.cleanScope != null && Object.hasOwnProperty.call(message, "cleanScope"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.cleanScope);
            if (message.senderId != null && Object.hasOwnProperty.call(message, "senderId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.senderId);
            if (message.cleanTimeOffset != null && Object.hasOwnProperty.call(message, "cleanTimeOffset"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.cleanTimeOffset);
            return writer;
        };

        /**
         * Encodes the specified CleanHisMsgReq message, length delimited. Does not implicitly {@link immessage.CleanHisMsgReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.CleanHisMsgReq
         * @static
         * @param {immessage.ICleanHisMsgReq} message CleanHisMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CleanHisMsgReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CleanHisMsgReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.CleanHisMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.CleanHisMsgReq} CleanHisMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CleanHisMsgReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.CleanHisMsgReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        message.cleanMsgTime = reader.int64();
                        break;
                    }
                case 4: {
                        message.cleanScope = reader.int32();
                        break;
                    }
                case 5: {
                        message.senderId = reader.string();
                        break;
                    }
                case 6: {
                        message.cleanTimeOffset = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CleanHisMsgReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.CleanHisMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.CleanHisMsgReq} CleanHisMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CleanHisMsgReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CleanHisMsgReq message.
         * @function verify
         * @memberof immessage.CleanHisMsgReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CleanHisMsgReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.cleanMsgTime != null && message.hasOwnProperty("cleanMsgTime"))
                if (!$util.isInteger(message.cleanMsgTime) && !(message.cleanMsgTime && $util.isInteger(message.cleanMsgTime.low) && $util.isInteger(message.cleanMsgTime.high)))
                    return "cleanMsgTime: integer|Long expected";
            if (message.cleanScope != null && message.hasOwnProperty("cleanScope"))
                if (!$util.isInteger(message.cleanScope))
                    return "cleanScope: integer expected";
            if (message.senderId != null && message.hasOwnProperty("senderId"))
                if (!$util.isString(message.senderId))
                    return "senderId: string expected";
            if (message.cleanTimeOffset != null && message.hasOwnProperty("cleanTimeOffset"))
                if (!$util.isInteger(message.cleanTimeOffset) && !(message.cleanTimeOffset && $util.isInteger(message.cleanTimeOffset.low) && $util.isInteger(message.cleanTimeOffset.high)))
                    return "cleanTimeOffset: integer|Long expected";
            return null;
        };

        /**
         * Creates a CleanHisMsgReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.CleanHisMsgReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.CleanHisMsgReq} CleanHisMsgReq
         */
        CleanHisMsgReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.CleanHisMsgReq)
                return object;
            let message = new $root.immessage.CleanHisMsgReq();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.cleanMsgTime != null)
                if ($util.Long)
                    (message.cleanMsgTime = $util.Long.fromValue(object.cleanMsgTime)).unsigned = false;
                else if (typeof object.cleanMsgTime === "string")
                    message.cleanMsgTime = parseInt(object.cleanMsgTime, 10);
                else if (typeof object.cleanMsgTime === "number")
                    message.cleanMsgTime = object.cleanMsgTime;
                else if (typeof object.cleanMsgTime === "object")
                    message.cleanMsgTime = new $util.LongBits(object.cleanMsgTime.low >>> 0, object.cleanMsgTime.high >>> 0).toNumber();
            if (object.cleanScope != null)
                message.cleanScope = object.cleanScope | 0;
            if (object.senderId != null)
                message.senderId = String(object.senderId);
            if (object.cleanTimeOffset != null)
                if ($util.Long)
                    (message.cleanTimeOffset = $util.Long.fromValue(object.cleanTimeOffset)).unsigned = false;
                else if (typeof object.cleanTimeOffset === "string")
                    message.cleanTimeOffset = parseInt(object.cleanTimeOffset, 10);
                else if (typeof object.cleanTimeOffset === "number")
                    message.cleanTimeOffset = object.cleanTimeOffset;
                else if (typeof object.cleanTimeOffset === "object")
                    message.cleanTimeOffset = new $util.LongBits(object.cleanTimeOffset.low >>> 0, object.cleanTimeOffset.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a CleanHisMsgReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.CleanHisMsgReq
         * @static
         * @param {immessage.CleanHisMsgReq} message CleanHisMsgReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CleanHisMsgReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.cleanMsgTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.cleanMsgTime = options.longs === String ? "0" : 0;
                object.cleanScope = 0;
                object.senderId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.cleanTimeOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.cleanTimeOffset = options.longs === String ? "0" : 0;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.cleanMsgTime != null && message.hasOwnProperty("cleanMsgTime"))
                if (typeof message.cleanMsgTime === "number")
                    object.cleanMsgTime = options.longs === String ? String(message.cleanMsgTime) : message.cleanMsgTime;
                else
                    object.cleanMsgTime = options.longs === String ? $util.Long.prototype.toString.call(message.cleanMsgTime) : options.longs === Number ? new $util.LongBits(message.cleanMsgTime.low >>> 0, message.cleanMsgTime.high >>> 0).toNumber() : message.cleanMsgTime;
            if (message.cleanScope != null && message.hasOwnProperty("cleanScope"))
                object.cleanScope = message.cleanScope;
            if (message.senderId != null && message.hasOwnProperty("senderId"))
                object.senderId = message.senderId;
            if (message.cleanTimeOffset != null && message.hasOwnProperty("cleanTimeOffset"))
                if (typeof message.cleanTimeOffset === "number")
                    object.cleanTimeOffset = options.longs === String ? String(message.cleanTimeOffset) : message.cleanTimeOffset;
                else
                    object.cleanTimeOffset = options.longs === String ? $util.Long.prototype.toString.call(message.cleanTimeOffset) : options.longs === Number ? new $util.LongBits(message.cleanTimeOffset.low >>> 0, message.cleanTimeOffset.high >>> 0).toNumber() : message.cleanTimeOffset;
            return object;
        };

        /**
         * Converts this CleanHisMsgReq to JSON.
         * @function toJSON
         * @memberof immessage.CleanHisMsgReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CleanHisMsgReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CleanHisMsgReq
         * @function getTypeUrl
         * @memberof immessage.CleanHisMsgReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CleanHisMsgReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.CleanHisMsgReq";
        };

        return CleanHisMsgReq;
    })();

    immessage.SimpleMsg = (function() {

        /**
         * Properties of a SimpleMsg.
         * @memberof immessage
         * @interface ISimpleMsg
         * @property {string|null} [msgId] SimpleMsg msgId
         * @property {number|Long|null} [msgTime] SimpleMsg msgTime
         * @property {number|Long|null} [msgReadIndex] SimpleMsg msgReadIndex
         */

        /**
         * Constructs a new SimpleMsg.
         * @memberof immessage
         * @classdesc Represents a SimpleMsg.
         * @implements ISimpleMsg
         * @constructor
         * @param {immessage.ISimpleMsg=} [properties] Properties to set
         */
        function SimpleMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SimpleMsg msgId.
         * @member {string} msgId
         * @memberof immessage.SimpleMsg
         * @instance
         */
        SimpleMsg.prototype.msgId = "";

        /**
         * SimpleMsg msgTime.
         * @member {number|Long} msgTime
         * @memberof immessage.SimpleMsg
         * @instance
         */
        SimpleMsg.prototype.msgTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SimpleMsg msgReadIndex.
         * @member {number|Long} msgReadIndex
         * @memberof immessage.SimpleMsg
         * @instance
         */
        SimpleMsg.prototype.msgReadIndex = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SimpleMsg instance using the specified properties.
         * @function create
         * @memberof immessage.SimpleMsg
         * @static
         * @param {immessage.ISimpleMsg=} [properties] Properties to set
         * @returns {immessage.SimpleMsg} SimpleMsg instance
         */
        SimpleMsg.create = function create(properties) {
            return new SimpleMsg(properties);
        };

        /**
         * Encodes the specified SimpleMsg message. Does not implicitly {@link immessage.SimpleMsg.verify|verify} messages.
         * @function encode
         * @memberof immessage.SimpleMsg
         * @static
         * @param {immessage.ISimpleMsg} message SimpleMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.msgId);
            if (message.msgTime != null && Object.hasOwnProperty.call(message, "msgTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.msgTime);
            if (message.msgReadIndex != null && Object.hasOwnProperty.call(message, "msgReadIndex"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.msgReadIndex);
            return writer;
        };

        /**
         * Encodes the specified SimpleMsg message, length delimited. Does not implicitly {@link immessage.SimpleMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.SimpleMsg
         * @static
         * @param {immessage.ISimpleMsg} message SimpleMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SimpleMsg message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.SimpleMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.SimpleMsg} SimpleMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.SimpleMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.msgId = reader.string();
                        break;
                    }
                case 2: {
                        message.msgTime = reader.int64();
                        break;
                    }
                case 3: {
                        message.msgReadIndex = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SimpleMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.SimpleMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.SimpleMsg} SimpleMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SimpleMsg message.
         * @function verify
         * @memberof immessage.SimpleMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SimpleMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (!$util.isInteger(message.msgTime) && !(message.msgTime && $util.isInteger(message.msgTime.low) && $util.isInteger(message.msgTime.high)))
                    return "msgTime: integer|Long expected";
            if (message.msgReadIndex != null && message.hasOwnProperty("msgReadIndex"))
                if (!$util.isInteger(message.msgReadIndex) && !(message.msgReadIndex && $util.isInteger(message.msgReadIndex.low) && $util.isInteger(message.msgReadIndex.high)))
                    return "msgReadIndex: integer|Long expected";
            return null;
        };

        /**
         * Creates a SimpleMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.SimpleMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.SimpleMsg} SimpleMsg
         */
        SimpleMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.SimpleMsg)
                return object;
            let message = new $root.immessage.SimpleMsg();
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            if (object.msgTime != null)
                if ($util.Long)
                    (message.msgTime = $util.Long.fromValue(object.msgTime)).unsigned = false;
                else if (typeof object.msgTime === "string")
                    message.msgTime = parseInt(object.msgTime, 10);
                else if (typeof object.msgTime === "number")
                    message.msgTime = object.msgTime;
                else if (typeof object.msgTime === "object")
                    message.msgTime = new $util.LongBits(object.msgTime.low >>> 0, object.msgTime.high >>> 0).toNumber();
            if (object.msgReadIndex != null)
                if ($util.Long)
                    (message.msgReadIndex = $util.Long.fromValue(object.msgReadIndex)).unsigned = false;
                else if (typeof object.msgReadIndex === "string")
                    message.msgReadIndex = parseInt(object.msgReadIndex, 10);
                else if (typeof object.msgReadIndex === "number")
                    message.msgReadIndex = object.msgReadIndex;
                else if (typeof object.msgReadIndex === "object")
                    message.msgReadIndex = new $util.LongBits(object.msgReadIndex.low >>> 0, object.msgReadIndex.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SimpleMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.SimpleMsg
         * @static
         * @param {immessage.SimpleMsg} message SimpleMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SimpleMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.msgId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.msgTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msgTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.msgReadIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msgReadIndex = options.longs === String ? "0" : 0;
            }
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (typeof message.msgTime === "number")
                    object.msgTime = options.longs === String ? String(message.msgTime) : message.msgTime;
                else
                    object.msgTime = options.longs === String ? $util.Long.prototype.toString.call(message.msgTime) : options.longs === Number ? new $util.LongBits(message.msgTime.low >>> 0, message.msgTime.high >>> 0).toNumber() : message.msgTime;
            if (message.msgReadIndex != null && message.hasOwnProperty("msgReadIndex"))
                if (typeof message.msgReadIndex === "number")
                    object.msgReadIndex = options.longs === String ? String(message.msgReadIndex) : message.msgReadIndex;
                else
                    object.msgReadIndex = options.longs === String ? $util.Long.prototype.toString.call(message.msgReadIndex) : options.longs === Number ? new $util.LongBits(message.msgReadIndex.low >>> 0, message.msgReadIndex.high >>> 0).toNumber() : message.msgReadIndex;
            return object;
        };

        /**
         * Converts this SimpleMsg to JSON.
         * @function toJSON
         * @memberof immessage.SimpleMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SimpleMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SimpleMsg
         * @function getTypeUrl
         * @memberof immessage.SimpleMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SimpleMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.SimpleMsg";
        };

        return SimpleMsg;
    })();

    immessage.IndexScope = (function() {

        /**
         * Properties of an IndexScope.
         * @memberof immessage
         * @interface IIndexScope
         * @property {number|Long|null} [startIndex] IndexScope startIndex
         * @property {number|Long|null} [endIndex] IndexScope endIndex
         */

        /**
         * Constructs a new IndexScope.
         * @memberof immessage
         * @classdesc Represents an IndexScope.
         * @implements IIndexScope
         * @constructor
         * @param {immessage.IIndexScope=} [properties] Properties to set
         */
        function IndexScope(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IndexScope startIndex.
         * @member {number|Long} startIndex
         * @memberof immessage.IndexScope
         * @instance
         */
        IndexScope.prototype.startIndex = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IndexScope endIndex.
         * @member {number|Long} endIndex
         * @memberof immessage.IndexScope
         * @instance
         */
        IndexScope.prototype.endIndex = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new IndexScope instance using the specified properties.
         * @function create
         * @memberof immessage.IndexScope
         * @static
         * @param {immessage.IIndexScope=} [properties] Properties to set
         * @returns {immessage.IndexScope} IndexScope instance
         */
        IndexScope.create = function create(properties) {
            return new IndexScope(properties);
        };

        /**
         * Encodes the specified IndexScope message. Does not implicitly {@link immessage.IndexScope.verify|verify} messages.
         * @function encode
         * @memberof immessage.IndexScope
         * @static
         * @param {immessage.IIndexScope} message IndexScope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IndexScope.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startIndex != null && Object.hasOwnProperty.call(message, "startIndex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.startIndex);
            if (message.endIndex != null && Object.hasOwnProperty.call(message, "endIndex"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.endIndex);
            return writer;
        };

        /**
         * Encodes the specified IndexScope message, length delimited. Does not implicitly {@link immessage.IndexScope.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.IndexScope
         * @static
         * @param {immessage.IIndexScope} message IndexScope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IndexScope.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IndexScope message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.IndexScope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.IndexScope} IndexScope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IndexScope.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.IndexScope();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.startIndex = reader.int64();
                        break;
                    }
                case 2: {
                        message.endIndex = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IndexScope message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.IndexScope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.IndexScope} IndexScope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IndexScope.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IndexScope message.
         * @function verify
         * @memberof immessage.IndexScope
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IndexScope.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startIndex != null && message.hasOwnProperty("startIndex"))
                if (!$util.isInteger(message.startIndex) && !(message.startIndex && $util.isInteger(message.startIndex.low) && $util.isInteger(message.startIndex.high)))
                    return "startIndex: integer|Long expected";
            if (message.endIndex != null && message.hasOwnProperty("endIndex"))
                if (!$util.isInteger(message.endIndex) && !(message.endIndex && $util.isInteger(message.endIndex.low) && $util.isInteger(message.endIndex.high)))
                    return "endIndex: integer|Long expected";
            return null;
        };

        /**
         * Creates an IndexScope message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.IndexScope
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.IndexScope} IndexScope
         */
        IndexScope.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.IndexScope)
                return object;
            let message = new $root.immessage.IndexScope();
            if (object.startIndex != null)
                if ($util.Long)
                    (message.startIndex = $util.Long.fromValue(object.startIndex)).unsigned = false;
                else if (typeof object.startIndex === "string")
                    message.startIndex = parseInt(object.startIndex, 10);
                else if (typeof object.startIndex === "number")
                    message.startIndex = object.startIndex;
                else if (typeof object.startIndex === "object")
                    message.startIndex = new $util.LongBits(object.startIndex.low >>> 0, object.startIndex.high >>> 0).toNumber();
            if (object.endIndex != null)
                if ($util.Long)
                    (message.endIndex = $util.Long.fromValue(object.endIndex)).unsigned = false;
                else if (typeof object.endIndex === "string")
                    message.endIndex = parseInt(object.endIndex, 10);
                else if (typeof object.endIndex === "number")
                    message.endIndex = object.endIndex;
                else if (typeof object.endIndex === "object")
                    message.endIndex = new $util.LongBits(object.endIndex.low >>> 0, object.endIndex.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an IndexScope message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.IndexScope
         * @static
         * @param {immessage.IndexScope} message IndexScope
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IndexScope.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.startIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startIndex = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.endIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.endIndex = options.longs === String ? "0" : 0;
            }
            if (message.startIndex != null && message.hasOwnProperty("startIndex"))
                if (typeof message.startIndex === "number")
                    object.startIndex = options.longs === String ? String(message.startIndex) : message.startIndex;
                else
                    object.startIndex = options.longs === String ? $util.Long.prototype.toString.call(message.startIndex) : options.longs === Number ? new $util.LongBits(message.startIndex.low >>> 0, message.startIndex.high >>> 0).toNumber() : message.startIndex;
            if (message.endIndex != null && message.hasOwnProperty("endIndex"))
                if (typeof message.endIndex === "number")
                    object.endIndex = options.longs === String ? String(message.endIndex) : message.endIndex;
                else
                    object.endIndex = options.longs === String ? $util.Long.prototype.toString.call(message.endIndex) : options.longs === Number ? new $util.LongBits(message.endIndex.low >>> 0, message.endIndex.high >>> 0).toNumber() : message.endIndex;
            return object;
        };

        /**
         * Converts this IndexScope to JSON.
         * @function toJSON
         * @memberof immessage.IndexScope
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IndexScope.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for IndexScope
         * @function getTypeUrl
         * @memberof immessage.IndexScope
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        IndexScope.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.IndexScope";
        };

        return IndexScope;
    })();

    immessage.ModifyMsgReq = (function() {

        /**
         * Properties of a ModifyMsgReq.
         * @memberof immessage
         * @interface IModifyMsgReq
         * @property {string|null} [targetId] ModifyMsgReq targetId
         * @property {immessage.ChannelType|null} [channelType] ModifyMsgReq channelType
         * @property {string|null} [msgId] ModifyMsgReq msgId
         * @property {number|Long|null} [msgTime] ModifyMsgReq msgTime
         * @property {number|Long|null} [msgSeqNo] ModifyMsgReq msgSeqNo
         * @property {Uint8Array|null} [msgContent] ModifyMsgReq msgContent
         * @property {string|null} [msgType] ModifyMsgReq msgType
         */

        /**
         * Constructs a new ModifyMsgReq.
         * @memberof immessage
         * @classdesc Represents a ModifyMsgReq.
         * @implements IModifyMsgReq
         * @constructor
         * @param {immessage.IModifyMsgReq=} [properties] Properties to set
         */
        function ModifyMsgReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModifyMsgReq targetId.
         * @member {string} targetId
         * @memberof immessage.ModifyMsgReq
         * @instance
         */
        ModifyMsgReq.prototype.targetId = "";

        /**
         * ModifyMsgReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.ModifyMsgReq
         * @instance
         */
        ModifyMsgReq.prototype.channelType = 0;

        /**
         * ModifyMsgReq msgId.
         * @member {string} msgId
         * @memberof immessage.ModifyMsgReq
         * @instance
         */
        ModifyMsgReq.prototype.msgId = "";

        /**
         * ModifyMsgReq msgTime.
         * @member {number|Long} msgTime
         * @memberof immessage.ModifyMsgReq
         * @instance
         */
        ModifyMsgReq.prototype.msgTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ModifyMsgReq msgSeqNo.
         * @member {number|Long} msgSeqNo
         * @memberof immessage.ModifyMsgReq
         * @instance
         */
        ModifyMsgReq.prototype.msgSeqNo = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ModifyMsgReq msgContent.
         * @member {Uint8Array} msgContent
         * @memberof immessage.ModifyMsgReq
         * @instance
         */
        ModifyMsgReq.prototype.msgContent = $util.newBuffer([]);

        /**
         * ModifyMsgReq msgType.
         * @member {string} msgType
         * @memberof immessage.ModifyMsgReq
         * @instance
         */
        ModifyMsgReq.prototype.msgType = "";

        /**
         * Creates a new ModifyMsgReq instance using the specified properties.
         * @function create
         * @memberof immessage.ModifyMsgReq
         * @static
         * @param {immessage.IModifyMsgReq=} [properties] Properties to set
         * @returns {immessage.ModifyMsgReq} ModifyMsgReq instance
         */
        ModifyMsgReq.create = function create(properties) {
            return new ModifyMsgReq(properties);
        };

        /**
         * Encodes the specified ModifyMsgReq message. Does not implicitly {@link immessage.ModifyMsgReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.ModifyMsgReq
         * @static
         * @param {immessage.IModifyMsgReq} message ModifyMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyMsgReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.msgId);
            if (message.msgTime != null && Object.hasOwnProperty.call(message, "msgTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.msgTime);
            if (message.msgSeqNo != null && Object.hasOwnProperty.call(message, "msgSeqNo"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.msgSeqNo);
            if (message.msgContent != null && Object.hasOwnProperty.call(message, "msgContent"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.msgContent);
            if (message.msgType != null && Object.hasOwnProperty.call(message, "msgType"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.msgType);
            return writer;
        };

        /**
         * Encodes the specified ModifyMsgReq message, length delimited. Does not implicitly {@link immessage.ModifyMsgReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.ModifyMsgReq
         * @static
         * @param {immessage.IModifyMsgReq} message ModifyMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyMsgReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModifyMsgReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.ModifyMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.ModifyMsgReq} ModifyMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyMsgReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.ModifyMsgReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        message.msgId = reader.string();
                        break;
                    }
                case 4: {
                        message.msgTime = reader.int64();
                        break;
                    }
                case 5: {
                        message.msgSeqNo = reader.int64();
                        break;
                    }
                case 6: {
                        message.msgContent = reader.bytes();
                        break;
                    }
                case 7: {
                        message.msgType = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModifyMsgReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.ModifyMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.ModifyMsgReq} ModifyMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyMsgReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModifyMsgReq message.
         * @function verify
         * @memberof immessage.ModifyMsgReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModifyMsgReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (!$util.isInteger(message.msgTime) && !(message.msgTime && $util.isInteger(message.msgTime.low) && $util.isInteger(message.msgTime.high)))
                    return "msgTime: integer|Long expected";
            if (message.msgSeqNo != null && message.hasOwnProperty("msgSeqNo"))
                if (!$util.isInteger(message.msgSeqNo) && !(message.msgSeqNo && $util.isInteger(message.msgSeqNo.low) && $util.isInteger(message.msgSeqNo.high)))
                    return "msgSeqNo: integer|Long expected";
            if (message.msgContent != null && message.hasOwnProperty("msgContent"))
                if (!(message.msgContent && typeof message.msgContent.length === "number" || $util.isString(message.msgContent)))
                    return "msgContent: buffer expected";
            if (message.msgType != null && message.hasOwnProperty("msgType"))
                if (!$util.isString(message.msgType))
                    return "msgType: string expected";
            return null;
        };

        /**
         * Creates a ModifyMsgReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.ModifyMsgReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.ModifyMsgReq} ModifyMsgReq
         */
        ModifyMsgReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.ModifyMsgReq)
                return object;
            let message = new $root.immessage.ModifyMsgReq();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            if (object.msgTime != null)
                if ($util.Long)
                    (message.msgTime = $util.Long.fromValue(object.msgTime)).unsigned = false;
                else if (typeof object.msgTime === "string")
                    message.msgTime = parseInt(object.msgTime, 10);
                else if (typeof object.msgTime === "number")
                    message.msgTime = object.msgTime;
                else if (typeof object.msgTime === "object")
                    message.msgTime = new $util.LongBits(object.msgTime.low >>> 0, object.msgTime.high >>> 0).toNumber();
            if (object.msgSeqNo != null)
                if ($util.Long)
                    (message.msgSeqNo = $util.Long.fromValue(object.msgSeqNo)).unsigned = false;
                else if (typeof object.msgSeqNo === "string")
                    message.msgSeqNo = parseInt(object.msgSeqNo, 10);
                else if (typeof object.msgSeqNo === "number")
                    message.msgSeqNo = object.msgSeqNo;
                else if (typeof object.msgSeqNo === "object")
                    message.msgSeqNo = new $util.LongBits(object.msgSeqNo.low >>> 0, object.msgSeqNo.high >>> 0).toNumber();
            if (object.msgContent != null)
                if (typeof object.msgContent === "string")
                    $util.base64.decode(object.msgContent, message.msgContent = $util.newBuffer($util.base64.length(object.msgContent)), 0);
                else if (object.msgContent.length >= 0)
                    message.msgContent = object.msgContent;
            if (object.msgType != null)
                message.msgType = String(object.msgType);
            return message;
        };

        /**
         * Creates a plain object from a ModifyMsgReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.ModifyMsgReq
         * @static
         * @param {immessage.ModifyMsgReq} message ModifyMsgReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ModifyMsgReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                object.msgId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.msgTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msgTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.msgSeqNo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msgSeqNo = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.msgContent = "";
                else {
                    object.msgContent = [];
                    if (options.bytes !== Array)
                        object.msgContent = $util.newBuffer(object.msgContent);
                }
                object.msgType = "";
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (typeof message.msgTime === "number")
                    object.msgTime = options.longs === String ? String(message.msgTime) : message.msgTime;
                else
                    object.msgTime = options.longs === String ? $util.Long.prototype.toString.call(message.msgTime) : options.longs === Number ? new $util.LongBits(message.msgTime.low >>> 0, message.msgTime.high >>> 0).toNumber() : message.msgTime;
            if (message.msgSeqNo != null && message.hasOwnProperty("msgSeqNo"))
                if (typeof message.msgSeqNo === "number")
                    object.msgSeqNo = options.longs === String ? String(message.msgSeqNo) : message.msgSeqNo;
                else
                    object.msgSeqNo = options.longs === String ? $util.Long.prototype.toString.call(message.msgSeqNo) : options.longs === Number ? new $util.LongBits(message.msgSeqNo.low >>> 0, message.msgSeqNo.high >>> 0).toNumber() : message.msgSeqNo;
            if (message.msgContent != null && message.hasOwnProperty("msgContent"))
                object.msgContent = options.bytes === String ? $util.base64.encode(message.msgContent, 0, message.msgContent.length) : options.bytes === Array ? Array.prototype.slice.call(message.msgContent) : message.msgContent;
            if (message.msgType != null && message.hasOwnProperty("msgType"))
                object.msgType = message.msgType;
            return object;
        };

        /**
         * Converts this ModifyMsgReq to JSON.
         * @function toJSON
         * @memberof immessage.ModifyMsgReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ModifyMsgReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ModifyMsgReq
         * @function getTypeUrl
         * @memberof immessage.ModifyMsgReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ModifyMsgReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.ModifyMsgReq";
        };

        return ModifyMsgReq;
    })();

    immessage.MergeMsgReq = (function() {

        /**
         * Properties of a MergeMsgReq.
         * @memberof immessage
         * @interface IMergeMsgReq
         * @property {string|null} [parentMsgId] MergeMsgReq parentMsgId
         * @property {immessage.IMergedMsgs|null} [mergedMsgs] MergeMsgReq mergedMsgs
         */

        /**
         * Constructs a new MergeMsgReq.
         * @memberof immessage
         * @classdesc Represents a MergeMsgReq.
         * @implements IMergeMsgReq
         * @constructor
         * @param {immessage.IMergeMsgReq=} [properties] Properties to set
         */
        function MergeMsgReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MergeMsgReq parentMsgId.
         * @member {string} parentMsgId
         * @memberof immessage.MergeMsgReq
         * @instance
         */
        MergeMsgReq.prototype.parentMsgId = "";

        /**
         * MergeMsgReq mergedMsgs.
         * @member {immessage.IMergedMsgs|null|undefined} mergedMsgs
         * @memberof immessage.MergeMsgReq
         * @instance
         */
        MergeMsgReq.prototype.mergedMsgs = null;

        /**
         * Creates a new MergeMsgReq instance using the specified properties.
         * @function create
         * @memberof immessage.MergeMsgReq
         * @static
         * @param {immessage.IMergeMsgReq=} [properties] Properties to set
         * @returns {immessage.MergeMsgReq} MergeMsgReq instance
         */
        MergeMsgReq.create = function create(properties) {
            return new MergeMsgReq(properties);
        };

        /**
         * Encodes the specified MergeMsgReq message. Does not implicitly {@link immessage.MergeMsgReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.MergeMsgReq
         * @static
         * @param {immessage.IMergeMsgReq} message MergeMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MergeMsgReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.parentMsgId != null && Object.hasOwnProperty.call(message, "parentMsgId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.parentMsgId);
            if (message.mergedMsgs != null && Object.hasOwnProperty.call(message, "mergedMsgs"))
                $root.immessage.MergedMsgs.encode(message.mergedMsgs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MergeMsgReq message, length delimited. Does not implicitly {@link immessage.MergeMsgReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.MergeMsgReq
         * @static
         * @param {immessage.IMergeMsgReq} message MergeMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MergeMsgReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MergeMsgReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.MergeMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.MergeMsgReq} MergeMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MergeMsgReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.MergeMsgReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.parentMsgId = reader.string();
                        break;
                    }
                case 2: {
                        message.mergedMsgs = $root.immessage.MergedMsgs.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MergeMsgReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.MergeMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.MergeMsgReq} MergeMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MergeMsgReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MergeMsgReq message.
         * @function verify
         * @memberof immessage.MergeMsgReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MergeMsgReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.parentMsgId != null && message.hasOwnProperty("parentMsgId"))
                if (!$util.isString(message.parentMsgId))
                    return "parentMsgId: string expected";
            if (message.mergedMsgs != null && message.hasOwnProperty("mergedMsgs")) {
                let error = $root.immessage.MergedMsgs.verify(message.mergedMsgs);
                if (error)
                    return "mergedMsgs." + error;
            }
            return null;
        };

        /**
         * Creates a MergeMsgReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.MergeMsgReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.MergeMsgReq} MergeMsgReq
         */
        MergeMsgReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.MergeMsgReq)
                return object;
            let message = new $root.immessage.MergeMsgReq();
            if (object.parentMsgId != null)
                message.parentMsgId = String(object.parentMsgId);
            if (object.mergedMsgs != null) {
                if (typeof object.mergedMsgs !== "object")
                    throw TypeError(".immessage.MergeMsgReq.mergedMsgs: object expected");
                message.mergedMsgs = $root.immessage.MergedMsgs.fromObject(object.mergedMsgs);
            }
            return message;
        };

        /**
         * Creates a plain object from a MergeMsgReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.MergeMsgReq
         * @static
         * @param {immessage.MergeMsgReq} message MergeMsgReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MergeMsgReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.parentMsgId = "";
                object.mergedMsgs = null;
            }
            if (message.parentMsgId != null && message.hasOwnProperty("parentMsgId"))
                object.parentMsgId = message.parentMsgId;
            if (message.mergedMsgs != null && message.hasOwnProperty("mergedMsgs"))
                object.mergedMsgs = $root.immessage.MergedMsgs.toObject(message.mergedMsgs, options);
            return object;
        };

        /**
         * Converts this MergeMsgReq to JSON.
         * @function toJSON
         * @memberof immessage.MergeMsgReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MergeMsgReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MergeMsgReq
         * @function getTypeUrl
         * @memberof immessage.MergeMsgReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MergeMsgReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.MergeMsgReq";
        };

        return MergeMsgReq;
    })();

    immessage.QryMergedMsgsReq = (function() {

        /**
         * Properties of a QryMergedMsgsReq.
         * @memberof immessage
         * @interface IQryMergedMsgsReq
         * @property {number|Long|null} [startTime] QryMergedMsgsReq startTime
         * @property {number|null} [count] QryMergedMsgsReq count
         * @property {number|null} [order] QryMergedMsgsReq order
         */

        /**
         * Constructs a new QryMergedMsgsReq.
         * @memberof immessage
         * @classdesc Represents a QryMergedMsgsReq.
         * @implements IQryMergedMsgsReq
         * @constructor
         * @param {immessage.IQryMergedMsgsReq=} [properties] Properties to set
         */
        function QryMergedMsgsReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryMergedMsgsReq startTime.
         * @member {number|Long} startTime
         * @memberof immessage.QryMergedMsgsReq
         * @instance
         */
        QryMergedMsgsReq.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QryMergedMsgsReq count.
         * @member {number} count
         * @memberof immessage.QryMergedMsgsReq
         * @instance
         */
        QryMergedMsgsReq.prototype.count = 0;

        /**
         * QryMergedMsgsReq order.
         * @member {number} order
         * @memberof immessage.QryMergedMsgsReq
         * @instance
         */
        QryMergedMsgsReq.prototype.order = 0;

        /**
         * Creates a new QryMergedMsgsReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryMergedMsgsReq
         * @static
         * @param {immessage.IQryMergedMsgsReq=} [properties] Properties to set
         * @returns {immessage.QryMergedMsgsReq} QryMergedMsgsReq instance
         */
        QryMergedMsgsReq.create = function create(properties) {
            return new QryMergedMsgsReq(properties);
        };

        /**
         * Encodes the specified QryMergedMsgsReq message. Does not implicitly {@link immessage.QryMergedMsgsReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryMergedMsgsReq
         * @static
         * @param {immessage.IQryMergedMsgsReq} message QryMergedMsgsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryMergedMsgsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.startTime);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
            if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.order);
            return writer;
        };

        /**
         * Encodes the specified QryMergedMsgsReq message, length delimited. Does not implicitly {@link immessage.QryMergedMsgsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryMergedMsgsReq
         * @static
         * @param {immessage.IQryMergedMsgsReq} message QryMergedMsgsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryMergedMsgsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryMergedMsgsReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryMergedMsgsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryMergedMsgsReq} QryMergedMsgsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryMergedMsgsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryMergedMsgsReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.startTime = reader.int64();
                        break;
                    }
                case 2: {
                        message.count = reader.int32();
                        break;
                    }
                case 3: {
                        message.order = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryMergedMsgsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryMergedMsgsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryMergedMsgsReq} QryMergedMsgsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryMergedMsgsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryMergedMsgsReq message.
         * @function verify
         * @memberof immessage.QryMergedMsgsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryMergedMsgsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            if (message.order != null && message.hasOwnProperty("order"))
                if (!$util.isInteger(message.order))
                    return "order: integer expected";
            return null;
        };

        /**
         * Creates a QryMergedMsgsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryMergedMsgsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryMergedMsgsReq} QryMergedMsgsReq
         */
        QryMergedMsgsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryMergedMsgsReq)
                return object;
            let message = new $root.immessage.QryMergedMsgsReq();
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = false;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber();
            if (object.count != null)
                message.count = object.count | 0;
            if (object.order != null)
                message.order = object.order | 0;
            return message;
        };

        /**
         * Creates a plain object from a QryMergedMsgsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryMergedMsgsReq
         * @static
         * @param {immessage.QryMergedMsgsReq} message QryMergedMsgsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryMergedMsgsReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTime = options.longs === String ? "0" : 0;
                object.count = 0;
                object.order = 0;
            }
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (typeof message.startTime === "number")
                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                else
                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber() : message.startTime;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            if (message.order != null && message.hasOwnProperty("order"))
                object.order = message.order;
            return object;
        };

        /**
         * Converts this QryMergedMsgsReq to JSON.
         * @function toJSON
         * @memberof immessage.QryMergedMsgsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryMergedMsgsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryMergedMsgsReq
         * @function getTypeUrl
         * @memberof immessage.QryMergedMsgsReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryMergedMsgsReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryMergedMsgsReq";
        };

        return QryMergedMsgsReq;
    })();

    immessage.MsgExt = (function() {

        /**
         * Properties of a MsgExt.
         * @memberof immessage
         * @interface IMsgExt
         * @property {string|null} [targetId] MsgExt targetId
         * @property {immessage.ChannelType|null} [channelType] MsgExt channelType
         * @property {string|null} [msgId] MsgExt msgId
         * @property {immessage.IMsgExtItem|null} [ext] MsgExt ext
         */

        /**
         * Constructs a new MsgExt.
         * @memberof immessage
         * @classdesc Represents a MsgExt.
         * @implements IMsgExt
         * @constructor
         * @param {immessage.IMsgExt=} [properties] Properties to set
         */
        function MsgExt(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgExt targetId.
         * @member {string} targetId
         * @memberof immessage.MsgExt
         * @instance
         */
        MsgExt.prototype.targetId = "";

        /**
         * MsgExt channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.MsgExt
         * @instance
         */
        MsgExt.prototype.channelType = 0;

        /**
         * MsgExt msgId.
         * @member {string} msgId
         * @memberof immessage.MsgExt
         * @instance
         */
        MsgExt.prototype.msgId = "";

        /**
         * MsgExt ext.
         * @member {immessage.IMsgExtItem|null|undefined} ext
         * @memberof immessage.MsgExt
         * @instance
         */
        MsgExt.prototype.ext = null;

        /**
         * Creates a new MsgExt instance using the specified properties.
         * @function create
         * @memberof immessage.MsgExt
         * @static
         * @param {immessage.IMsgExt=} [properties] Properties to set
         * @returns {immessage.MsgExt} MsgExt instance
         */
        MsgExt.create = function create(properties) {
            return new MsgExt(properties);
        };

        /**
         * Encodes the specified MsgExt message. Does not implicitly {@link immessage.MsgExt.verify|verify} messages.
         * @function encode
         * @memberof immessage.MsgExt
         * @static
         * @param {immessage.IMsgExt} message MsgExt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgExt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.msgId);
            if (message.ext != null && Object.hasOwnProperty.call(message, "ext"))
                $root.immessage.MsgExtItem.encode(message.ext, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MsgExt message, length delimited. Does not implicitly {@link immessage.MsgExt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.MsgExt
         * @static
         * @param {immessage.IMsgExt} message MsgExt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgExt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgExt message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.MsgExt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.MsgExt} MsgExt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgExt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.MsgExt();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        message.msgId = reader.string();
                        break;
                    }
                case 4: {
                        message.ext = $root.immessage.MsgExtItem.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MsgExt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.MsgExt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.MsgExt} MsgExt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgExt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgExt message.
         * @function verify
         * @memberof immessage.MsgExt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgExt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            if (message.ext != null && message.hasOwnProperty("ext")) {
                let error = $root.immessage.MsgExtItem.verify(message.ext);
                if (error)
                    return "ext." + error;
            }
            return null;
        };

        /**
         * Creates a MsgExt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.MsgExt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.MsgExt} MsgExt
         */
        MsgExt.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.MsgExt)
                return object;
            let message = new $root.immessage.MsgExt();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            if (object.ext != null) {
                if (typeof object.ext !== "object")
                    throw TypeError(".immessage.MsgExt.ext: object expected");
                message.ext = $root.immessage.MsgExtItem.fromObject(object.ext);
            }
            return message;
        };

        /**
         * Creates a plain object from a MsgExt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.MsgExt
         * @static
         * @param {immessage.MsgExt} message MsgExt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgExt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                object.msgId = "";
                object.ext = null;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            if (message.ext != null && message.hasOwnProperty("ext"))
                object.ext = $root.immessage.MsgExtItem.toObject(message.ext, options);
            return object;
        };

        /**
         * Converts this MsgExt to JSON.
         * @function toJSON
         * @memberof immessage.MsgExt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgExt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MsgExt
         * @function getTypeUrl
         * @memberof immessage.MsgExt
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MsgExt.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.MsgExt";
        };

        return MsgExt;
    })();

    immessage.MsgExtItem = (function() {

        /**
         * Properties of a MsgExtItem.
         * @memberof immessage
         * @interface IMsgExtItem
         * @property {string|null} [key] MsgExtItem key
         * @property {string|null} [value] MsgExtItem value
         * @property {number|Long|null} [timestamp] MsgExtItem timestamp
         * @property {immessage.IUserInfo|null} [userInfo] MsgExtItem userInfo
         */

        /**
         * Constructs a new MsgExtItem.
         * @memberof immessage
         * @classdesc Represents a MsgExtItem.
         * @implements IMsgExtItem
         * @constructor
         * @param {immessage.IMsgExtItem=} [properties] Properties to set
         */
        function MsgExtItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgExtItem key.
         * @member {string} key
         * @memberof immessage.MsgExtItem
         * @instance
         */
        MsgExtItem.prototype.key = "";

        /**
         * MsgExtItem value.
         * @member {string} value
         * @memberof immessage.MsgExtItem
         * @instance
         */
        MsgExtItem.prototype.value = "";

        /**
         * MsgExtItem timestamp.
         * @member {number|Long} timestamp
         * @memberof immessage.MsgExtItem
         * @instance
         */
        MsgExtItem.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MsgExtItem userInfo.
         * @member {immessage.IUserInfo|null|undefined} userInfo
         * @memberof immessage.MsgExtItem
         * @instance
         */
        MsgExtItem.prototype.userInfo = null;

        /**
         * Creates a new MsgExtItem instance using the specified properties.
         * @function create
         * @memberof immessage.MsgExtItem
         * @static
         * @param {immessage.IMsgExtItem=} [properties] Properties to set
         * @returns {immessage.MsgExtItem} MsgExtItem instance
         */
        MsgExtItem.create = function create(properties) {
            return new MsgExtItem(properties);
        };

        /**
         * Encodes the specified MsgExtItem message. Does not implicitly {@link immessage.MsgExtItem.verify|verify} messages.
         * @function encode
         * @memberof immessage.MsgExtItem
         * @static
         * @param {immessage.IMsgExtItem} message MsgExtItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgExtItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            if (message.userInfo != null && Object.hasOwnProperty.call(message, "userInfo"))
                $root.immessage.UserInfo.encode(message.userInfo, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MsgExtItem message, length delimited. Does not implicitly {@link immessage.MsgExtItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.MsgExtItem
         * @static
         * @param {immessage.IMsgExtItem} message MsgExtItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgExtItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgExtItem message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.MsgExtItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.MsgExtItem} MsgExtItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgExtItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.MsgExtItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.key = reader.string();
                        break;
                    }
                case 2: {
                        message.value = reader.string();
                        break;
                    }
                case 3: {
                        message.timestamp = reader.int64();
                        break;
                    }
                case 4: {
                        message.userInfo = $root.immessage.UserInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MsgExtItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.MsgExtItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.MsgExtItem} MsgExtItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgExtItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgExtItem message.
         * @function verify
         * @memberof immessage.MsgExtItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgExtItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.userInfo != null && message.hasOwnProperty("userInfo")) {
                let error = $root.immessage.UserInfo.verify(message.userInfo);
                if (error)
                    return "userInfo." + error;
            }
            return null;
        };

        /**
         * Creates a MsgExtItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.MsgExtItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.MsgExtItem} MsgExtItem
         */
        MsgExtItem.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.MsgExtItem)
                return object;
            let message = new $root.immessage.MsgExtItem();
            if (object.key != null)
                message.key = String(object.key);
            if (object.value != null)
                message.value = String(object.value);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.userInfo != null) {
                if (typeof object.userInfo !== "object")
                    throw TypeError(".immessage.MsgExtItem.userInfo: object expected");
                message.userInfo = $root.immessage.UserInfo.fromObject(object.userInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a MsgExtItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.MsgExtItem
         * @static
         * @param {immessage.MsgExtItem} message MsgExtItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgExtItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.key = "";
                object.value = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.userInfo = null;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.userInfo != null && message.hasOwnProperty("userInfo"))
                object.userInfo = $root.immessage.UserInfo.toObject(message.userInfo, options);
            return object;
        };

        /**
         * Converts this MsgExtItem to JSON.
         * @function toJSON
         * @memberof immessage.MsgExtItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgExtItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MsgExtItem
         * @function getTypeUrl
         * @memberof immessage.MsgExtItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MsgExtItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.MsgExtItem";
        };

        return MsgExtItem;
    })();

    immessage.QryMsgExtReq = (function() {

        /**
         * Properties of a QryMsgExtReq.
         * @memberof immessage
         * @interface IQryMsgExtReq
         * @property {string|null} [targetId] QryMsgExtReq targetId
         * @property {immessage.ChannelType|null} [channelType] QryMsgExtReq channelType
         * @property {Array.<string>|null} [msgIds] QryMsgExtReq msgIds
         */

        /**
         * Constructs a new QryMsgExtReq.
         * @memberof immessage
         * @classdesc Represents a QryMsgExtReq.
         * @implements IQryMsgExtReq
         * @constructor
         * @param {immessage.IQryMsgExtReq=} [properties] Properties to set
         */
        function QryMsgExtReq(properties) {
            this.msgIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryMsgExtReq targetId.
         * @member {string} targetId
         * @memberof immessage.QryMsgExtReq
         * @instance
         */
        QryMsgExtReq.prototype.targetId = "";

        /**
         * QryMsgExtReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.QryMsgExtReq
         * @instance
         */
        QryMsgExtReq.prototype.channelType = 0;

        /**
         * QryMsgExtReq msgIds.
         * @member {Array.<string>} msgIds
         * @memberof immessage.QryMsgExtReq
         * @instance
         */
        QryMsgExtReq.prototype.msgIds = $util.emptyArray;

        /**
         * Creates a new QryMsgExtReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryMsgExtReq
         * @static
         * @param {immessage.IQryMsgExtReq=} [properties] Properties to set
         * @returns {immessage.QryMsgExtReq} QryMsgExtReq instance
         */
        QryMsgExtReq.create = function create(properties) {
            return new QryMsgExtReq(properties);
        };

        /**
         * Encodes the specified QryMsgExtReq message. Does not implicitly {@link immessage.QryMsgExtReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryMsgExtReq
         * @static
         * @param {immessage.IQryMsgExtReq} message QryMsgExtReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryMsgExtReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.msgIds != null && message.msgIds.length)
                for (let i = 0; i < message.msgIds.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.msgIds[i]);
            return writer;
        };

        /**
         * Encodes the specified QryMsgExtReq message, length delimited. Does not implicitly {@link immessage.QryMsgExtReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryMsgExtReq
         * @static
         * @param {immessage.IQryMsgExtReq} message QryMsgExtReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryMsgExtReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryMsgExtReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryMsgExtReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryMsgExtReq} QryMsgExtReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryMsgExtReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryMsgExtReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.msgIds && message.msgIds.length))
                            message.msgIds = [];
                        message.msgIds.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryMsgExtReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryMsgExtReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryMsgExtReq} QryMsgExtReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryMsgExtReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryMsgExtReq message.
         * @function verify
         * @memberof immessage.QryMsgExtReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryMsgExtReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.msgIds != null && message.hasOwnProperty("msgIds")) {
                if (!Array.isArray(message.msgIds))
                    return "msgIds: array expected";
                for (let i = 0; i < message.msgIds.length; ++i)
                    if (!$util.isString(message.msgIds[i]))
                        return "msgIds: string[] expected";
            }
            return null;
        };

        /**
         * Creates a QryMsgExtReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryMsgExtReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryMsgExtReq} QryMsgExtReq
         */
        QryMsgExtReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryMsgExtReq)
                return object;
            let message = new $root.immessage.QryMsgExtReq();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.msgIds) {
                if (!Array.isArray(object.msgIds))
                    throw TypeError(".immessage.QryMsgExtReq.msgIds: array expected");
                message.msgIds = [];
                for (let i = 0; i < object.msgIds.length; ++i)
                    message.msgIds[i] = String(object.msgIds[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a QryMsgExtReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryMsgExtReq
         * @static
         * @param {immessage.QryMsgExtReq} message QryMsgExtReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryMsgExtReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.msgIds = [];
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.msgIds && message.msgIds.length) {
                object.msgIds = [];
                for (let j = 0; j < message.msgIds.length; ++j)
                    object.msgIds[j] = message.msgIds[j];
            }
            return object;
        };

        /**
         * Converts this QryMsgExtReq to JSON.
         * @function toJSON
         * @memberof immessage.QryMsgExtReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryMsgExtReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryMsgExtReq
         * @function getTypeUrl
         * @memberof immessage.QryMsgExtReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryMsgExtReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryMsgExtReq";
        };

        return QryMsgExtReq;
    })();

    immessage.MsgExtItemsList = (function() {

        /**
         * Properties of a MsgExtItemsList.
         * @memberof immessage
         * @interface IMsgExtItemsList
         * @property {Array.<immessage.IMsgExtItems>|null} [items] MsgExtItemsList items
         */

        /**
         * Constructs a new MsgExtItemsList.
         * @memberof immessage
         * @classdesc Represents a MsgExtItemsList.
         * @implements IMsgExtItemsList
         * @constructor
         * @param {immessage.IMsgExtItemsList=} [properties] Properties to set
         */
        function MsgExtItemsList(properties) {
            this.items = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgExtItemsList items.
         * @member {Array.<immessage.IMsgExtItems>} items
         * @memberof immessage.MsgExtItemsList
         * @instance
         */
        MsgExtItemsList.prototype.items = $util.emptyArray;

        /**
         * Creates a new MsgExtItemsList instance using the specified properties.
         * @function create
         * @memberof immessage.MsgExtItemsList
         * @static
         * @param {immessage.IMsgExtItemsList=} [properties] Properties to set
         * @returns {immessage.MsgExtItemsList} MsgExtItemsList instance
         */
        MsgExtItemsList.create = function create(properties) {
            return new MsgExtItemsList(properties);
        };

        /**
         * Encodes the specified MsgExtItemsList message. Does not implicitly {@link immessage.MsgExtItemsList.verify|verify} messages.
         * @function encode
         * @memberof immessage.MsgExtItemsList
         * @static
         * @param {immessage.IMsgExtItemsList} message MsgExtItemsList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgExtItemsList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (let i = 0; i < message.items.length; ++i)
                    $root.immessage.MsgExtItems.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MsgExtItemsList message, length delimited. Does not implicitly {@link immessage.MsgExtItemsList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.MsgExtItemsList
         * @static
         * @param {immessage.IMsgExtItemsList} message MsgExtItemsList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgExtItemsList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgExtItemsList message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.MsgExtItemsList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.MsgExtItemsList} MsgExtItemsList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgExtItemsList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.MsgExtItemsList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.immessage.MsgExtItems.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MsgExtItemsList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.MsgExtItemsList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.MsgExtItemsList} MsgExtItemsList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgExtItemsList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgExtItemsList message.
         * @function verify
         * @memberof immessage.MsgExtItemsList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgExtItemsList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (let i = 0; i < message.items.length; ++i) {
                    let error = $root.immessage.MsgExtItems.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MsgExtItemsList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.MsgExtItemsList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.MsgExtItemsList} MsgExtItemsList
         */
        MsgExtItemsList.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.MsgExtItemsList)
                return object;
            let message = new $root.immessage.MsgExtItemsList();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".immessage.MsgExtItemsList.items: array expected");
                message.items = [];
                for (let i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".immessage.MsgExtItemsList.items: object expected");
                    message.items[i] = $root.immessage.MsgExtItems.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MsgExtItemsList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.MsgExtItemsList
         * @static
         * @param {immessage.MsgExtItemsList} message MsgExtItemsList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgExtItemsList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (message.items && message.items.length) {
                object.items = [];
                for (let j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.immessage.MsgExtItems.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this MsgExtItemsList to JSON.
         * @function toJSON
         * @memberof immessage.MsgExtItemsList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgExtItemsList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MsgExtItemsList
         * @function getTypeUrl
         * @memberof immessage.MsgExtItemsList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MsgExtItemsList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.MsgExtItemsList";
        };

        return MsgExtItemsList;
    })();

    immessage.MsgExtItems = (function() {

        /**
         * Properties of a MsgExtItems.
         * @memberof immessage
         * @interface IMsgExtItems
         * @property {string|null} [msgId] MsgExtItems msgId
         * @property {Array.<immessage.IMsgExtItem>|null} [exts] MsgExtItems exts
         */

        /**
         * Constructs a new MsgExtItems.
         * @memberof immessage
         * @classdesc Represents a MsgExtItems.
         * @implements IMsgExtItems
         * @constructor
         * @param {immessage.IMsgExtItems=} [properties] Properties to set
         */
        function MsgExtItems(properties) {
            this.exts = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgExtItems msgId.
         * @member {string} msgId
         * @memberof immessage.MsgExtItems
         * @instance
         */
        MsgExtItems.prototype.msgId = "";

        /**
         * MsgExtItems exts.
         * @member {Array.<immessage.IMsgExtItem>} exts
         * @memberof immessage.MsgExtItems
         * @instance
         */
        MsgExtItems.prototype.exts = $util.emptyArray;

        /**
         * Creates a new MsgExtItems instance using the specified properties.
         * @function create
         * @memberof immessage.MsgExtItems
         * @static
         * @param {immessage.IMsgExtItems=} [properties] Properties to set
         * @returns {immessage.MsgExtItems} MsgExtItems instance
         */
        MsgExtItems.create = function create(properties) {
            return new MsgExtItems(properties);
        };

        /**
         * Encodes the specified MsgExtItems message. Does not implicitly {@link immessage.MsgExtItems.verify|verify} messages.
         * @function encode
         * @memberof immessage.MsgExtItems
         * @static
         * @param {immessage.IMsgExtItems} message MsgExtItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgExtItems.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.msgId);
            if (message.exts != null && message.exts.length)
                for (let i = 0; i < message.exts.length; ++i)
                    $root.immessage.MsgExtItem.encode(message.exts[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MsgExtItems message, length delimited. Does not implicitly {@link immessage.MsgExtItems.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.MsgExtItems
         * @static
         * @param {immessage.IMsgExtItems} message MsgExtItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgExtItems.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgExtItems message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.MsgExtItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.MsgExtItems} MsgExtItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgExtItems.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.MsgExtItems();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.msgId = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.exts && message.exts.length))
                            message.exts = [];
                        message.exts.push($root.immessage.MsgExtItem.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MsgExtItems message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.MsgExtItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.MsgExtItems} MsgExtItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgExtItems.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgExtItems message.
         * @function verify
         * @memberof immessage.MsgExtItems
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgExtItems.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            if (message.exts != null && message.hasOwnProperty("exts")) {
                if (!Array.isArray(message.exts))
                    return "exts: array expected";
                for (let i = 0; i < message.exts.length; ++i) {
                    let error = $root.immessage.MsgExtItem.verify(message.exts[i]);
                    if (error)
                        return "exts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MsgExtItems message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.MsgExtItems
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.MsgExtItems} MsgExtItems
         */
        MsgExtItems.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.MsgExtItems)
                return object;
            let message = new $root.immessage.MsgExtItems();
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            if (object.exts) {
                if (!Array.isArray(object.exts))
                    throw TypeError(".immessage.MsgExtItems.exts: array expected");
                message.exts = [];
                for (let i = 0; i < object.exts.length; ++i) {
                    if (typeof object.exts[i] !== "object")
                        throw TypeError(".immessage.MsgExtItems.exts: object expected");
                    message.exts[i] = $root.immessage.MsgExtItem.fromObject(object.exts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MsgExtItems message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.MsgExtItems
         * @static
         * @param {immessage.MsgExtItems} message MsgExtItems
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgExtItems.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.exts = [];
            if (options.defaults)
                object.msgId = "";
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            if (message.exts && message.exts.length) {
                object.exts = [];
                for (let j = 0; j < message.exts.length; ++j)
                    object.exts[j] = $root.immessage.MsgExtItem.toObject(message.exts[j], options);
            }
            return object;
        };

        /**
         * Converts this MsgExtItems to JSON.
         * @function toJSON
         * @memberof immessage.MsgExtItems
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgExtItems.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MsgExtItems
         * @function getTypeUrl
         * @memberof immessage.MsgExtItems
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MsgExtItems.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.MsgExtItems";
        };

        return MsgExtItems;
    })();

    immessage.FavoriteMsgIds = (function() {

        /**
         * Properties of a FavoriteMsgIds.
         * @memberof immessage
         * @interface IFavoriteMsgIds
         * @property {Array.<immessage.IFavoriteMsgIdItem>|null} [items] FavoriteMsgIds items
         */

        /**
         * Constructs a new FavoriteMsgIds.
         * @memberof immessage
         * @classdesc Represents a FavoriteMsgIds.
         * @implements IFavoriteMsgIds
         * @constructor
         * @param {immessage.IFavoriteMsgIds=} [properties] Properties to set
         */
        function FavoriteMsgIds(properties) {
            this.items = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FavoriteMsgIds items.
         * @member {Array.<immessage.IFavoriteMsgIdItem>} items
         * @memberof immessage.FavoriteMsgIds
         * @instance
         */
        FavoriteMsgIds.prototype.items = $util.emptyArray;

        /**
         * Creates a new FavoriteMsgIds instance using the specified properties.
         * @function create
         * @memberof immessage.FavoriteMsgIds
         * @static
         * @param {immessage.IFavoriteMsgIds=} [properties] Properties to set
         * @returns {immessage.FavoriteMsgIds} FavoriteMsgIds instance
         */
        FavoriteMsgIds.create = function create(properties) {
            return new FavoriteMsgIds(properties);
        };

        /**
         * Encodes the specified FavoriteMsgIds message. Does not implicitly {@link immessage.FavoriteMsgIds.verify|verify} messages.
         * @function encode
         * @memberof immessage.FavoriteMsgIds
         * @static
         * @param {immessage.IFavoriteMsgIds} message FavoriteMsgIds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FavoriteMsgIds.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (let i = 0; i < message.items.length; ++i)
                    $root.immessage.FavoriteMsgIdItem.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FavoriteMsgIds message, length delimited. Does not implicitly {@link immessage.FavoriteMsgIds.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.FavoriteMsgIds
         * @static
         * @param {immessage.IFavoriteMsgIds} message FavoriteMsgIds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FavoriteMsgIds.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FavoriteMsgIds message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.FavoriteMsgIds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.FavoriteMsgIds} FavoriteMsgIds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FavoriteMsgIds.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.FavoriteMsgIds();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.immessage.FavoriteMsgIdItem.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FavoriteMsgIds message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.FavoriteMsgIds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.FavoriteMsgIds} FavoriteMsgIds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FavoriteMsgIds.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FavoriteMsgIds message.
         * @function verify
         * @memberof immessage.FavoriteMsgIds
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FavoriteMsgIds.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (let i = 0; i < message.items.length; ++i) {
                    let error = $root.immessage.FavoriteMsgIdItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FavoriteMsgIds message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.FavoriteMsgIds
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.FavoriteMsgIds} FavoriteMsgIds
         */
        FavoriteMsgIds.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.FavoriteMsgIds)
                return object;
            let message = new $root.immessage.FavoriteMsgIds();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".immessage.FavoriteMsgIds.items: array expected");
                message.items = [];
                for (let i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".immessage.FavoriteMsgIds.items: object expected");
                    message.items[i] = $root.immessage.FavoriteMsgIdItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a FavoriteMsgIds message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.FavoriteMsgIds
         * @static
         * @param {immessage.FavoriteMsgIds} message FavoriteMsgIds
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FavoriteMsgIds.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (message.items && message.items.length) {
                object.items = [];
                for (let j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.immessage.FavoriteMsgIdItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this FavoriteMsgIds to JSON.
         * @function toJSON
         * @memberof immessage.FavoriteMsgIds
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FavoriteMsgIds.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FavoriteMsgIds
         * @function getTypeUrl
         * @memberof immessage.FavoriteMsgIds
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FavoriteMsgIds.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.FavoriteMsgIds";
        };

        return FavoriteMsgIds;
    })();

    immessage.FavoriteMsgIdItem = (function() {

        /**
         * Properties of a FavoriteMsgIdItem.
         * @memberof immessage
         * @interface IFavoriteMsgIdItem
         * @property {string|null} [senderId] FavoriteMsgIdItem senderId
         * @property {string|null} [receiverId] FavoriteMsgIdItem receiverId
         * @property {immessage.ChannelType|null} [channelType] FavoriteMsgIdItem channelType
         * @property {string|null} [msgId] FavoriteMsgIdItem msgId
         */

        /**
         * Constructs a new FavoriteMsgIdItem.
         * @memberof immessage
         * @classdesc Represents a FavoriteMsgIdItem.
         * @implements IFavoriteMsgIdItem
         * @constructor
         * @param {immessage.IFavoriteMsgIdItem=} [properties] Properties to set
         */
        function FavoriteMsgIdItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FavoriteMsgIdItem senderId.
         * @member {string} senderId
         * @memberof immessage.FavoriteMsgIdItem
         * @instance
         */
        FavoriteMsgIdItem.prototype.senderId = "";

        /**
         * FavoriteMsgIdItem receiverId.
         * @member {string} receiverId
         * @memberof immessage.FavoriteMsgIdItem
         * @instance
         */
        FavoriteMsgIdItem.prototype.receiverId = "";

        /**
         * FavoriteMsgIdItem channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.FavoriteMsgIdItem
         * @instance
         */
        FavoriteMsgIdItem.prototype.channelType = 0;

        /**
         * FavoriteMsgIdItem msgId.
         * @member {string} msgId
         * @memberof immessage.FavoriteMsgIdItem
         * @instance
         */
        FavoriteMsgIdItem.prototype.msgId = "";

        /**
         * Creates a new FavoriteMsgIdItem instance using the specified properties.
         * @function create
         * @memberof immessage.FavoriteMsgIdItem
         * @static
         * @param {immessage.IFavoriteMsgIdItem=} [properties] Properties to set
         * @returns {immessage.FavoriteMsgIdItem} FavoriteMsgIdItem instance
         */
        FavoriteMsgIdItem.create = function create(properties) {
            return new FavoriteMsgIdItem(properties);
        };

        /**
         * Encodes the specified FavoriteMsgIdItem message. Does not implicitly {@link immessage.FavoriteMsgIdItem.verify|verify} messages.
         * @function encode
         * @memberof immessage.FavoriteMsgIdItem
         * @static
         * @param {immessage.IFavoriteMsgIdItem} message FavoriteMsgIdItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FavoriteMsgIdItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.senderId != null && Object.hasOwnProperty.call(message, "senderId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.senderId);
            if (message.receiverId != null && Object.hasOwnProperty.call(message, "receiverId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.receiverId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.channelType);
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.msgId);
            return writer;
        };

        /**
         * Encodes the specified FavoriteMsgIdItem message, length delimited. Does not implicitly {@link immessage.FavoriteMsgIdItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.FavoriteMsgIdItem
         * @static
         * @param {immessage.IFavoriteMsgIdItem} message FavoriteMsgIdItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FavoriteMsgIdItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FavoriteMsgIdItem message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.FavoriteMsgIdItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.FavoriteMsgIdItem} FavoriteMsgIdItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FavoriteMsgIdItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.FavoriteMsgIdItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.senderId = reader.string();
                        break;
                    }
                case 2: {
                        message.receiverId = reader.string();
                        break;
                    }
                case 3: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 4: {
                        message.msgId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FavoriteMsgIdItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.FavoriteMsgIdItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.FavoriteMsgIdItem} FavoriteMsgIdItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FavoriteMsgIdItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FavoriteMsgIdItem message.
         * @function verify
         * @memberof immessage.FavoriteMsgIdItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FavoriteMsgIdItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.senderId != null && message.hasOwnProperty("senderId"))
                if (!$util.isString(message.senderId))
                    return "senderId: string expected";
            if (message.receiverId != null && message.hasOwnProperty("receiverId"))
                if (!$util.isString(message.receiverId))
                    return "receiverId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            return null;
        };

        /**
         * Creates a FavoriteMsgIdItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.FavoriteMsgIdItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.FavoriteMsgIdItem} FavoriteMsgIdItem
         */
        FavoriteMsgIdItem.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.FavoriteMsgIdItem)
                return object;
            let message = new $root.immessage.FavoriteMsgIdItem();
            if (object.senderId != null)
                message.senderId = String(object.senderId);
            if (object.receiverId != null)
                message.receiverId = String(object.receiverId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            return message;
        };

        /**
         * Creates a plain object from a FavoriteMsgIdItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.FavoriteMsgIdItem
         * @static
         * @param {immessage.FavoriteMsgIdItem} message FavoriteMsgIdItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FavoriteMsgIdItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.senderId = "";
                object.receiverId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                object.msgId = "";
            }
            if (message.senderId != null && message.hasOwnProperty("senderId"))
                object.senderId = message.senderId;
            if (message.receiverId != null && message.hasOwnProperty("receiverId"))
                object.receiverId = message.receiverId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            return object;
        };

        /**
         * Converts this FavoriteMsgIdItem to JSON.
         * @function toJSON
         * @memberof immessage.FavoriteMsgIdItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FavoriteMsgIdItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FavoriteMsgIdItem
         * @function getTypeUrl
         * @memberof immessage.FavoriteMsgIdItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FavoriteMsgIdItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.FavoriteMsgIdItem";
        };

        return FavoriteMsgIdItem;
    })();

    immessage.QryFavoriteMsgsReq = (function() {

        /**
         * Properties of a QryFavoriteMsgsReq.
         * @memberof immessage
         * @interface IQryFavoriteMsgsReq
         * @property {number|Long|null} [limit] QryFavoriteMsgsReq limit
         * @property {string|null} [offset] QryFavoriteMsgsReq offset
         */

        /**
         * Constructs a new QryFavoriteMsgsReq.
         * @memberof immessage
         * @classdesc Represents a QryFavoriteMsgsReq.
         * @implements IQryFavoriteMsgsReq
         * @constructor
         * @param {immessage.IQryFavoriteMsgsReq=} [properties] Properties to set
         */
        function QryFavoriteMsgsReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryFavoriteMsgsReq limit.
         * @member {number|Long} limit
         * @memberof immessage.QryFavoriteMsgsReq
         * @instance
         */
        QryFavoriteMsgsReq.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QryFavoriteMsgsReq offset.
         * @member {string} offset
         * @memberof immessage.QryFavoriteMsgsReq
         * @instance
         */
        QryFavoriteMsgsReq.prototype.offset = "";

        /**
         * Creates a new QryFavoriteMsgsReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryFavoriteMsgsReq
         * @static
         * @param {immessage.IQryFavoriteMsgsReq=} [properties] Properties to set
         * @returns {immessage.QryFavoriteMsgsReq} QryFavoriteMsgsReq instance
         */
        QryFavoriteMsgsReq.create = function create(properties) {
            return new QryFavoriteMsgsReq(properties);
        };

        /**
         * Encodes the specified QryFavoriteMsgsReq message. Does not implicitly {@link immessage.QryFavoriteMsgsReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryFavoriteMsgsReq
         * @static
         * @param {immessage.IQryFavoriteMsgsReq} message QryFavoriteMsgsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryFavoriteMsgsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.limit);
            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.offset);
            return writer;
        };

        /**
         * Encodes the specified QryFavoriteMsgsReq message, length delimited. Does not implicitly {@link immessage.QryFavoriteMsgsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryFavoriteMsgsReq
         * @static
         * @param {immessage.IQryFavoriteMsgsReq} message QryFavoriteMsgsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryFavoriteMsgsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryFavoriteMsgsReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryFavoriteMsgsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryFavoriteMsgsReq} QryFavoriteMsgsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryFavoriteMsgsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryFavoriteMsgsReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.limit = reader.int64();
                        break;
                    }
                case 2: {
                        message.offset = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryFavoriteMsgsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryFavoriteMsgsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryFavoriteMsgsReq} QryFavoriteMsgsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryFavoriteMsgsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryFavoriteMsgsReq message.
         * @function verify
         * @memberof immessage.QryFavoriteMsgsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryFavoriteMsgsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                    return "limit: integer|Long expected";
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isString(message.offset))
                    return "offset: string expected";
            return null;
        };

        /**
         * Creates a QryFavoriteMsgsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryFavoriteMsgsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryFavoriteMsgsReq} QryFavoriteMsgsReq
         */
        QryFavoriteMsgsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryFavoriteMsgsReq)
                return object;
            let message = new $root.immessage.QryFavoriteMsgsReq();
            if (object.limit != null)
                if ($util.Long)
                    (message.limit = $util.Long.fromValue(object.limit)).unsigned = false;
                else if (typeof object.limit === "string")
                    message.limit = parseInt(object.limit, 10);
                else if (typeof object.limit === "number")
                    message.limit = object.limit;
                else if (typeof object.limit === "object")
                    message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber();
            if (object.offset != null)
                message.offset = String(object.offset);
            return message;
        };

        /**
         * Creates a plain object from a QryFavoriteMsgsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryFavoriteMsgsReq
         * @static
         * @param {immessage.QryFavoriteMsgsReq} message QryFavoriteMsgsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryFavoriteMsgsReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.limit = options.longs === String ? "0" : 0;
                object.offset = "";
            }
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (typeof message.limit === "number")
                    object.limit = options.longs === String ? String(message.limit) : message.limit;
                else
                    object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber() : message.limit;
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            return object;
        };

        /**
         * Converts this QryFavoriteMsgsReq to JSON.
         * @function toJSON
         * @memberof immessage.QryFavoriteMsgsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryFavoriteMsgsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryFavoriteMsgsReq
         * @function getTypeUrl
         * @memberof immessage.QryFavoriteMsgsReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryFavoriteMsgsReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryFavoriteMsgsReq";
        };

        return QryFavoriteMsgsReq;
    })();

    immessage.FavoriteMsg = (function() {

        /**
         * Properties of a FavoriteMsg.
         * @memberof immessage
         * @interface IFavoriteMsg
         * @property {immessage.IDownMsg|null} [msg] FavoriteMsg msg
         * @property {number|Long|null} [createdTime] FavoriteMsg createdTime
         */

        /**
         * Constructs a new FavoriteMsg.
         * @memberof immessage
         * @classdesc Represents a FavoriteMsg.
         * @implements IFavoriteMsg
         * @constructor
         * @param {immessage.IFavoriteMsg=} [properties] Properties to set
         */
        function FavoriteMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FavoriteMsg msg.
         * @member {immessage.IDownMsg|null|undefined} msg
         * @memberof immessage.FavoriteMsg
         * @instance
         */
        FavoriteMsg.prototype.msg = null;

        /**
         * FavoriteMsg createdTime.
         * @member {number|Long} createdTime
         * @memberof immessage.FavoriteMsg
         * @instance
         */
        FavoriteMsg.prototype.createdTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new FavoriteMsg instance using the specified properties.
         * @function create
         * @memberof immessage.FavoriteMsg
         * @static
         * @param {immessage.IFavoriteMsg=} [properties] Properties to set
         * @returns {immessage.FavoriteMsg} FavoriteMsg instance
         */
        FavoriteMsg.create = function create(properties) {
            return new FavoriteMsg(properties);
        };

        /**
         * Encodes the specified FavoriteMsg message. Does not implicitly {@link immessage.FavoriteMsg.verify|verify} messages.
         * @function encode
         * @memberof immessage.FavoriteMsg
         * @static
         * @param {immessage.IFavoriteMsg} message FavoriteMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FavoriteMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                $root.immessage.DownMsg.encode(message.msg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.createdTime != null && Object.hasOwnProperty.call(message, "createdTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.createdTime);
            return writer;
        };

        /**
         * Encodes the specified FavoriteMsg message, length delimited. Does not implicitly {@link immessage.FavoriteMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.FavoriteMsg
         * @static
         * @param {immessage.IFavoriteMsg} message FavoriteMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FavoriteMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FavoriteMsg message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.FavoriteMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.FavoriteMsg} FavoriteMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FavoriteMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.FavoriteMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.msg = $root.immessage.DownMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.createdTime = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FavoriteMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.FavoriteMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.FavoriteMsg} FavoriteMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FavoriteMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FavoriteMsg message.
         * @function verify
         * @memberof immessage.FavoriteMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FavoriteMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msg != null && message.hasOwnProperty("msg")) {
                let error = $root.immessage.DownMsg.verify(message.msg);
                if (error)
                    return "msg." + error;
            }
            if (message.createdTime != null && message.hasOwnProperty("createdTime"))
                if (!$util.isInteger(message.createdTime) && !(message.createdTime && $util.isInteger(message.createdTime.low) && $util.isInteger(message.createdTime.high)))
                    return "createdTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a FavoriteMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.FavoriteMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.FavoriteMsg} FavoriteMsg
         */
        FavoriteMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.FavoriteMsg)
                return object;
            let message = new $root.immessage.FavoriteMsg();
            if (object.msg != null) {
                if (typeof object.msg !== "object")
                    throw TypeError(".immessage.FavoriteMsg.msg: object expected");
                message.msg = $root.immessage.DownMsg.fromObject(object.msg);
            }
            if (object.createdTime != null)
                if ($util.Long)
                    (message.createdTime = $util.Long.fromValue(object.createdTime)).unsigned = false;
                else if (typeof object.createdTime === "string")
                    message.createdTime = parseInt(object.createdTime, 10);
                else if (typeof object.createdTime === "number")
                    message.createdTime = object.createdTime;
                else if (typeof object.createdTime === "object")
                    message.createdTime = new $util.LongBits(object.createdTime.low >>> 0, object.createdTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a FavoriteMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.FavoriteMsg
         * @static
         * @param {immessage.FavoriteMsg} message FavoriteMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FavoriteMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.msg = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.createdTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createdTime = options.longs === String ? "0" : 0;
            }
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = $root.immessage.DownMsg.toObject(message.msg, options);
            if (message.createdTime != null && message.hasOwnProperty("createdTime"))
                if (typeof message.createdTime === "number")
                    object.createdTime = options.longs === String ? String(message.createdTime) : message.createdTime;
                else
                    object.createdTime = options.longs === String ? $util.Long.prototype.toString.call(message.createdTime) : options.longs === Number ? new $util.LongBits(message.createdTime.low >>> 0, message.createdTime.high >>> 0).toNumber() : message.createdTime;
            return object;
        };

        /**
         * Converts this FavoriteMsg to JSON.
         * @function toJSON
         * @memberof immessage.FavoriteMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FavoriteMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FavoriteMsg
         * @function getTypeUrl
         * @memberof immessage.FavoriteMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FavoriteMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.FavoriteMsg";
        };

        return FavoriteMsg;
    })();

    immessage.FavoriteMsgs = (function() {

        /**
         * Properties of a FavoriteMsgs.
         * @memberof immessage
         * @interface IFavoriteMsgs
         * @property {Array.<immessage.IFavoriteMsg>|null} [items] FavoriteMsgs items
         * @property {string|null} [offset] FavoriteMsgs offset
         */

        /**
         * Constructs a new FavoriteMsgs.
         * @memberof immessage
         * @classdesc Represents a FavoriteMsgs.
         * @implements IFavoriteMsgs
         * @constructor
         * @param {immessage.IFavoriteMsgs=} [properties] Properties to set
         */
        function FavoriteMsgs(properties) {
            this.items = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FavoriteMsgs items.
         * @member {Array.<immessage.IFavoriteMsg>} items
         * @memberof immessage.FavoriteMsgs
         * @instance
         */
        FavoriteMsgs.prototype.items = $util.emptyArray;

        /**
         * FavoriteMsgs offset.
         * @member {string} offset
         * @memberof immessage.FavoriteMsgs
         * @instance
         */
        FavoriteMsgs.prototype.offset = "";

        /**
         * Creates a new FavoriteMsgs instance using the specified properties.
         * @function create
         * @memberof immessage.FavoriteMsgs
         * @static
         * @param {immessage.IFavoriteMsgs=} [properties] Properties to set
         * @returns {immessage.FavoriteMsgs} FavoriteMsgs instance
         */
        FavoriteMsgs.create = function create(properties) {
            return new FavoriteMsgs(properties);
        };

        /**
         * Encodes the specified FavoriteMsgs message. Does not implicitly {@link immessage.FavoriteMsgs.verify|verify} messages.
         * @function encode
         * @memberof immessage.FavoriteMsgs
         * @static
         * @param {immessage.IFavoriteMsgs} message FavoriteMsgs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FavoriteMsgs.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (let i = 0; i < message.items.length; ++i)
                    $root.immessage.FavoriteMsg.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.offset);
            return writer;
        };

        /**
         * Encodes the specified FavoriteMsgs message, length delimited. Does not implicitly {@link immessage.FavoriteMsgs.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.FavoriteMsgs
         * @static
         * @param {immessage.IFavoriteMsgs} message FavoriteMsgs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FavoriteMsgs.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FavoriteMsgs message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.FavoriteMsgs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.FavoriteMsgs} FavoriteMsgs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FavoriteMsgs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.FavoriteMsgs();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.immessage.FavoriteMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.offset = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FavoriteMsgs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.FavoriteMsgs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.FavoriteMsgs} FavoriteMsgs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FavoriteMsgs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FavoriteMsgs message.
         * @function verify
         * @memberof immessage.FavoriteMsgs
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FavoriteMsgs.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (let i = 0; i < message.items.length; ++i) {
                    let error = $root.immessage.FavoriteMsg.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isString(message.offset))
                    return "offset: string expected";
            return null;
        };

        /**
         * Creates a FavoriteMsgs message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.FavoriteMsgs
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.FavoriteMsgs} FavoriteMsgs
         */
        FavoriteMsgs.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.FavoriteMsgs)
                return object;
            let message = new $root.immessage.FavoriteMsgs();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".immessage.FavoriteMsgs.items: array expected");
                message.items = [];
                for (let i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".immessage.FavoriteMsgs.items: object expected");
                    message.items[i] = $root.immessage.FavoriteMsg.fromObject(object.items[i]);
                }
            }
            if (object.offset != null)
                message.offset = String(object.offset);
            return message;
        };

        /**
         * Creates a plain object from a FavoriteMsgs message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.FavoriteMsgs
         * @static
         * @param {immessage.FavoriteMsgs} message FavoriteMsgs
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FavoriteMsgs.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                object.offset = "";
            if (message.items && message.items.length) {
                object.items = [];
                for (let j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.immessage.FavoriteMsg.toObject(message.items[j], options);
            }
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            return object;
        };

        /**
         * Converts this FavoriteMsgs to JSON.
         * @function toJSON
         * @memberof immessage.FavoriteMsgs
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FavoriteMsgs.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FavoriteMsgs
         * @function getTypeUrl
         * @memberof immessage.FavoriteMsgs
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FavoriteMsgs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.FavoriteMsgs";
        };

        return FavoriteMsgs;
    })();

    immessage.TopMsgReq = (function() {

        /**
         * Properties of a TopMsgReq.
         * @memberof immessage
         * @interface ITopMsgReq
         * @property {string|null} [targetId] TopMsgReq targetId
         * @property {immessage.ChannelType|null} [channelType] TopMsgReq channelType
         * @property {string|null} [msgId] TopMsgReq msgId
         */

        /**
         * Constructs a new TopMsgReq.
         * @memberof immessage
         * @classdesc Represents a TopMsgReq.
         * @implements ITopMsgReq
         * @constructor
         * @param {immessage.ITopMsgReq=} [properties] Properties to set
         */
        function TopMsgReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TopMsgReq targetId.
         * @member {string} targetId
         * @memberof immessage.TopMsgReq
         * @instance
         */
        TopMsgReq.prototype.targetId = "";

        /**
         * TopMsgReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.TopMsgReq
         * @instance
         */
        TopMsgReq.prototype.channelType = 0;

        /**
         * TopMsgReq msgId.
         * @member {string} msgId
         * @memberof immessage.TopMsgReq
         * @instance
         */
        TopMsgReq.prototype.msgId = "";

        /**
         * Creates a new TopMsgReq instance using the specified properties.
         * @function create
         * @memberof immessage.TopMsgReq
         * @static
         * @param {immessage.ITopMsgReq=} [properties] Properties to set
         * @returns {immessage.TopMsgReq} TopMsgReq instance
         */
        TopMsgReq.create = function create(properties) {
            return new TopMsgReq(properties);
        };

        /**
         * Encodes the specified TopMsgReq message. Does not implicitly {@link immessage.TopMsgReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.TopMsgReq
         * @static
         * @param {immessage.ITopMsgReq} message TopMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TopMsgReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.msgId);
            return writer;
        };

        /**
         * Encodes the specified TopMsgReq message, length delimited. Does not implicitly {@link immessage.TopMsgReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.TopMsgReq
         * @static
         * @param {immessage.ITopMsgReq} message TopMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TopMsgReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TopMsgReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.TopMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.TopMsgReq} TopMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TopMsgReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.TopMsgReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        message.msgId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TopMsgReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.TopMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.TopMsgReq} TopMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TopMsgReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TopMsgReq message.
         * @function verify
         * @memberof immessage.TopMsgReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TopMsgReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            return null;
        };

        /**
         * Creates a TopMsgReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.TopMsgReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.TopMsgReq} TopMsgReq
         */
        TopMsgReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.TopMsgReq)
                return object;
            let message = new $root.immessage.TopMsgReq();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            return message;
        };

        /**
         * Creates a plain object from a TopMsgReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.TopMsgReq
         * @static
         * @param {immessage.TopMsgReq} message TopMsgReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TopMsgReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                object.msgId = "";
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            return object;
        };

        /**
         * Converts this TopMsgReq to JSON.
         * @function toJSON
         * @memberof immessage.TopMsgReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TopMsgReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TopMsgReq
         * @function getTypeUrl
         * @memberof immessage.TopMsgReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TopMsgReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.TopMsgReq";
        };

        return TopMsgReq;
    })();

    immessage.GetTopMsgReq = (function() {

        /**
         * Properties of a GetTopMsgReq.
         * @memberof immessage
         * @interface IGetTopMsgReq
         * @property {string|null} [targetId] GetTopMsgReq targetId
         * @property {immessage.ChannelType|null} [channelType] GetTopMsgReq channelType
         */

        /**
         * Constructs a new GetTopMsgReq.
         * @memberof immessage
         * @classdesc Represents a GetTopMsgReq.
         * @implements IGetTopMsgReq
         * @constructor
         * @param {immessage.IGetTopMsgReq=} [properties] Properties to set
         */
        function GetTopMsgReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTopMsgReq targetId.
         * @member {string} targetId
         * @memberof immessage.GetTopMsgReq
         * @instance
         */
        GetTopMsgReq.prototype.targetId = "";

        /**
         * GetTopMsgReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.GetTopMsgReq
         * @instance
         */
        GetTopMsgReq.prototype.channelType = 0;

        /**
         * Creates a new GetTopMsgReq instance using the specified properties.
         * @function create
         * @memberof immessage.GetTopMsgReq
         * @static
         * @param {immessage.IGetTopMsgReq=} [properties] Properties to set
         * @returns {immessage.GetTopMsgReq} GetTopMsgReq instance
         */
        GetTopMsgReq.create = function create(properties) {
            return new GetTopMsgReq(properties);
        };

        /**
         * Encodes the specified GetTopMsgReq message. Does not implicitly {@link immessage.GetTopMsgReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.GetTopMsgReq
         * @static
         * @param {immessage.IGetTopMsgReq} message GetTopMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTopMsgReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            return writer;
        };

        /**
         * Encodes the specified GetTopMsgReq message, length delimited. Does not implicitly {@link immessage.GetTopMsgReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.GetTopMsgReq
         * @static
         * @param {immessage.IGetTopMsgReq} message GetTopMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTopMsgReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTopMsgReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.GetTopMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.GetTopMsgReq} GetTopMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTopMsgReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.GetTopMsgReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTopMsgReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.GetTopMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.GetTopMsgReq} GetTopMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTopMsgReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTopMsgReq message.
         * @function verify
         * @memberof immessage.GetTopMsgReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTopMsgReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            return null;
        };

        /**
         * Creates a GetTopMsgReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.GetTopMsgReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.GetTopMsgReq} GetTopMsgReq
         */
        GetTopMsgReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.GetTopMsgReq)
                return object;
            let message = new $root.immessage.GetTopMsgReq();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GetTopMsgReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.GetTopMsgReq
         * @static
         * @param {immessage.GetTopMsgReq} message GetTopMsgReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTopMsgReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            return object;
        };

        /**
         * Converts this GetTopMsgReq to JSON.
         * @function toJSON
         * @memberof immessage.GetTopMsgReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTopMsgReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetTopMsgReq
         * @function getTypeUrl
         * @memberof immessage.GetTopMsgReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetTopMsgReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.GetTopMsgReq";
        };

        return GetTopMsgReq;
    })();

    immessage.TopMsg = (function() {

        /**
         * Properties of a TopMsg.
         * @memberof immessage
         * @interface ITopMsg
         * @property {immessage.IDownMsg|null} [msg] TopMsg msg
         * @property {immessage.IUserInfo|null} [operator] TopMsg operator
         * @property {number|Long|null} [createdTime] TopMsg createdTime
         */

        /**
         * Constructs a new TopMsg.
         * @memberof immessage
         * @classdesc Represents a TopMsg.
         * @implements ITopMsg
         * @constructor
         * @param {immessage.ITopMsg=} [properties] Properties to set
         */
        function TopMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TopMsg msg.
         * @member {immessage.IDownMsg|null|undefined} msg
         * @memberof immessage.TopMsg
         * @instance
         */
        TopMsg.prototype.msg = null;

        /**
         * TopMsg operator.
         * @member {immessage.IUserInfo|null|undefined} operator
         * @memberof immessage.TopMsg
         * @instance
         */
        TopMsg.prototype.operator = null;

        /**
         * TopMsg createdTime.
         * @member {number|Long} createdTime
         * @memberof immessage.TopMsg
         * @instance
         */
        TopMsg.prototype.createdTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TopMsg instance using the specified properties.
         * @function create
         * @memberof immessage.TopMsg
         * @static
         * @param {immessage.ITopMsg=} [properties] Properties to set
         * @returns {immessage.TopMsg} TopMsg instance
         */
        TopMsg.create = function create(properties) {
            return new TopMsg(properties);
        };

        /**
         * Encodes the specified TopMsg message. Does not implicitly {@link immessage.TopMsg.verify|verify} messages.
         * @function encode
         * @memberof immessage.TopMsg
         * @static
         * @param {immessage.ITopMsg} message TopMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TopMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                $root.immessage.DownMsg.encode(message.msg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.operator != null && Object.hasOwnProperty.call(message, "operator"))
                $root.immessage.UserInfo.encode(message.operator, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.createdTime != null && Object.hasOwnProperty.call(message, "createdTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.createdTime);
            return writer;
        };

        /**
         * Encodes the specified TopMsg message, length delimited. Does not implicitly {@link immessage.TopMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.TopMsg
         * @static
         * @param {immessage.ITopMsg} message TopMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TopMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TopMsg message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.TopMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.TopMsg} TopMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TopMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.TopMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.msg = $root.immessage.DownMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.operator = $root.immessage.UserInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.createdTime = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TopMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.TopMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.TopMsg} TopMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TopMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TopMsg message.
         * @function verify
         * @memberof immessage.TopMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TopMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msg != null && message.hasOwnProperty("msg")) {
                let error = $root.immessage.DownMsg.verify(message.msg);
                if (error)
                    return "msg." + error;
            }
            if (message.operator != null && message.hasOwnProperty("operator")) {
                let error = $root.immessage.UserInfo.verify(message.operator);
                if (error)
                    return "operator." + error;
            }
            if (message.createdTime != null && message.hasOwnProperty("createdTime"))
                if (!$util.isInteger(message.createdTime) && !(message.createdTime && $util.isInteger(message.createdTime.low) && $util.isInteger(message.createdTime.high)))
                    return "createdTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a TopMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.TopMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.TopMsg} TopMsg
         */
        TopMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.TopMsg)
                return object;
            let message = new $root.immessage.TopMsg();
            if (object.msg != null) {
                if (typeof object.msg !== "object")
                    throw TypeError(".immessage.TopMsg.msg: object expected");
                message.msg = $root.immessage.DownMsg.fromObject(object.msg);
            }
            if (object.operator != null) {
                if (typeof object.operator !== "object")
                    throw TypeError(".immessage.TopMsg.operator: object expected");
                message.operator = $root.immessage.UserInfo.fromObject(object.operator);
            }
            if (object.createdTime != null)
                if ($util.Long)
                    (message.createdTime = $util.Long.fromValue(object.createdTime)).unsigned = false;
                else if (typeof object.createdTime === "string")
                    message.createdTime = parseInt(object.createdTime, 10);
                else if (typeof object.createdTime === "number")
                    message.createdTime = object.createdTime;
                else if (typeof object.createdTime === "object")
                    message.createdTime = new $util.LongBits(object.createdTime.low >>> 0, object.createdTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TopMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.TopMsg
         * @static
         * @param {immessage.TopMsg} message TopMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TopMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.msg = null;
                object.operator = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.createdTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createdTime = options.longs === String ? "0" : 0;
            }
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = $root.immessage.DownMsg.toObject(message.msg, options);
            if (message.operator != null && message.hasOwnProperty("operator"))
                object.operator = $root.immessage.UserInfo.toObject(message.operator, options);
            if (message.createdTime != null && message.hasOwnProperty("createdTime"))
                if (typeof message.createdTime === "number")
                    object.createdTime = options.longs === String ? String(message.createdTime) : message.createdTime;
                else
                    object.createdTime = options.longs === String ? $util.Long.prototype.toString.call(message.createdTime) : options.longs === Number ? new $util.LongBits(message.createdTime.low >>> 0, message.createdTime.high >>> 0).toNumber() : message.createdTime;
            return object;
        };

        /**
         * Converts this TopMsg to JSON.
         * @function toJSON
         * @memberof immessage.TopMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TopMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TopMsg
         * @function getTypeUrl
         * @memberof immessage.TopMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TopMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.TopMsg";
        };

        return TopMsg;
    })();

    immessage.SearchMsgsReq = (function() {

        /**
         * Properties of a SearchMsgsReq.
         * @memberof immessage
         * @interface ISearchMsgsReq
         * @property {string|null} [targetId] SearchMsgsReq targetId
         * @property {immessage.ChannelType|null} [channelType] SearchMsgsReq channelType
         * @property {string|null} [keyword] SearchMsgsReq keyword
         * @property {number|null} [count] SearchMsgsReq count
         */

        /**
         * Constructs a new SearchMsgsReq.
         * @memberof immessage
         * @classdesc Represents a SearchMsgsReq.
         * @implements ISearchMsgsReq
         * @constructor
         * @param {immessage.ISearchMsgsReq=} [properties] Properties to set
         */
        function SearchMsgsReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchMsgsReq targetId.
         * @member {string} targetId
         * @memberof immessage.SearchMsgsReq
         * @instance
         */
        SearchMsgsReq.prototype.targetId = "";

        /**
         * SearchMsgsReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.SearchMsgsReq
         * @instance
         */
        SearchMsgsReq.prototype.channelType = 0;

        /**
         * SearchMsgsReq keyword.
         * @member {string} keyword
         * @memberof immessage.SearchMsgsReq
         * @instance
         */
        SearchMsgsReq.prototype.keyword = "";

        /**
         * SearchMsgsReq count.
         * @member {number} count
         * @memberof immessage.SearchMsgsReq
         * @instance
         */
        SearchMsgsReq.prototype.count = 0;

        /**
         * Creates a new SearchMsgsReq instance using the specified properties.
         * @function create
         * @memberof immessage.SearchMsgsReq
         * @static
         * @param {immessage.ISearchMsgsReq=} [properties] Properties to set
         * @returns {immessage.SearchMsgsReq} SearchMsgsReq instance
         */
        SearchMsgsReq.create = function create(properties) {
            return new SearchMsgsReq(properties);
        };

        /**
         * Encodes the specified SearchMsgsReq message. Does not implicitly {@link immessage.SearchMsgsReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.SearchMsgsReq
         * @static
         * @param {immessage.ISearchMsgsReq} message SearchMsgsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchMsgsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.keyword != null && Object.hasOwnProperty.call(message, "keyword"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.keyword);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified SearchMsgsReq message, length delimited. Does not implicitly {@link immessage.SearchMsgsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.SearchMsgsReq
         * @static
         * @param {immessage.ISearchMsgsReq} message SearchMsgsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchMsgsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SearchMsgsReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.SearchMsgsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.SearchMsgsReq} SearchMsgsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchMsgsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.SearchMsgsReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        message.keyword = reader.string();
                        break;
                    }
                case 4: {
                        message.count = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchMsgsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.SearchMsgsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.SearchMsgsReq} SearchMsgsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchMsgsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SearchMsgsReq message.
         * @function verify
         * @memberof immessage.SearchMsgsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SearchMsgsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.keyword != null && message.hasOwnProperty("keyword"))
                if (!$util.isString(message.keyword))
                    return "keyword: string expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        /**
         * Creates a SearchMsgsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.SearchMsgsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.SearchMsgsReq} SearchMsgsReq
         */
        SearchMsgsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.SearchMsgsReq)
                return object;
            let message = new $root.immessage.SearchMsgsReq();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.keyword != null)
                message.keyword = String(object.keyword);
            if (object.count != null)
                message.count = object.count | 0;
            return message;
        };

        /**
         * Creates a plain object from a SearchMsgsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.SearchMsgsReq
         * @static
         * @param {immessage.SearchMsgsReq} message SearchMsgsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SearchMsgsReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                object.keyword = "";
                object.count = 0;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.keyword != null && message.hasOwnProperty("keyword"))
                object.keyword = message.keyword;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this SearchMsgsReq to JSON.
         * @function toJSON
         * @memberof immessage.SearchMsgsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SearchMsgsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SearchMsgsReq
         * @function getTypeUrl
         * @memberof immessage.SearchMsgsReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SearchMsgsReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.SearchMsgsReq";
        };

        return SearchMsgsReq;
    })();

    immessage.BatchSearchMsgsReq = (function() {

        /**
         * Properties of a BatchSearchMsgsReq.
         * @memberof immessage
         * @interface IBatchSearchMsgsReq
         * @property {Array.<immessage.ISimpleConversation>|null} [convers] BatchSearchMsgsReq convers
         * @property {string|null} [keyword] BatchSearchMsgsReq keyword
         * @property {number|null} [count] BatchSearchMsgsReq count
         */

        /**
         * Constructs a new BatchSearchMsgsReq.
         * @memberof immessage
         * @classdesc Represents a BatchSearchMsgsReq.
         * @implements IBatchSearchMsgsReq
         * @constructor
         * @param {immessage.IBatchSearchMsgsReq=} [properties] Properties to set
         */
        function BatchSearchMsgsReq(properties) {
            this.convers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BatchSearchMsgsReq convers.
         * @member {Array.<immessage.ISimpleConversation>} convers
         * @memberof immessage.BatchSearchMsgsReq
         * @instance
         */
        BatchSearchMsgsReq.prototype.convers = $util.emptyArray;

        /**
         * BatchSearchMsgsReq keyword.
         * @member {string} keyword
         * @memberof immessage.BatchSearchMsgsReq
         * @instance
         */
        BatchSearchMsgsReq.prototype.keyword = "";

        /**
         * BatchSearchMsgsReq count.
         * @member {number} count
         * @memberof immessage.BatchSearchMsgsReq
         * @instance
         */
        BatchSearchMsgsReq.prototype.count = 0;

        /**
         * Creates a new BatchSearchMsgsReq instance using the specified properties.
         * @function create
         * @memberof immessage.BatchSearchMsgsReq
         * @static
         * @param {immessage.IBatchSearchMsgsReq=} [properties] Properties to set
         * @returns {immessage.BatchSearchMsgsReq} BatchSearchMsgsReq instance
         */
        BatchSearchMsgsReq.create = function create(properties) {
            return new BatchSearchMsgsReq(properties);
        };

        /**
         * Encodes the specified BatchSearchMsgsReq message. Does not implicitly {@link immessage.BatchSearchMsgsReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.BatchSearchMsgsReq
         * @static
         * @param {immessage.IBatchSearchMsgsReq} message BatchSearchMsgsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BatchSearchMsgsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.convers != null && message.convers.length)
                for (let i = 0; i < message.convers.length; ++i)
                    $root.immessage.SimpleConversation.encode(message.convers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.keyword != null && Object.hasOwnProperty.call(message, "keyword"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.keyword);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified BatchSearchMsgsReq message, length delimited. Does not implicitly {@link immessage.BatchSearchMsgsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.BatchSearchMsgsReq
         * @static
         * @param {immessage.IBatchSearchMsgsReq} message BatchSearchMsgsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BatchSearchMsgsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BatchSearchMsgsReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.BatchSearchMsgsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.BatchSearchMsgsReq} BatchSearchMsgsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BatchSearchMsgsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.BatchSearchMsgsReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.convers && message.convers.length))
                            message.convers = [];
                        message.convers.push($root.immessage.SimpleConversation.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.keyword = reader.string();
                        break;
                    }
                case 3: {
                        message.count = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BatchSearchMsgsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.BatchSearchMsgsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.BatchSearchMsgsReq} BatchSearchMsgsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BatchSearchMsgsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BatchSearchMsgsReq message.
         * @function verify
         * @memberof immessage.BatchSearchMsgsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BatchSearchMsgsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.convers != null && message.hasOwnProperty("convers")) {
                if (!Array.isArray(message.convers))
                    return "convers: array expected";
                for (let i = 0; i < message.convers.length; ++i) {
                    let error = $root.immessage.SimpleConversation.verify(message.convers[i]);
                    if (error)
                        return "convers." + error;
                }
            }
            if (message.keyword != null && message.hasOwnProperty("keyword"))
                if (!$util.isString(message.keyword))
                    return "keyword: string expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        /**
         * Creates a BatchSearchMsgsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.BatchSearchMsgsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.BatchSearchMsgsReq} BatchSearchMsgsReq
         */
        BatchSearchMsgsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.BatchSearchMsgsReq)
                return object;
            let message = new $root.immessage.BatchSearchMsgsReq();
            if (object.convers) {
                if (!Array.isArray(object.convers))
                    throw TypeError(".immessage.BatchSearchMsgsReq.convers: array expected");
                message.convers = [];
                for (let i = 0; i < object.convers.length; ++i) {
                    if (typeof object.convers[i] !== "object")
                        throw TypeError(".immessage.BatchSearchMsgsReq.convers: object expected");
                    message.convers[i] = $root.immessage.SimpleConversation.fromObject(object.convers[i]);
                }
            }
            if (object.keyword != null)
                message.keyword = String(object.keyword);
            if (object.count != null)
                message.count = object.count | 0;
            return message;
        };

        /**
         * Creates a plain object from a BatchSearchMsgsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.BatchSearchMsgsReq
         * @static
         * @param {immessage.BatchSearchMsgsReq} message BatchSearchMsgsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BatchSearchMsgsReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.convers = [];
            if (options.defaults) {
                object.keyword = "";
                object.count = 0;
            }
            if (message.convers && message.convers.length) {
                object.convers = [];
                for (let j = 0; j < message.convers.length; ++j)
                    object.convers[j] = $root.immessage.SimpleConversation.toObject(message.convers[j], options);
            }
            if (message.keyword != null && message.hasOwnProperty("keyword"))
                object.keyword = message.keyword;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this BatchSearchMsgsReq to JSON.
         * @function toJSON
         * @memberof immessage.BatchSearchMsgsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BatchSearchMsgsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BatchSearchMsgsReq
         * @function getTypeUrl
         * @memberof immessage.BatchSearchMsgsReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BatchSearchMsgsReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.BatchSearchMsgsReq";
        };

        return BatchSearchMsgsReq;
    })();

    immessage.SearchMsgsResp = (function() {

        /**
         * Properties of a SearchMsgsResp.
         * @memberof immessage
         * @interface ISearchMsgsResp
         * @property {string|null} [targetId] SearchMsgsResp targetId
         * @property {immessage.ChannelType|null} [channelType] SearchMsgsResp channelType
         * @property {Array.<immessage.ISearchMsgItem>|null} [items] SearchMsgsResp items
         * @property {number|null} [maxScore] SearchMsgsResp maxScore
         */

        /**
         * Constructs a new SearchMsgsResp.
         * @memberof immessage
         * @classdesc Represents a SearchMsgsResp.
         * @implements ISearchMsgsResp
         * @constructor
         * @param {immessage.ISearchMsgsResp=} [properties] Properties to set
         */
        function SearchMsgsResp(properties) {
            this.items = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchMsgsResp targetId.
         * @member {string} targetId
         * @memberof immessage.SearchMsgsResp
         * @instance
         */
        SearchMsgsResp.prototype.targetId = "";

        /**
         * SearchMsgsResp channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.SearchMsgsResp
         * @instance
         */
        SearchMsgsResp.prototype.channelType = 0;

        /**
         * SearchMsgsResp items.
         * @member {Array.<immessage.ISearchMsgItem>} items
         * @memberof immessage.SearchMsgsResp
         * @instance
         */
        SearchMsgsResp.prototype.items = $util.emptyArray;

        /**
         * SearchMsgsResp maxScore.
         * @member {number} maxScore
         * @memberof immessage.SearchMsgsResp
         * @instance
         */
        SearchMsgsResp.prototype.maxScore = 0;

        /**
         * Creates a new SearchMsgsResp instance using the specified properties.
         * @function create
         * @memberof immessage.SearchMsgsResp
         * @static
         * @param {immessage.ISearchMsgsResp=} [properties] Properties to set
         * @returns {immessage.SearchMsgsResp} SearchMsgsResp instance
         */
        SearchMsgsResp.create = function create(properties) {
            return new SearchMsgsResp(properties);
        };

        /**
         * Encodes the specified SearchMsgsResp message. Does not implicitly {@link immessage.SearchMsgsResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.SearchMsgsResp
         * @static
         * @param {immessage.ISearchMsgsResp} message SearchMsgsResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchMsgsResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.items != null && message.items.length)
                for (let i = 0; i < message.items.length; ++i)
                    $root.immessage.SearchMsgItem.encode(message.items[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.maxScore != null && Object.hasOwnProperty.call(message, "maxScore"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.maxScore);
            return writer;
        };

        /**
         * Encodes the specified SearchMsgsResp message, length delimited. Does not implicitly {@link immessage.SearchMsgsResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.SearchMsgsResp
         * @static
         * @param {immessage.ISearchMsgsResp} message SearchMsgsResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchMsgsResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SearchMsgsResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.SearchMsgsResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.SearchMsgsResp} SearchMsgsResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchMsgsResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.SearchMsgsResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.immessage.SearchMsgItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.maxScore = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchMsgsResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.SearchMsgsResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.SearchMsgsResp} SearchMsgsResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchMsgsResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SearchMsgsResp message.
         * @function verify
         * @memberof immessage.SearchMsgsResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SearchMsgsResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (let i = 0; i < message.items.length; ++i) {
                    let error = $root.immessage.SearchMsgItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.maxScore != null && message.hasOwnProperty("maxScore"))
                if (typeof message.maxScore !== "number")
                    return "maxScore: number expected";
            return null;
        };

        /**
         * Creates a SearchMsgsResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.SearchMsgsResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.SearchMsgsResp} SearchMsgsResp
         */
        SearchMsgsResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.SearchMsgsResp)
                return object;
            let message = new $root.immessage.SearchMsgsResp();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".immessage.SearchMsgsResp.items: array expected");
                message.items = [];
                for (let i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".immessage.SearchMsgsResp.items: object expected");
                    message.items[i] = $root.immessage.SearchMsgItem.fromObject(object.items[i]);
                }
            }
            if (object.maxScore != null)
                message.maxScore = Number(object.maxScore);
            return message;
        };

        /**
         * Creates a plain object from a SearchMsgsResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.SearchMsgsResp
         * @static
         * @param {immessage.SearchMsgsResp} message SearchMsgsResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SearchMsgsResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                object.maxScore = 0;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.items && message.items.length) {
                object.items = [];
                for (let j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.immessage.SearchMsgItem.toObject(message.items[j], options);
            }
            if (message.maxScore != null && message.hasOwnProperty("maxScore"))
                object.maxScore = options.json && !isFinite(message.maxScore) ? String(message.maxScore) : message.maxScore;
            return object;
        };

        /**
         * Converts this SearchMsgsResp to JSON.
         * @function toJSON
         * @memberof immessage.SearchMsgsResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SearchMsgsResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SearchMsgsResp
         * @function getTypeUrl
         * @memberof immessage.SearchMsgsResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SearchMsgsResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.SearchMsgsResp";
        };

        return SearchMsgsResp;
    })();

    immessage.SearchMsgItem = (function() {

        /**
         * Properties of a SearchMsgItem.
         * @memberof immessage
         * @interface ISearchMsgItem
         * @property {string|null} [highlightText] SearchMsgItem highlightText
         * @property {immessage.IDownMsg|null} [msg] SearchMsgItem msg
         * @property {number|null} [score] SearchMsgItem score
         */

        /**
         * Constructs a new SearchMsgItem.
         * @memberof immessage
         * @classdesc Represents a SearchMsgItem.
         * @implements ISearchMsgItem
         * @constructor
         * @param {immessage.ISearchMsgItem=} [properties] Properties to set
         */
        function SearchMsgItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchMsgItem highlightText.
         * @member {string} highlightText
         * @memberof immessage.SearchMsgItem
         * @instance
         */
        SearchMsgItem.prototype.highlightText = "";

        /**
         * SearchMsgItem msg.
         * @member {immessage.IDownMsg|null|undefined} msg
         * @memberof immessage.SearchMsgItem
         * @instance
         */
        SearchMsgItem.prototype.msg = null;

        /**
         * SearchMsgItem score.
         * @member {number} score
         * @memberof immessage.SearchMsgItem
         * @instance
         */
        SearchMsgItem.prototype.score = 0;

        /**
         * Creates a new SearchMsgItem instance using the specified properties.
         * @function create
         * @memberof immessage.SearchMsgItem
         * @static
         * @param {immessage.ISearchMsgItem=} [properties] Properties to set
         * @returns {immessage.SearchMsgItem} SearchMsgItem instance
         */
        SearchMsgItem.create = function create(properties) {
            return new SearchMsgItem(properties);
        };

        /**
         * Encodes the specified SearchMsgItem message. Does not implicitly {@link immessage.SearchMsgItem.verify|verify} messages.
         * @function encode
         * @memberof immessage.SearchMsgItem
         * @static
         * @param {immessage.ISearchMsgItem} message SearchMsgItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchMsgItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.highlightText != null && Object.hasOwnProperty.call(message, "highlightText"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.highlightText);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                $root.immessage.DownMsg.encode(message.msg, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.score);
            return writer;
        };

        /**
         * Encodes the specified SearchMsgItem message, length delimited. Does not implicitly {@link immessage.SearchMsgItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.SearchMsgItem
         * @static
         * @param {immessage.ISearchMsgItem} message SearchMsgItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchMsgItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SearchMsgItem message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.SearchMsgItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.SearchMsgItem} SearchMsgItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchMsgItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.SearchMsgItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.highlightText = reader.string();
                        break;
                    }
                case 2: {
                        message.msg = $root.immessage.DownMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.score = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchMsgItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.SearchMsgItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.SearchMsgItem} SearchMsgItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchMsgItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SearchMsgItem message.
         * @function verify
         * @memberof immessage.SearchMsgItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SearchMsgItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.highlightText != null && message.hasOwnProperty("highlightText"))
                if (!$util.isString(message.highlightText))
                    return "highlightText: string expected";
            if (message.msg != null && message.hasOwnProperty("msg")) {
                let error = $root.immessage.DownMsg.verify(message.msg);
                if (error)
                    return "msg." + error;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                if (typeof message.score !== "number")
                    return "score: number expected";
            return null;
        };

        /**
         * Creates a SearchMsgItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.SearchMsgItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.SearchMsgItem} SearchMsgItem
         */
        SearchMsgItem.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.SearchMsgItem)
                return object;
            let message = new $root.immessage.SearchMsgItem();
            if (object.highlightText != null)
                message.highlightText = String(object.highlightText);
            if (object.msg != null) {
                if (typeof object.msg !== "object")
                    throw TypeError(".immessage.SearchMsgItem.msg: object expected");
                message.msg = $root.immessage.DownMsg.fromObject(object.msg);
            }
            if (object.score != null)
                message.score = Number(object.score);
            return message;
        };

        /**
         * Creates a plain object from a SearchMsgItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.SearchMsgItem
         * @static
         * @param {immessage.SearchMsgItem} message SearchMsgItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SearchMsgItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.highlightText = "";
                object.msg = null;
                object.score = 0;
            }
            if (message.highlightText != null && message.hasOwnProperty("highlightText"))
                object.highlightText = message.highlightText;
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = $root.immessage.DownMsg.toObject(message.msg, options);
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;
            return object;
        };

        /**
         * Converts this SearchMsgItem to JSON.
         * @function toJSON
         * @memberof immessage.SearchMsgItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SearchMsgItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SearchMsgItem
         * @function getTypeUrl
         * @memberof immessage.SearchMsgItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SearchMsgItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.SearchMsgItem";
        };

        return SearchMsgItem;
    })();

    immessage.BatchSearchMsgsResp = (function() {

        /**
         * Properties of a BatchSearchMsgsResp.
         * @memberof immessage
         * @interface IBatchSearchMsgsResp
         * @property {Array.<immessage.ISearchMsgsResp>|null} [items] BatchSearchMsgsResp items
         * @property {number|null} [maxScore] BatchSearchMsgsResp maxScore
         */

        /**
         * Constructs a new BatchSearchMsgsResp.
         * @memberof immessage
         * @classdesc Represents a BatchSearchMsgsResp.
         * @implements IBatchSearchMsgsResp
         * @constructor
         * @param {immessage.IBatchSearchMsgsResp=} [properties] Properties to set
         */
        function BatchSearchMsgsResp(properties) {
            this.items = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BatchSearchMsgsResp items.
         * @member {Array.<immessage.ISearchMsgsResp>} items
         * @memberof immessage.BatchSearchMsgsResp
         * @instance
         */
        BatchSearchMsgsResp.prototype.items = $util.emptyArray;

        /**
         * BatchSearchMsgsResp maxScore.
         * @member {number} maxScore
         * @memberof immessage.BatchSearchMsgsResp
         * @instance
         */
        BatchSearchMsgsResp.prototype.maxScore = 0;

        /**
         * Creates a new BatchSearchMsgsResp instance using the specified properties.
         * @function create
         * @memberof immessage.BatchSearchMsgsResp
         * @static
         * @param {immessage.IBatchSearchMsgsResp=} [properties] Properties to set
         * @returns {immessage.BatchSearchMsgsResp} BatchSearchMsgsResp instance
         */
        BatchSearchMsgsResp.create = function create(properties) {
            return new BatchSearchMsgsResp(properties);
        };

        /**
         * Encodes the specified BatchSearchMsgsResp message. Does not implicitly {@link immessage.BatchSearchMsgsResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.BatchSearchMsgsResp
         * @static
         * @param {immessage.IBatchSearchMsgsResp} message BatchSearchMsgsResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BatchSearchMsgsResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (let i = 0; i < message.items.length; ++i)
                    $root.immessage.SearchMsgsResp.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.maxScore != null && Object.hasOwnProperty.call(message, "maxScore"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.maxScore);
            return writer;
        };

        /**
         * Encodes the specified BatchSearchMsgsResp message, length delimited. Does not implicitly {@link immessage.BatchSearchMsgsResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.BatchSearchMsgsResp
         * @static
         * @param {immessage.IBatchSearchMsgsResp} message BatchSearchMsgsResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BatchSearchMsgsResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BatchSearchMsgsResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.BatchSearchMsgsResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.BatchSearchMsgsResp} BatchSearchMsgsResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BatchSearchMsgsResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.BatchSearchMsgsResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.immessage.SearchMsgsResp.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.maxScore = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BatchSearchMsgsResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.BatchSearchMsgsResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.BatchSearchMsgsResp} BatchSearchMsgsResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BatchSearchMsgsResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BatchSearchMsgsResp message.
         * @function verify
         * @memberof immessage.BatchSearchMsgsResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BatchSearchMsgsResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (let i = 0; i < message.items.length; ++i) {
                    let error = $root.immessage.SearchMsgsResp.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.maxScore != null && message.hasOwnProperty("maxScore"))
                if (typeof message.maxScore !== "number")
                    return "maxScore: number expected";
            return null;
        };

        /**
         * Creates a BatchSearchMsgsResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.BatchSearchMsgsResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.BatchSearchMsgsResp} BatchSearchMsgsResp
         */
        BatchSearchMsgsResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.BatchSearchMsgsResp)
                return object;
            let message = new $root.immessage.BatchSearchMsgsResp();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".immessage.BatchSearchMsgsResp.items: array expected");
                message.items = [];
                for (let i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".immessage.BatchSearchMsgsResp.items: object expected");
                    message.items[i] = $root.immessage.SearchMsgsResp.fromObject(object.items[i]);
                }
            }
            if (object.maxScore != null)
                message.maxScore = Number(object.maxScore);
            return message;
        };

        /**
         * Creates a plain object from a BatchSearchMsgsResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.BatchSearchMsgsResp
         * @static
         * @param {immessage.BatchSearchMsgsResp} message BatchSearchMsgsResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BatchSearchMsgsResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                object.maxScore = 0;
            if (message.items && message.items.length) {
                object.items = [];
                for (let j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.immessage.SearchMsgsResp.toObject(message.items[j], options);
            }
            if (message.maxScore != null && message.hasOwnProperty("maxScore"))
                object.maxScore = options.json && !isFinite(message.maxScore) ? String(message.maxScore) : message.maxScore;
            return object;
        };

        /**
         * Converts this BatchSearchMsgsResp to JSON.
         * @function toJSON
         * @memberof immessage.BatchSearchMsgsResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BatchSearchMsgsResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BatchSearchMsgsResp
         * @function getTypeUrl
         * @memberof immessage.BatchSearchMsgsResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BatchSearchMsgsResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.BatchSearchMsgsResp";
        };

        return BatchSearchMsgsResp;
    })();

    immessage.QryGlobalConversReq = (function() {

        /**
         * Properties of a QryGlobalConversReq.
         * @memberof immessage
         * @interface IQryGlobalConversReq
         * @property {number|Long|null} [start] QryGlobalConversReq start
         * @property {number|null} [count] QryGlobalConversReq count
         * @property {number|null} [order] QryGlobalConversReq order
         * @property {string|null} [targetId] QryGlobalConversReq targetId
         * @property {immessage.ChannelType|null} [channelType] QryGlobalConversReq channelType
         * @property {Array.<string>|null} [excludeUserIds] QryGlobalConversReq excludeUserIds
         */

        /**
         * Constructs a new QryGlobalConversReq.
         * @memberof immessage
         * @classdesc Represents a QryGlobalConversReq.
         * @implements IQryGlobalConversReq
         * @constructor
         * @param {immessage.IQryGlobalConversReq=} [properties] Properties to set
         */
        function QryGlobalConversReq(properties) {
            this.excludeUserIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryGlobalConversReq start.
         * @member {number|Long} start
         * @memberof immessage.QryGlobalConversReq
         * @instance
         */
        QryGlobalConversReq.prototype.start = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QryGlobalConversReq count.
         * @member {number} count
         * @memberof immessage.QryGlobalConversReq
         * @instance
         */
        QryGlobalConversReq.prototype.count = 0;

        /**
         * QryGlobalConversReq order.
         * @member {number} order
         * @memberof immessage.QryGlobalConversReq
         * @instance
         */
        QryGlobalConversReq.prototype.order = 0;

        /**
         * QryGlobalConversReq targetId.
         * @member {string} targetId
         * @memberof immessage.QryGlobalConversReq
         * @instance
         */
        QryGlobalConversReq.prototype.targetId = "";

        /**
         * QryGlobalConversReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.QryGlobalConversReq
         * @instance
         */
        QryGlobalConversReq.prototype.channelType = 0;

        /**
         * QryGlobalConversReq excludeUserIds.
         * @member {Array.<string>} excludeUserIds
         * @memberof immessage.QryGlobalConversReq
         * @instance
         */
        QryGlobalConversReq.prototype.excludeUserIds = $util.emptyArray;

        /**
         * Creates a new QryGlobalConversReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryGlobalConversReq
         * @static
         * @param {immessage.IQryGlobalConversReq=} [properties] Properties to set
         * @returns {immessage.QryGlobalConversReq} QryGlobalConversReq instance
         */
        QryGlobalConversReq.create = function create(properties) {
            return new QryGlobalConversReq(properties);
        };

        /**
         * Encodes the specified QryGlobalConversReq message. Does not implicitly {@link immessage.QryGlobalConversReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryGlobalConversReq
         * @static
         * @param {immessage.IQryGlobalConversReq} message QryGlobalConversReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryGlobalConversReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.start);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
            if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.order);
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.channelType);
            if (message.excludeUserIds != null && message.excludeUserIds.length)
                for (let i = 0; i < message.excludeUserIds.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.excludeUserIds[i]);
            return writer;
        };

        /**
         * Encodes the specified QryGlobalConversReq message, length delimited. Does not implicitly {@link immessage.QryGlobalConversReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryGlobalConversReq
         * @static
         * @param {immessage.IQryGlobalConversReq} message QryGlobalConversReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryGlobalConversReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryGlobalConversReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryGlobalConversReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryGlobalConversReq} QryGlobalConversReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryGlobalConversReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryGlobalConversReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.start = reader.int64();
                        break;
                    }
                case 2: {
                        message.count = reader.int32();
                        break;
                    }
                case 3: {
                        message.order = reader.int32();
                        break;
                    }
                case 4: {
                        message.targetId = reader.string();
                        break;
                    }
                case 5: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 6: {
                        if (!(message.excludeUserIds && message.excludeUserIds.length))
                            message.excludeUserIds = [];
                        message.excludeUserIds.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryGlobalConversReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryGlobalConversReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryGlobalConversReq} QryGlobalConversReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryGlobalConversReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryGlobalConversReq message.
         * @function verify
         * @memberof immessage.QryGlobalConversReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryGlobalConversReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.start != null && message.hasOwnProperty("start"))
                if (!$util.isInteger(message.start) && !(message.start && $util.isInteger(message.start.low) && $util.isInteger(message.start.high)))
                    return "start: integer|Long expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            if (message.order != null && message.hasOwnProperty("order"))
                if (!$util.isInteger(message.order))
                    return "order: integer expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.excludeUserIds != null && message.hasOwnProperty("excludeUserIds")) {
                if (!Array.isArray(message.excludeUserIds))
                    return "excludeUserIds: array expected";
                for (let i = 0; i < message.excludeUserIds.length; ++i)
                    if (!$util.isString(message.excludeUserIds[i]))
                        return "excludeUserIds: string[] expected";
            }
            return null;
        };

        /**
         * Creates a QryGlobalConversReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryGlobalConversReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryGlobalConversReq} QryGlobalConversReq
         */
        QryGlobalConversReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryGlobalConversReq)
                return object;
            let message = new $root.immessage.QryGlobalConversReq();
            if (object.start != null)
                if ($util.Long)
                    (message.start = $util.Long.fromValue(object.start)).unsigned = false;
                else if (typeof object.start === "string")
                    message.start = parseInt(object.start, 10);
                else if (typeof object.start === "number")
                    message.start = object.start;
                else if (typeof object.start === "object")
                    message.start = new $util.LongBits(object.start.low >>> 0, object.start.high >>> 0).toNumber();
            if (object.count != null)
                message.count = object.count | 0;
            if (object.order != null)
                message.order = object.order | 0;
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.excludeUserIds) {
                if (!Array.isArray(object.excludeUserIds))
                    throw TypeError(".immessage.QryGlobalConversReq.excludeUserIds: array expected");
                message.excludeUserIds = [];
                for (let i = 0; i < object.excludeUserIds.length; ++i)
                    message.excludeUserIds[i] = String(object.excludeUserIds[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a QryGlobalConversReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryGlobalConversReq
         * @static
         * @param {immessage.QryGlobalConversReq} message QryGlobalConversReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryGlobalConversReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.excludeUserIds = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.start = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.start = options.longs === String ? "0" : 0;
                object.count = 0;
                object.order = 0;
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
            }
            if (message.start != null && message.hasOwnProperty("start"))
                if (typeof message.start === "number")
                    object.start = options.longs === String ? String(message.start) : message.start;
                else
                    object.start = options.longs === String ? $util.Long.prototype.toString.call(message.start) : options.longs === Number ? new $util.LongBits(message.start.low >>> 0, message.start.high >>> 0).toNumber() : message.start;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            if (message.order != null && message.hasOwnProperty("order"))
                object.order = message.order;
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.excludeUserIds && message.excludeUserIds.length) {
                object.excludeUserIds = [];
                for (let j = 0; j < message.excludeUserIds.length; ++j)
                    object.excludeUserIds[j] = message.excludeUserIds[j];
            }
            return object;
        };

        /**
         * Converts this QryGlobalConversReq to JSON.
         * @function toJSON
         * @memberof immessage.QryGlobalConversReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryGlobalConversReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryGlobalConversReq
         * @function getTypeUrl
         * @memberof immessage.QryGlobalConversReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryGlobalConversReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryGlobalConversReq";
        };

        return QryGlobalConversReq;
    })();

    immessage.QryGlobalConversResp = (function() {

        /**
         * Properties of a QryGlobalConversResp.
         * @memberof immessage
         * @interface IQryGlobalConversResp
         * @property {Array.<immessage.IGlobalConver>|null} [convers] QryGlobalConversResp convers
         * @property {boolean|null} [isFinished] QryGlobalConversResp isFinished
         */

        /**
         * Constructs a new QryGlobalConversResp.
         * @memberof immessage
         * @classdesc Represents a QryGlobalConversResp.
         * @implements IQryGlobalConversResp
         * @constructor
         * @param {immessage.IQryGlobalConversResp=} [properties] Properties to set
         */
        function QryGlobalConversResp(properties) {
            this.convers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryGlobalConversResp convers.
         * @member {Array.<immessage.IGlobalConver>} convers
         * @memberof immessage.QryGlobalConversResp
         * @instance
         */
        QryGlobalConversResp.prototype.convers = $util.emptyArray;

        /**
         * QryGlobalConversResp isFinished.
         * @member {boolean} isFinished
         * @memberof immessage.QryGlobalConversResp
         * @instance
         */
        QryGlobalConversResp.prototype.isFinished = false;

        /**
         * Creates a new QryGlobalConversResp instance using the specified properties.
         * @function create
         * @memberof immessage.QryGlobalConversResp
         * @static
         * @param {immessage.IQryGlobalConversResp=} [properties] Properties to set
         * @returns {immessage.QryGlobalConversResp} QryGlobalConversResp instance
         */
        QryGlobalConversResp.create = function create(properties) {
            return new QryGlobalConversResp(properties);
        };

        /**
         * Encodes the specified QryGlobalConversResp message. Does not implicitly {@link immessage.QryGlobalConversResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryGlobalConversResp
         * @static
         * @param {immessage.IQryGlobalConversResp} message QryGlobalConversResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryGlobalConversResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.convers != null && message.convers.length)
                for (let i = 0; i < message.convers.length; ++i)
                    $root.immessage.GlobalConver.encode(message.convers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.isFinished != null && Object.hasOwnProperty.call(message, "isFinished"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isFinished);
            return writer;
        };

        /**
         * Encodes the specified QryGlobalConversResp message, length delimited. Does not implicitly {@link immessage.QryGlobalConversResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryGlobalConversResp
         * @static
         * @param {immessage.IQryGlobalConversResp} message QryGlobalConversResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryGlobalConversResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryGlobalConversResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryGlobalConversResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryGlobalConversResp} QryGlobalConversResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryGlobalConversResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryGlobalConversResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.convers && message.convers.length))
                            message.convers = [];
                        message.convers.push($root.immessage.GlobalConver.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.isFinished = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryGlobalConversResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryGlobalConversResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryGlobalConversResp} QryGlobalConversResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryGlobalConversResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryGlobalConversResp message.
         * @function verify
         * @memberof immessage.QryGlobalConversResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryGlobalConversResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.convers != null && message.hasOwnProperty("convers")) {
                if (!Array.isArray(message.convers))
                    return "convers: array expected";
                for (let i = 0; i < message.convers.length; ++i) {
                    let error = $root.immessage.GlobalConver.verify(message.convers[i]);
                    if (error)
                        return "convers." + error;
                }
            }
            if (message.isFinished != null && message.hasOwnProperty("isFinished"))
                if (typeof message.isFinished !== "boolean")
                    return "isFinished: boolean expected";
            return null;
        };

        /**
         * Creates a QryGlobalConversResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryGlobalConversResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryGlobalConversResp} QryGlobalConversResp
         */
        QryGlobalConversResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryGlobalConversResp)
                return object;
            let message = new $root.immessage.QryGlobalConversResp();
            if (object.convers) {
                if (!Array.isArray(object.convers))
                    throw TypeError(".immessage.QryGlobalConversResp.convers: array expected");
                message.convers = [];
                for (let i = 0; i < object.convers.length; ++i) {
                    if (typeof object.convers[i] !== "object")
                        throw TypeError(".immessage.QryGlobalConversResp.convers: object expected");
                    message.convers[i] = $root.immessage.GlobalConver.fromObject(object.convers[i]);
                }
            }
            if (object.isFinished != null)
                message.isFinished = Boolean(object.isFinished);
            return message;
        };

        /**
         * Creates a plain object from a QryGlobalConversResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryGlobalConversResp
         * @static
         * @param {immessage.QryGlobalConversResp} message QryGlobalConversResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryGlobalConversResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.convers = [];
            if (options.defaults)
                object.isFinished = false;
            if (message.convers && message.convers.length) {
                object.convers = [];
                for (let j = 0; j < message.convers.length; ++j)
                    object.convers[j] = $root.immessage.GlobalConver.toObject(message.convers[j], options);
            }
            if (message.isFinished != null && message.hasOwnProperty("isFinished"))
                object.isFinished = message.isFinished;
            return object;
        };

        /**
         * Converts this QryGlobalConversResp to JSON.
         * @function toJSON
         * @memberof immessage.QryGlobalConversResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryGlobalConversResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryGlobalConversResp
         * @function getTypeUrl
         * @memberof immessage.QryGlobalConversResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryGlobalConversResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryGlobalConversResp";
        };

        return QryGlobalConversResp;
    })();

    immessage.GlobalConver = (function() {

        /**
         * Properties of a GlobalConver.
         * @memberof immessage
         * @interface IGlobalConver
         * @property {string|null} [Id] GlobalConver Id
         * @property {string|null} [converId] GlobalConver converId
         * @property {string|null} [senderId] GlobalConver senderId
         * @property {string|null} [targetId] GlobalConver targetId
         * @property {immessage.ChannelType|null} [channelType] GlobalConver channelType
         * @property {number|Long|null} [updatedTime] GlobalConver updatedTime
         */

        /**
         * Constructs a new GlobalConver.
         * @memberof immessage
         * @classdesc Represents a GlobalConver.
         * @implements IGlobalConver
         * @constructor
         * @param {immessage.IGlobalConver=} [properties] Properties to set
         */
        function GlobalConver(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GlobalConver Id.
         * @member {string} Id
         * @memberof immessage.GlobalConver
         * @instance
         */
        GlobalConver.prototype.Id = "";

        /**
         * GlobalConver converId.
         * @member {string} converId
         * @memberof immessage.GlobalConver
         * @instance
         */
        GlobalConver.prototype.converId = "";

        /**
         * GlobalConver senderId.
         * @member {string} senderId
         * @memberof immessage.GlobalConver
         * @instance
         */
        GlobalConver.prototype.senderId = "";

        /**
         * GlobalConver targetId.
         * @member {string} targetId
         * @memberof immessage.GlobalConver
         * @instance
         */
        GlobalConver.prototype.targetId = "";

        /**
         * GlobalConver channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.GlobalConver
         * @instance
         */
        GlobalConver.prototype.channelType = 0;

        /**
         * GlobalConver updatedTime.
         * @member {number|Long} updatedTime
         * @memberof immessage.GlobalConver
         * @instance
         */
        GlobalConver.prototype.updatedTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GlobalConver instance using the specified properties.
         * @function create
         * @memberof immessage.GlobalConver
         * @static
         * @param {immessage.IGlobalConver=} [properties] Properties to set
         * @returns {immessage.GlobalConver} GlobalConver instance
         */
        GlobalConver.create = function create(properties) {
            return new GlobalConver(properties);
        };

        /**
         * Encodes the specified GlobalConver message. Does not implicitly {@link immessage.GlobalConver.verify|verify} messages.
         * @function encode
         * @memberof immessage.GlobalConver
         * @static
         * @param {immessage.IGlobalConver} message GlobalConver message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GlobalConver.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Id != null && Object.hasOwnProperty.call(message, "Id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Id);
            if (message.converId != null && Object.hasOwnProperty.call(message, "converId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.converId);
            if (message.senderId != null && Object.hasOwnProperty.call(message, "senderId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.senderId);
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.channelType);
            if (message.updatedTime != null && Object.hasOwnProperty.call(message, "updatedTime"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.updatedTime);
            return writer;
        };

        /**
         * Encodes the specified GlobalConver message, length delimited. Does not implicitly {@link immessage.GlobalConver.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.GlobalConver
         * @static
         * @param {immessage.IGlobalConver} message GlobalConver message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GlobalConver.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GlobalConver message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.GlobalConver
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.GlobalConver} GlobalConver
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GlobalConver.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.GlobalConver();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.Id = reader.string();
                        break;
                    }
                case 2: {
                        message.converId = reader.string();
                        break;
                    }
                case 3: {
                        message.senderId = reader.string();
                        break;
                    }
                case 4: {
                        message.targetId = reader.string();
                        break;
                    }
                case 5: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 6: {
                        message.updatedTime = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GlobalConver message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.GlobalConver
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.GlobalConver} GlobalConver
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GlobalConver.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GlobalConver message.
         * @function verify
         * @memberof immessage.GlobalConver
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GlobalConver.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Id != null && message.hasOwnProperty("Id"))
                if (!$util.isString(message.Id))
                    return "Id: string expected";
            if (message.converId != null && message.hasOwnProperty("converId"))
                if (!$util.isString(message.converId))
                    return "converId: string expected";
            if (message.senderId != null && message.hasOwnProperty("senderId"))
                if (!$util.isString(message.senderId))
                    return "senderId: string expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.updatedTime != null && message.hasOwnProperty("updatedTime"))
                if (!$util.isInteger(message.updatedTime) && !(message.updatedTime && $util.isInteger(message.updatedTime.low) && $util.isInteger(message.updatedTime.high)))
                    return "updatedTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a GlobalConver message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.GlobalConver
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.GlobalConver} GlobalConver
         */
        GlobalConver.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.GlobalConver)
                return object;
            let message = new $root.immessage.GlobalConver();
            if (object.Id != null)
                message.Id = String(object.Id);
            if (object.converId != null)
                message.converId = String(object.converId);
            if (object.senderId != null)
                message.senderId = String(object.senderId);
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.updatedTime != null)
                if ($util.Long)
                    (message.updatedTime = $util.Long.fromValue(object.updatedTime)).unsigned = false;
                else if (typeof object.updatedTime === "string")
                    message.updatedTime = parseInt(object.updatedTime, 10);
                else if (typeof object.updatedTime === "number")
                    message.updatedTime = object.updatedTime;
                else if (typeof object.updatedTime === "object")
                    message.updatedTime = new $util.LongBits(object.updatedTime.low >>> 0, object.updatedTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a GlobalConver message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.GlobalConver
         * @static
         * @param {immessage.GlobalConver} message GlobalConver
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GlobalConver.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.Id = "";
                object.converId = "";
                object.senderId = "";
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.updatedTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.updatedTime = options.longs === String ? "0" : 0;
            }
            if (message.Id != null && message.hasOwnProperty("Id"))
                object.Id = message.Id;
            if (message.converId != null && message.hasOwnProperty("converId"))
                object.converId = message.converId;
            if (message.senderId != null && message.hasOwnProperty("senderId"))
                object.senderId = message.senderId;
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.updatedTime != null && message.hasOwnProperty("updatedTime"))
                if (typeof message.updatedTime === "number")
                    object.updatedTime = options.longs === String ? String(message.updatedTime) : message.updatedTime;
                else
                    object.updatedTime = options.longs === String ? $util.Long.prototype.toString.call(message.updatedTime) : options.longs === Number ? new $util.LongBits(message.updatedTime.low >>> 0, message.updatedTime.high >>> 0).toNumber() : message.updatedTime;
            return object;
        };

        /**
         * Converts this GlobalConver to JSON.
         * @function toJSON
         * @memberof immessage.GlobalConver
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GlobalConver.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GlobalConver
         * @function getTypeUrl
         * @memberof immessage.GlobalConver
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GlobalConver.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.GlobalConver";
        };

        return GlobalConver;
    })();

    immessage.QryConversationsReq = (function() {

        /**
         * Properties of a QryConversationsReq.
         * @memberof immessage
         * @interface IQryConversationsReq
         * @property {number|Long|null} [startTime] QryConversationsReq startTime
         * @property {number|null} [count] QryConversationsReq count
         * @property {number|null} [order] QryConversationsReq order
         * @property {string|null} [targetId] QryConversationsReq targetId
         * @property {immessage.ChannelType|null} [channelType] QryConversationsReq channelType
         * @property {string|null} [tag] QryConversationsReq tag
         * @property {Array.<immessage.IPermitConver>|null} [permitConvers] QryConversationsReq permitConvers
         * @property {boolean|null} [onlyConver] QryConversationsReq onlyConver
         */

        /**
         * Constructs a new QryConversationsReq.
         * @memberof immessage
         * @classdesc Represents a QryConversationsReq.
         * @implements IQryConversationsReq
         * @constructor
         * @param {immessage.IQryConversationsReq=} [properties] Properties to set
         */
        function QryConversationsReq(properties) {
            this.permitConvers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryConversationsReq startTime.
         * @member {number|Long} startTime
         * @memberof immessage.QryConversationsReq
         * @instance
         */
        QryConversationsReq.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QryConversationsReq count.
         * @member {number} count
         * @memberof immessage.QryConversationsReq
         * @instance
         */
        QryConversationsReq.prototype.count = 0;

        /**
         * QryConversationsReq order.
         * @member {number} order
         * @memberof immessage.QryConversationsReq
         * @instance
         */
        QryConversationsReq.prototype.order = 0;

        /**
         * QryConversationsReq targetId.
         * @member {string} targetId
         * @memberof immessage.QryConversationsReq
         * @instance
         */
        QryConversationsReq.prototype.targetId = "";

        /**
         * QryConversationsReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.QryConversationsReq
         * @instance
         */
        QryConversationsReq.prototype.channelType = 0;

        /**
         * QryConversationsReq tag.
         * @member {string} tag
         * @memberof immessage.QryConversationsReq
         * @instance
         */
        QryConversationsReq.prototype.tag = "";

        /**
         * QryConversationsReq permitConvers.
         * @member {Array.<immessage.IPermitConver>} permitConvers
         * @memberof immessage.QryConversationsReq
         * @instance
         */
        QryConversationsReq.prototype.permitConvers = $util.emptyArray;

        /**
         * QryConversationsReq onlyConver.
         * @member {boolean} onlyConver
         * @memberof immessage.QryConversationsReq
         * @instance
         */
        QryConversationsReq.prototype.onlyConver = false;

        /**
         * Creates a new QryConversationsReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryConversationsReq
         * @static
         * @param {immessage.IQryConversationsReq=} [properties] Properties to set
         * @returns {immessage.QryConversationsReq} QryConversationsReq instance
         */
        QryConversationsReq.create = function create(properties) {
            return new QryConversationsReq(properties);
        };

        /**
         * Encodes the specified QryConversationsReq message. Does not implicitly {@link immessage.QryConversationsReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryConversationsReq
         * @static
         * @param {immessage.IQryConversationsReq} message QryConversationsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryConversationsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.startTime);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
            if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.order);
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.channelType);
            if (message.tag != null && Object.hasOwnProperty.call(message, "tag"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.tag);
            if (message.permitConvers != null && message.permitConvers.length)
                for (let i = 0; i < message.permitConvers.length; ++i)
                    $root.immessage.PermitConver.encode(message.permitConvers[i], writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
            if (message.onlyConver != null && Object.hasOwnProperty.call(message, "onlyConver"))
                writer.uint32(/* id 52, wireType 0 =*/416).bool(message.onlyConver);
            return writer;
        };

        /**
         * Encodes the specified QryConversationsReq message, length delimited. Does not implicitly {@link immessage.QryConversationsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryConversationsReq
         * @static
         * @param {immessage.IQryConversationsReq} message QryConversationsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryConversationsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryConversationsReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryConversationsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryConversationsReq} QryConversationsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryConversationsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryConversationsReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.startTime = reader.int64();
                        break;
                    }
                case 2: {
                        message.count = reader.int32();
                        break;
                    }
                case 3: {
                        message.order = reader.int32();
                        break;
                    }
                case 5: {
                        message.targetId = reader.string();
                        break;
                    }
                case 6: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 7: {
                        message.tag = reader.string();
                        break;
                    }
                case 51: {
                        if (!(message.permitConvers && message.permitConvers.length))
                            message.permitConvers = [];
                        message.permitConvers.push($root.immessage.PermitConver.decode(reader, reader.uint32()));
                        break;
                    }
                case 52: {
                        message.onlyConver = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryConversationsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryConversationsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryConversationsReq} QryConversationsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryConversationsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryConversationsReq message.
         * @function verify
         * @memberof immessage.QryConversationsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryConversationsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            if (message.order != null && message.hasOwnProperty("order"))
                if (!$util.isInteger(message.order))
                    return "order: integer expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.tag != null && message.hasOwnProperty("tag"))
                if (!$util.isString(message.tag))
                    return "tag: string expected";
            if (message.permitConvers != null && message.hasOwnProperty("permitConvers")) {
                if (!Array.isArray(message.permitConvers))
                    return "permitConvers: array expected";
                for (let i = 0; i < message.permitConvers.length; ++i) {
                    let error = $root.immessage.PermitConver.verify(message.permitConvers[i]);
                    if (error)
                        return "permitConvers." + error;
                }
            }
            if (message.onlyConver != null && message.hasOwnProperty("onlyConver"))
                if (typeof message.onlyConver !== "boolean")
                    return "onlyConver: boolean expected";
            return null;
        };

        /**
         * Creates a QryConversationsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryConversationsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryConversationsReq} QryConversationsReq
         */
        QryConversationsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryConversationsReq)
                return object;
            let message = new $root.immessage.QryConversationsReq();
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = false;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber();
            if (object.count != null)
                message.count = object.count | 0;
            if (object.order != null)
                message.order = object.order | 0;
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.tag != null)
                message.tag = String(object.tag);
            if (object.permitConvers) {
                if (!Array.isArray(object.permitConvers))
                    throw TypeError(".immessage.QryConversationsReq.permitConvers: array expected");
                message.permitConvers = [];
                for (let i = 0; i < object.permitConvers.length; ++i) {
                    if (typeof object.permitConvers[i] !== "object")
                        throw TypeError(".immessage.QryConversationsReq.permitConvers: object expected");
                    message.permitConvers[i] = $root.immessage.PermitConver.fromObject(object.permitConvers[i]);
                }
            }
            if (object.onlyConver != null)
                message.onlyConver = Boolean(object.onlyConver);
            return message;
        };

        /**
         * Creates a plain object from a QryConversationsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryConversationsReq
         * @static
         * @param {immessage.QryConversationsReq} message QryConversationsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryConversationsReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.permitConvers = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTime = options.longs === String ? "0" : 0;
                object.count = 0;
                object.order = 0;
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                object.tag = "";
                object.onlyConver = false;
            }
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (typeof message.startTime === "number")
                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                else
                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber() : message.startTime;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            if (message.order != null && message.hasOwnProperty("order"))
                object.order = message.order;
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.tag != null && message.hasOwnProperty("tag"))
                object.tag = message.tag;
            if (message.permitConvers && message.permitConvers.length) {
                object.permitConvers = [];
                for (let j = 0; j < message.permitConvers.length; ++j)
                    object.permitConvers[j] = $root.immessage.PermitConver.toObject(message.permitConvers[j], options);
            }
            if (message.onlyConver != null && message.hasOwnProperty("onlyConver"))
                object.onlyConver = message.onlyConver;
            return object;
        };

        /**
         * Converts this QryConversationsReq to JSON.
         * @function toJSON
         * @memberof immessage.QryConversationsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryConversationsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryConversationsReq
         * @function getTypeUrl
         * @memberof immessage.QryConversationsReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryConversationsReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryConversationsReq";
        };

        return QryConversationsReq;
    })();

    immessage.QryConversationsResp = (function() {

        /**
         * Properties of a QryConversationsResp.
         * @memberof immessage
         * @interface IQryConversationsResp
         * @property {Array.<immessage.IConversation>|null} [conversations] QryConversationsResp conversations
         * @property {boolean|null} [isFinished] QryConversationsResp isFinished
         */

        /**
         * Constructs a new QryConversationsResp.
         * @memberof immessage
         * @classdesc Represents a QryConversationsResp.
         * @implements IQryConversationsResp
         * @constructor
         * @param {immessage.IQryConversationsResp=} [properties] Properties to set
         */
        function QryConversationsResp(properties) {
            this.conversations = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryConversationsResp conversations.
         * @member {Array.<immessage.IConversation>} conversations
         * @memberof immessage.QryConversationsResp
         * @instance
         */
        QryConversationsResp.prototype.conversations = $util.emptyArray;

        /**
         * QryConversationsResp isFinished.
         * @member {boolean} isFinished
         * @memberof immessage.QryConversationsResp
         * @instance
         */
        QryConversationsResp.prototype.isFinished = false;

        /**
         * Creates a new QryConversationsResp instance using the specified properties.
         * @function create
         * @memberof immessage.QryConversationsResp
         * @static
         * @param {immessage.IQryConversationsResp=} [properties] Properties to set
         * @returns {immessage.QryConversationsResp} QryConversationsResp instance
         */
        QryConversationsResp.create = function create(properties) {
            return new QryConversationsResp(properties);
        };

        /**
         * Encodes the specified QryConversationsResp message. Does not implicitly {@link immessage.QryConversationsResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryConversationsResp
         * @static
         * @param {immessage.IQryConversationsResp} message QryConversationsResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryConversationsResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.conversations != null && message.conversations.length)
                for (let i = 0; i < message.conversations.length; ++i)
                    $root.immessage.Conversation.encode(message.conversations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.isFinished != null && Object.hasOwnProperty.call(message, "isFinished"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isFinished);
            return writer;
        };

        /**
         * Encodes the specified QryConversationsResp message, length delimited. Does not implicitly {@link immessage.QryConversationsResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryConversationsResp
         * @static
         * @param {immessage.IQryConversationsResp} message QryConversationsResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryConversationsResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryConversationsResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryConversationsResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryConversationsResp} QryConversationsResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryConversationsResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryConversationsResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.conversations && message.conversations.length))
                            message.conversations = [];
                        message.conversations.push($root.immessage.Conversation.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.isFinished = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryConversationsResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryConversationsResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryConversationsResp} QryConversationsResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryConversationsResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryConversationsResp message.
         * @function verify
         * @memberof immessage.QryConversationsResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryConversationsResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.conversations != null && message.hasOwnProperty("conversations")) {
                if (!Array.isArray(message.conversations))
                    return "conversations: array expected";
                for (let i = 0; i < message.conversations.length; ++i) {
                    let error = $root.immessage.Conversation.verify(message.conversations[i]);
                    if (error)
                        return "conversations." + error;
                }
            }
            if (message.isFinished != null && message.hasOwnProperty("isFinished"))
                if (typeof message.isFinished !== "boolean")
                    return "isFinished: boolean expected";
            return null;
        };

        /**
         * Creates a QryConversationsResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryConversationsResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryConversationsResp} QryConversationsResp
         */
        QryConversationsResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryConversationsResp)
                return object;
            let message = new $root.immessage.QryConversationsResp();
            if (object.conversations) {
                if (!Array.isArray(object.conversations))
                    throw TypeError(".immessage.QryConversationsResp.conversations: array expected");
                message.conversations = [];
                for (let i = 0; i < object.conversations.length; ++i) {
                    if (typeof object.conversations[i] !== "object")
                        throw TypeError(".immessage.QryConversationsResp.conversations: object expected");
                    message.conversations[i] = $root.immessage.Conversation.fromObject(object.conversations[i]);
                }
            }
            if (object.isFinished != null)
                message.isFinished = Boolean(object.isFinished);
            return message;
        };

        /**
         * Creates a plain object from a QryConversationsResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryConversationsResp
         * @static
         * @param {immessage.QryConversationsResp} message QryConversationsResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryConversationsResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.conversations = [];
            if (options.defaults)
                object.isFinished = false;
            if (message.conversations && message.conversations.length) {
                object.conversations = [];
                for (let j = 0; j < message.conversations.length; ++j)
                    object.conversations[j] = $root.immessage.Conversation.toObject(message.conversations[j], options);
            }
            if (message.isFinished != null && message.hasOwnProperty("isFinished"))
                object.isFinished = message.isFinished;
            return object;
        };

        /**
         * Converts this QryConversationsResp to JSON.
         * @function toJSON
         * @memberof immessage.QryConversationsResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryConversationsResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryConversationsResp
         * @function getTypeUrl
         * @memberof immessage.QryConversationsResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryConversationsResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryConversationsResp";
        };

        return QryConversationsResp;
    })();

    immessage.Conversation = (function() {

        /**
         * Properties of a Conversation.
         * @memberof immessage
         * @interface IConversation
         * @property {string|null} [userId] Conversation userId
         * @property {string|null} [targetId] Conversation targetId
         * @property {immessage.ChannelType|null} [channelType] Conversation channelType
         * @property {number|Long|null} [sortTime] Conversation sortTime
         * @property {number|Long|null} [unreadCount] Conversation unreadCount
         * @property {immessage.IDownMsg|null} [msg] Conversation msg
         * @property {number|Long|null} [latestReadIndex] Conversation latestReadIndex
         * @property {immessage.IMentions|null} [mentions] Conversation mentions
         * @property {number|null} [isTop] Conversation isTop
         * @property {number|Long|null} [topUpdatedTime] Conversation topUpdatedTime
         * @property {number|null} [undisturbType] Conversation undisturbType
         * @property {immessage.IUserInfo|null} [targetUserInfo] Conversation targetUserInfo
         * @property {immessage.IGroupInfo|null} [groupInfo] Conversation groupInfo
         * @property {number|Long|null} [syncTime] Conversation syncTime
         * @property {number|null} [isDelete] Conversation isDelete
         * @property {number|Long|null} [latestUnreadIndex] Conversation latestUnreadIndex
         * @property {number|null} [unreadTag] Conversation unreadTag
         * @property {string|null} [latestReadMsgId] Conversation latestReadMsgId
         * @property {number|Long|null} [latestReadMsgTime] Conversation latestReadMsgTime
         * @property {Array.<immessage.IConverTag>|null} [converTags] Conversation converTags
         */

        /**
         * Constructs a new Conversation.
         * @memberof immessage
         * @classdesc Represents a Conversation.
         * @implements IConversation
         * @constructor
         * @param {immessage.IConversation=} [properties] Properties to set
         */
        function Conversation(properties) {
            this.converTags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Conversation userId.
         * @member {string} userId
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.userId = "";

        /**
         * Conversation targetId.
         * @member {string} targetId
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.targetId = "";

        /**
         * Conversation channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.channelType = 0;

        /**
         * Conversation sortTime.
         * @member {number|Long} sortTime
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.sortTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Conversation unreadCount.
         * @member {number|Long} unreadCount
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.unreadCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Conversation msg.
         * @member {immessage.IDownMsg|null|undefined} msg
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.msg = null;

        /**
         * Conversation latestReadIndex.
         * @member {number|Long} latestReadIndex
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.latestReadIndex = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Conversation mentions.
         * @member {immessage.IMentions|null|undefined} mentions
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.mentions = null;

        /**
         * Conversation isTop.
         * @member {number} isTop
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.isTop = 0;

        /**
         * Conversation topUpdatedTime.
         * @member {number|Long} topUpdatedTime
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.topUpdatedTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Conversation undisturbType.
         * @member {number} undisturbType
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.undisturbType = 0;

        /**
         * Conversation targetUserInfo.
         * @member {immessage.IUserInfo|null|undefined} targetUserInfo
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.targetUserInfo = null;

        /**
         * Conversation groupInfo.
         * @member {immessage.IGroupInfo|null|undefined} groupInfo
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.groupInfo = null;

        /**
         * Conversation syncTime.
         * @member {number|Long} syncTime
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.syncTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Conversation isDelete.
         * @member {number} isDelete
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.isDelete = 0;

        /**
         * Conversation latestUnreadIndex.
         * @member {number|Long} latestUnreadIndex
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.latestUnreadIndex = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Conversation unreadTag.
         * @member {number} unreadTag
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.unreadTag = 0;

        /**
         * Conversation latestReadMsgId.
         * @member {string} latestReadMsgId
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.latestReadMsgId = "";

        /**
         * Conversation latestReadMsgTime.
         * @member {number|Long} latestReadMsgTime
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.latestReadMsgTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Conversation converTags.
         * @member {Array.<immessage.IConverTag>} converTags
         * @memberof immessage.Conversation
         * @instance
         */
        Conversation.prototype.converTags = $util.emptyArray;

        /**
         * Creates a new Conversation instance using the specified properties.
         * @function create
         * @memberof immessage.Conversation
         * @static
         * @param {immessage.IConversation=} [properties] Properties to set
         * @returns {immessage.Conversation} Conversation instance
         */
        Conversation.create = function create(properties) {
            return new Conversation(properties);
        };

        /**
         * Encodes the specified Conversation message. Does not implicitly {@link immessage.Conversation.verify|verify} messages.
         * @function encode
         * @memberof immessage.Conversation
         * @static
         * @param {immessage.IConversation} message Conversation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Conversation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.channelType);
            if (message.sortTime != null && Object.hasOwnProperty.call(message, "sortTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.sortTime);
            if (message.unreadCount != null && Object.hasOwnProperty.call(message, "unreadCount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.unreadCount);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                $root.immessage.DownMsg.encode(message.msg, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.latestReadIndex != null && Object.hasOwnProperty.call(message, "latestReadIndex"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.latestReadIndex);
            if (message.mentions != null && Object.hasOwnProperty.call(message, "mentions"))
                $root.immessage.Mentions.encode(message.mentions, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.isTop != null && Object.hasOwnProperty.call(message, "isTop"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.isTop);
            if (message.topUpdatedTime != null && Object.hasOwnProperty.call(message, "topUpdatedTime"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.topUpdatedTime);
            if (message.undisturbType != null && Object.hasOwnProperty.call(message, "undisturbType"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.undisturbType);
            if (message.targetUserInfo != null && Object.hasOwnProperty.call(message, "targetUserInfo"))
                $root.immessage.UserInfo.encode(message.targetUserInfo, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.groupInfo != null && Object.hasOwnProperty.call(message, "groupInfo"))
                $root.immessage.GroupInfo.encode(message.groupInfo, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.syncTime != null && Object.hasOwnProperty.call(message, "syncTime"))
                writer.uint32(/* id 14, wireType 0 =*/112).int64(message.syncTime);
            if (message.isDelete != null && Object.hasOwnProperty.call(message, "isDelete"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.isDelete);
            if (message.latestUnreadIndex != null && Object.hasOwnProperty.call(message, "latestUnreadIndex"))
                writer.uint32(/* id 16, wireType 0 =*/128).int64(message.latestUnreadIndex);
            if (message.unreadTag != null && Object.hasOwnProperty.call(message, "unreadTag"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.unreadTag);
            if (message.latestReadMsgId != null && Object.hasOwnProperty.call(message, "latestReadMsgId"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.latestReadMsgId);
            if (message.latestReadMsgTime != null && Object.hasOwnProperty.call(message, "latestReadMsgTime"))
                writer.uint32(/* id 19, wireType 0 =*/152).int64(message.latestReadMsgTime);
            if (message.converTags != null && message.converTags.length)
                for (let i = 0; i < message.converTags.length; ++i)
                    $root.immessage.ConverTag.encode(message.converTags[i], writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Conversation message, length delimited. Does not implicitly {@link immessage.Conversation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.Conversation
         * @static
         * @param {immessage.IConversation} message Conversation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Conversation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Conversation message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.Conversation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.Conversation} Conversation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Conversation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.Conversation();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.targetId = reader.string();
                        break;
                    }
                case 3: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 4: {
                        message.sortTime = reader.int64();
                        break;
                    }
                case 5: {
                        message.unreadCount = reader.int64();
                        break;
                    }
                case 6: {
                        message.msg = $root.immessage.DownMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.latestReadIndex = reader.int64();
                        break;
                    }
                case 8: {
                        message.mentions = $root.immessage.Mentions.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.isTop = reader.int32();
                        break;
                    }
                case 10: {
                        message.topUpdatedTime = reader.int64();
                        break;
                    }
                case 11: {
                        message.undisturbType = reader.int32();
                        break;
                    }
                case 12: {
                        message.targetUserInfo = $root.immessage.UserInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.groupInfo = $root.immessage.GroupInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.syncTime = reader.int64();
                        break;
                    }
                case 15: {
                        message.isDelete = reader.int32();
                        break;
                    }
                case 16: {
                        message.latestUnreadIndex = reader.int64();
                        break;
                    }
                case 17: {
                        message.unreadTag = reader.int32();
                        break;
                    }
                case 18: {
                        message.latestReadMsgId = reader.string();
                        break;
                    }
                case 19: {
                        message.latestReadMsgTime = reader.int64();
                        break;
                    }
                case 20: {
                        if (!(message.converTags && message.converTags.length))
                            message.converTags = [];
                        message.converTags.push($root.immessage.ConverTag.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Conversation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.Conversation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.Conversation} Conversation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Conversation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Conversation message.
         * @function verify
         * @memberof immessage.Conversation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Conversation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.sortTime != null && message.hasOwnProperty("sortTime"))
                if (!$util.isInteger(message.sortTime) && !(message.sortTime && $util.isInteger(message.sortTime.low) && $util.isInteger(message.sortTime.high)))
                    return "sortTime: integer|Long expected";
            if (message.unreadCount != null && message.hasOwnProperty("unreadCount"))
                if (!$util.isInteger(message.unreadCount) && !(message.unreadCount && $util.isInteger(message.unreadCount.low) && $util.isInteger(message.unreadCount.high)))
                    return "unreadCount: integer|Long expected";
            if (message.msg != null && message.hasOwnProperty("msg")) {
                let error = $root.immessage.DownMsg.verify(message.msg);
                if (error)
                    return "msg." + error;
            }
            if (message.latestReadIndex != null && message.hasOwnProperty("latestReadIndex"))
                if (!$util.isInteger(message.latestReadIndex) && !(message.latestReadIndex && $util.isInteger(message.latestReadIndex.low) && $util.isInteger(message.latestReadIndex.high)))
                    return "latestReadIndex: integer|Long expected";
            if (message.mentions != null && message.hasOwnProperty("mentions")) {
                let error = $root.immessage.Mentions.verify(message.mentions);
                if (error)
                    return "mentions." + error;
            }
            if (message.isTop != null && message.hasOwnProperty("isTop"))
                if (!$util.isInteger(message.isTop))
                    return "isTop: integer expected";
            if (message.topUpdatedTime != null && message.hasOwnProperty("topUpdatedTime"))
                if (!$util.isInteger(message.topUpdatedTime) && !(message.topUpdatedTime && $util.isInteger(message.topUpdatedTime.low) && $util.isInteger(message.topUpdatedTime.high)))
                    return "topUpdatedTime: integer|Long expected";
            if (message.undisturbType != null && message.hasOwnProperty("undisturbType"))
                if (!$util.isInteger(message.undisturbType))
                    return "undisturbType: integer expected";
            if (message.targetUserInfo != null && message.hasOwnProperty("targetUserInfo")) {
                let error = $root.immessage.UserInfo.verify(message.targetUserInfo);
                if (error)
                    return "targetUserInfo." + error;
            }
            if (message.groupInfo != null && message.hasOwnProperty("groupInfo")) {
                let error = $root.immessage.GroupInfo.verify(message.groupInfo);
                if (error)
                    return "groupInfo." + error;
            }
            if (message.syncTime != null && message.hasOwnProperty("syncTime"))
                if (!$util.isInteger(message.syncTime) && !(message.syncTime && $util.isInteger(message.syncTime.low) && $util.isInteger(message.syncTime.high)))
                    return "syncTime: integer|Long expected";
            if (message.isDelete != null && message.hasOwnProperty("isDelete"))
                if (!$util.isInteger(message.isDelete))
                    return "isDelete: integer expected";
            if (message.latestUnreadIndex != null && message.hasOwnProperty("latestUnreadIndex"))
                if (!$util.isInteger(message.latestUnreadIndex) && !(message.latestUnreadIndex && $util.isInteger(message.latestUnreadIndex.low) && $util.isInteger(message.latestUnreadIndex.high)))
                    return "latestUnreadIndex: integer|Long expected";
            if (message.unreadTag != null && message.hasOwnProperty("unreadTag"))
                if (!$util.isInteger(message.unreadTag))
                    return "unreadTag: integer expected";
            if (message.latestReadMsgId != null && message.hasOwnProperty("latestReadMsgId"))
                if (!$util.isString(message.latestReadMsgId))
                    return "latestReadMsgId: string expected";
            if (message.latestReadMsgTime != null && message.hasOwnProperty("latestReadMsgTime"))
                if (!$util.isInteger(message.latestReadMsgTime) && !(message.latestReadMsgTime && $util.isInteger(message.latestReadMsgTime.low) && $util.isInteger(message.latestReadMsgTime.high)))
                    return "latestReadMsgTime: integer|Long expected";
            if (message.converTags != null && message.hasOwnProperty("converTags")) {
                if (!Array.isArray(message.converTags))
                    return "converTags: array expected";
                for (let i = 0; i < message.converTags.length; ++i) {
                    let error = $root.immessage.ConverTag.verify(message.converTags[i]);
                    if (error)
                        return "converTags." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Conversation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.Conversation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.Conversation} Conversation
         */
        Conversation.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.Conversation)
                return object;
            let message = new $root.immessage.Conversation();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.sortTime != null)
                if ($util.Long)
                    (message.sortTime = $util.Long.fromValue(object.sortTime)).unsigned = false;
                else if (typeof object.sortTime === "string")
                    message.sortTime = parseInt(object.sortTime, 10);
                else if (typeof object.sortTime === "number")
                    message.sortTime = object.sortTime;
                else if (typeof object.sortTime === "object")
                    message.sortTime = new $util.LongBits(object.sortTime.low >>> 0, object.sortTime.high >>> 0).toNumber();
            if (object.unreadCount != null)
                if ($util.Long)
                    (message.unreadCount = $util.Long.fromValue(object.unreadCount)).unsigned = false;
                else if (typeof object.unreadCount === "string")
                    message.unreadCount = parseInt(object.unreadCount, 10);
                else if (typeof object.unreadCount === "number")
                    message.unreadCount = object.unreadCount;
                else if (typeof object.unreadCount === "object")
                    message.unreadCount = new $util.LongBits(object.unreadCount.low >>> 0, object.unreadCount.high >>> 0).toNumber();
            if (object.msg != null) {
                if (typeof object.msg !== "object")
                    throw TypeError(".immessage.Conversation.msg: object expected");
                message.msg = $root.immessage.DownMsg.fromObject(object.msg);
            }
            if (object.latestReadIndex != null)
                if ($util.Long)
                    (message.latestReadIndex = $util.Long.fromValue(object.latestReadIndex)).unsigned = false;
                else if (typeof object.latestReadIndex === "string")
                    message.latestReadIndex = parseInt(object.latestReadIndex, 10);
                else if (typeof object.latestReadIndex === "number")
                    message.latestReadIndex = object.latestReadIndex;
                else if (typeof object.latestReadIndex === "object")
                    message.latestReadIndex = new $util.LongBits(object.latestReadIndex.low >>> 0, object.latestReadIndex.high >>> 0).toNumber();
            if (object.mentions != null) {
                if (typeof object.mentions !== "object")
                    throw TypeError(".immessage.Conversation.mentions: object expected");
                message.mentions = $root.immessage.Mentions.fromObject(object.mentions);
            }
            if (object.isTop != null)
                message.isTop = object.isTop | 0;
            if (object.topUpdatedTime != null)
                if ($util.Long)
                    (message.topUpdatedTime = $util.Long.fromValue(object.topUpdatedTime)).unsigned = false;
                else if (typeof object.topUpdatedTime === "string")
                    message.topUpdatedTime = parseInt(object.topUpdatedTime, 10);
                else if (typeof object.topUpdatedTime === "number")
                    message.topUpdatedTime = object.topUpdatedTime;
                else if (typeof object.topUpdatedTime === "object")
                    message.topUpdatedTime = new $util.LongBits(object.topUpdatedTime.low >>> 0, object.topUpdatedTime.high >>> 0).toNumber();
            if (object.undisturbType != null)
                message.undisturbType = object.undisturbType | 0;
            if (object.targetUserInfo != null) {
                if (typeof object.targetUserInfo !== "object")
                    throw TypeError(".immessage.Conversation.targetUserInfo: object expected");
                message.targetUserInfo = $root.immessage.UserInfo.fromObject(object.targetUserInfo);
            }
            if (object.groupInfo != null) {
                if (typeof object.groupInfo !== "object")
                    throw TypeError(".immessage.Conversation.groupInfo: object expected");
                message.groupInfo = $root.immessage.GroupInfo.fromObject(object.groupInfo);
            }
            if (object.syncTime != null)
                if ($util.Long)
                    (message.syncTime = $util.Long.fromValue(object.syncTime)).unsigned = false;
                else if (typeof object.syncTime === "string")
                    message.syncTime = parseInt(object.syncTime, 10);
                else if (typeof object.syncTime === "number")
                    message.syncTime = object.syncTime;
                else if (typeof object.syncTime === "object")
                    message.syncTime = new $util.LongBits(object.syncTime.low >>> 0, object.syncTime.high >>> 0).toNumber();
            if (object.isDelete != null)
                message.isDelete = object.isDelete | 0;
            if (object.latestUnreadIndex != null)
                if ($util.Long)
                    (message.latestUnreadIndex = $util.Long.fromValue(object.latestUnreadIndex)).unsigned = false;
                else if (typeof object.latestUnreadIndex === "string")
                    message.latestUnreadIndex = parseInt(object.latestUnreadIndex, 10);
                else if (typeof object.latestUnreadIndex === "number")
                    message.latestUnreadIndex = object.latestUnreadIndex;
                else if (typeof object.latestUnreadIndex === "object")
                    message.latestUnreadIndex = new $util.LongBits(object.latestUnreadIndex.low >>> 0, object.latestUnreadIndex.high >>> 0).toNumber();
            if (object.unreadTag != null)
                message.unreadTag = object.unreadTag | 0;
            if (object.latestReadMsgId != null)
                message.latestReadMsgId = String(object.latestReadMsgId);
            if (object.latestReadMsgTime != null)
                if ($util.Long)
                    (message.latestReadMsgTime = $util.Long.fromValue(object.latestReadMsgTime)).unsigned = false;
                else if (typeof object.latestReadMsgTime === "string")
                    message.latestReadMsgTime = parseInt(object.latestReadMsgTime, 10);
                else if (typeof object.latestReadMsgTime === "number")
                    message.latestReadMsgTime = object.latestReadMsgTime;
                else if (typeof object.latestReadMsgTime === "object")
                    message.latestReadMsgTime = new $util.LongBits(object.latestReadMsgTime.low >>> 0, object.latestReadMsgTime.high >>> 0).toNumber();
            if (object.converTags) {
                if (!Array.isArray(object.converTags))
                    throw TypeError(".immessage.Conversation.converTags: array expected");
                message.converTags = [];
                for (let i = 0; i < object.converTags.length; ++i) {
                    if (typeof object.converTags[i] !== "object")
                        throw TypeError(".immessage.Conversation.converTags: object expected");
                    message.converTags[i] = $root.immessage.ConverTag.fromObject(object.converTags[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Conversation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.Conversation
         * @static
         * @param {immessage.Conversation} message Conversation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Conversation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.converTags = [];
            if (options.defaults) {
                object.userId = "";
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.sortTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sortTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.unreadCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.unreadCount = options.longs === String ? "0" : 0;
                object.msg = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.latestReadIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latestReadIndex = options.longs === String ? "0" : 0;
                object.mentions = null;
                object.isTop = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.topUpdatedTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.topUpdatedTime = options.longs === String ? "0" : 0;
                object.undisturbType = 0;
                object.targetUserInfo = null;
                object.groupInfo = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.syncTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.syncTime = options.longs === String ? "0" : 0;
                object.isDelete = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.latestUnreadIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latestUnreadIndex = options.longs === String ? "0" : 0;
                object.unreadTag = 0;
                object.latestReadMsgId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.latestReadMsgTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latestReadMsgTime = options.longs === String ? "0" : 0;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.sortTime != null && message.hasOwnProperty("sortTime"))
                if (typeof message.sortTime === "number")
                    object.sortTime = options.longs === String ? String(message.sortTime) : message.sortTime;
                else
                    object.sortTime = options.longs === String ? $util.Long.prototype.toString.call(message.sortTime) : options.longs === Number ? new $util.LongBits(message.sortTime.low >>> 0, message.sortTime.high >>> 0).toNumber() : message.sortTime;
            if (message.unreadCount != null && message.hasOwnProperty("unreadCount"))
                if (typeof message.unreadCount === "number")
                    object.unreadCount = options.longs === String ? String(message.unreadCount) : message.unreadCount;
                else
                    object.unreadCount = options.longs === String ? $util.Long.prototype.toString.call(message.unreadCount) : options.longs === Number ? new $util.LongBits(message.unreadCount.low >>> 0, message.unreadCount.high >>> 0).toNumber() : message.unreadCount;
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = $root.immessage.DownMsg.toObject(message.msg, options);
            if (message.latestReadIndex != null && message.hasOwnProperty("latestReadIndex"))
                if (typeof message.latestReadIndex === "number")
                    object.latestReadIndex = options.longs === String ? String(message.latestReadIndex) : message.latestReadIndex;
                else
                    object.latestReadIndex = options.longs === String ? $util.Long.prototype.toString.call(message.latestReadIndex) : options.longs === Number ? new $util.LongBits(message.latestReadIndex.low >>> 0, message.latestReadIndex.high >>> 0).toNumber() : message.latestReadIndex;
            if (message.mentions != null && message.hasOwnProperty("mentions"))
                object.mentions = $root.immessage.Mentions.toObject(message.mentions, options);
            if (message.isTop != null && message.hasOwnProperty("isTop"))
                object.isTop = message.isTop;
            if (message.topUpdatedTime != null && message.hasOwnProperty("topUpdatedTime"))
                if (typeof message.topUpdatedTime === "number")
                    object.topUpdatedTime = options.longs === String ? String(message.topUpdatedTime) : message.topUpdatedTime;
                else
                    object.topUpdatedTime = options.longs === String ? $util.Long.prototype.toString.call(message.topUpdatedTime) : options.longs === Number ? new $util.LongBits(message.topUpdatedTime.low >>> 0, message.topUpdatedTime.high >>> 0).toNumber() : message.topUpdatedTime;
            if (message.undisturbType != null && message.hasOwnProperty("undisturbType"))
                object.undisturbType = message.undisturbType;
            if (message.targetUserInfo != null && message.hasOwnProperty("targetUserInfo"))
                object.targetUserInfo = $root.immessage.UserInfo.toObject(message.targetUserInfo, options);
            if (message.groupInfo != null && message.hasOwnProperty("groupInfo"))
                object.groupInfo = $root.immessage.GroupInfo.toObject(message.groupInfo, options);
            if (message.syncTime != null && message.hasOwnProperty("syncTime"))
                if (typeof message.syncTime === "number")
                    object.syncTime = options.longs === String ? String(message.syncTime) : message.syncTime;
                else
                    object.syncTime = options.longs === String ? $util.Long.prototype.toString.call(message.syncTime) : options.longs === Number ? new $util.LongBits(message.syncTime.low >>> 0, message.syncTime.high >>> 0).toNumber() : message.syncTime;
            if (message.isDelete != null && message.hasOwnProperty("isDelete"))
                object.isDelete = message.isDelete;
            if (message.latestUnreadIndex != null && message.hasOwnProperty("latestUnreadIndex"))
                if (typeof message.latestUnreadIndex === "number")
                    object.latestUnreadIndex = options.longs === String ? String(message.latestUnreadIndex) : message.latestUnreadIndex;
                else
                    object.latestUnreadIndex = options.longs === String ? $util.Long.prototype.toString.call(message.latestUnreadIndex) : options.longs === Number ? new $util.LongBits(message.latestUnreadIndex.low >>> 0, message.latestUnreadIndex.high >>> 0).toNumber() : message.latestUnreadIndex;
            if (message.unreadTag != null && message.hasOwnProperty("unreadTag"))
                object.unreadTag = message.unreadTag;
            if (message.latestReadMsgId != null && message.hasOwnProperty("latestReadMsgId"))
                object.latestReadMsgId = message.latestReadMsgId;
            if (message.latestReadMsgTime != null && message.hasOwnProperty("latestReadMsgTime"))
                if (typeof message.latestReadMsgTime === "number")
                    object.latestReadMsgTime = options.longs === String ? String(message.latestReadMsgTime) : message.latestReadMsgTime;
                else
                    object.latestReadMsgTime = options.longs === String ? $util.Long.prototype.toString.call(message.latestReadMsgTime) : options.longs === Number ? new $util.LongBits(message.latestReadMsgTime.low >>> 0, message.latestReadMsgTime.high >>> 0).toNumber() : message.latestReadMsgTime;
            if (message.converTags && message.converTags.length) {
                object.converTags = [];
                for (let j = 0; j < message.converTags.length; ++j)
                    object.converTags[j] = $root.immessage.ConverTag.toObject(message.converTags[j], options);
            }
            return object;
        };

        /**
         * Converts this Conversation to JSON.
         * @function toJSON
         * @memberof immessage.Conversation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Conversation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Conversation
         * @function getTypeUrl
         * @memberof immessage.Conversation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Conversation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.Conversation";
        };

        return Conversation;
    })();

    immessage.BatchAddConvers = (function() {

        /**
         * Properties of a BatchAddConvers.
         * @memberof immessage
         * @interface IBatchAddConvers
         * @property {Array.<immessage.IConversation>|null} [convers] BatchAddConvers convers
         */

        /**
         * Constructs a new BatchAddConvers.
         * @memberof immessage
         * @classdesc Represents a BatchAddConvers.
         * @implements IBatchAddConvers
         * @constructor
         * @param {immessage.IBatchAddConvers=} [properties] Properties to set
         */
        function BatchAddConvers(properties) {
            this.convers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BatchAddConvers convers.
         * @member {Array.<immessage.IConversation>} convers
         * @memberof immessage.BatchAddConvers
         * @instance
         */
        BatchAddConvers.prototype.convers = $util.emptyArray;

        /**
         * Creates a new BatchAddConvers instance using the specified properties.
         * @function create
         * @memberof immessage.BatchAddConvers
         * @static
         * @param {immessage.IBatchAddConvers=} [properties] Properties to set
         * @returns {immessage.BatchAddConvers} BatchAddConvers instance
         */
        BatchAddConvers.create = function create(properties) {
            return new BatchAddConvers(properties);
        };

        /**
         * Encodes the specified BatchAddConvers message. Does not implicitly {@link immessage.BatchAddConvers.verify|verify} messages.
         * @function encode
         * @memberof immessage.BatchAddConvers
         * @static
         * @param {immessage.IBatchAddConvers} message BatchAddConvers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BatchAddConvers.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.convers != null && message.convers.length)
                for (let i = 0; i < message.convers.length; ++i)
                    $root.immessage.Conversation.encode(message.convers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BatchAddConvers message, length delimited. Does not implicitly {@link immessage.BatchAddConvers.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.BatchAddConvers
         * @static
         * @param {immessage.IBatchAddConvers} message BatchAddConvers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BatchAddConvers.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BatchAddConvers message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.BatchAddConvers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.BatchAddConvers} BatchAddConvers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BatchAddConvers.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.BatchAddConvers();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.convers && message.convers.length))
                            message.convers = [];
                        message.convers.push($root.immessage.Conversation.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BatchAddConvers message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.BatchAddConvers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.BatchAddConvers} BatchAddConvers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BatchAddConvers.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BatchAddConvers message.
         * @function verify
         * @memberof immessage.BatchAddConvers
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BatchAddConvers.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.convers != null && message.hasOwnProperty("convers")) {
                if (!Array.isArray(message.convers))
                    return "convers: array expected";
                for (let i = 0; i < message.convers.length; ++i) {
                    let error = $root.immessage.Conversation.verify(message.convers[i]);
                    if (error)
                        return "convers." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BatchAddConvers message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.BatchAddConvers
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.BatchAddConvers} BatchAddConvers
         */
        BatchAddConvers.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.BatchAddConvers)
                return object;
            let message = new $root.immessage.BatchAddConvers();
            if (object.convers) {
                if (!Array.isArray(object.convers))
                    throw TypeError(".immessage.BatchAddConvers.convers: array expected");
                message.convers = [];
                for (let i = 0; i < object.convers.length; ++i) {
                    if (typeof object.convers[i] !== "object")
                        throw TypeError(".immessage.BatchAddConvers.convers: object expected");
                    message.convers[i] = $root.immessage.Conversation.fromObject(object.convers[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BatchAddConvers message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.BatchAddConvers
         * @static
         * @param {immessage.BatchAddConvers} message BatchAddConvers
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BatchAddConvers.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.convers = [];
            if (message.convers && message.convers.length) {
                object.convers = [];
                for (let j = 0; j < message.convers.length; ++j)
                    object.convers[j] = $root.immessage.Conversation.toObject(message.convers[j], options);
            }
            return object;
        };

        /**
         * Converts this BatchAddConvers to JSON.
         * @function toJSON
         * @memberof immessage.BatchAddConvers
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BatchAddConvers.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BatchAddConvers
         * @function getTypeUrl
         * @memberof immessage.BatchAddConvers
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BatchAddConvers.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.BatchAddConvers";
        };

        return BatchAddConvers;
    })();

    immessage.UserMsgTimeItem = (function() {

        /**
         * Properties of a UserMsgTimeItem.
         * @memberof immessage
         * @interface IUserMsgTimeItem
         * @property {string|null} [userId] UserMsgTimeItem userId
         * @property {number|Long|null} [msgTime] UserMsgTimeItem msgTime
         */

        /**
         * Constructs a new UserMsgTimeItem.
         * @memberof immessage
         * @classdesc Represents a UserMsgTimeItem.
         * @implements IUserMsgTimeItem
         * @constructor
         * @param {immessage.IUserMsgTimeItem=} [properties] Properties to set
         */
        function UserMsgTimeItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserMsgTimeItem userId.
         * @member {string} userId
         * @memberof immessage.UserMsgTimeItem
         * @instance
         */
        UserMsgTimeItem.prototype.userId = "";

        /**
         * UserMsgTimeItem msgTime.
         * @member {number|Long} msgTime
         * @memberof immessage.UserMsgTimeItem
         * @instance
         */
        UserMsgTimeItem.prototype.msgTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UserMsgTimeItem instance using the specified properties.
         * @function create
         * @memberof immessage.UserMsgTimeItem
         * @static
         * @param {immessage.IUserMsgTimeItem=} [properties] Properties to set
         * @returns {immessage.UserMsgTimeItem} UserMsgTimeItem instance
         */
        UserMsgTimeItem.create = function create(properties) {
            return new UserMsgTimeItem(properties);
        };

        /**
         * Encodes the specified UserMsgTimeItem message. Does not implicitly {@link immessage.UserMsgTimeItem.verify|verify} messages.
         * @function encode
         * @memberof immessage.UserMsgTimeItem
         * @static
         * @param {immessage.IUserMsgTimeItem} message UserMsgTimeItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserMsgTimeItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.msgTime != null && Object.hasOwnProperty.call(message, "msgTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.msgTime);
            return writer;
        };

        /**
         * Encodes the specified UserMsgTimeItem message, length delimited. Does not implicitly {@link immessage.UserMsgTimeItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UserMsgTimeItem
         * @static
         * @param {immessage.IUserMsgTimeItem} message UserMsgTimeItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserMsgTimeItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserMsgTimeItem message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UserMsgTimeItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UserMsgTimeItem} UserMsgTimeItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserMsgTimeItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UserMsgTimeItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.msgTime = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserMsgTimeItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UserMsgTimeItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UserMsgTimeItem} UserMsgTimeItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserMsgTimeItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserMsgTimeItem message.
         * @function verify
         * @memberof immessage.UserMsgTimeItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserMsgTimeItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (!$util.isInteger(message.msgTime) && !(message.msgTime && $util.isInteger(message.msgTime.low) && $util.isInteger(message.msgTime.high)))
                    return "msgTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a UserMsgTimeItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UserMsgTimeItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UserMsgTimeItem} UserMsgTimeItem
         */
        UserMsgTimeItem.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UserMsgTimeItem)
                return object;
            let message = new $root.immessage.UserMsgTimeItem();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.msgTime != null)
                if ($util.Long)
                    (message.msgTime = $util.Long.fromValue(object.msgTime)).unsigned = false;
                else if (typeof object.msgTime === "string")
                    message.msgTime = parseInt(object.msgTime, 10);
                else if (typeof object.msgTime === "number")
                    message.msgTime = object.msgTime;
                else if (typeof object.msgTime === "object")
                    message.msgTime = new $util.LongBits(object.msgTime.low >>> 0, object.msgTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a UserMsgTimeItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UserMsgTimeItem
         * @static
         * @param {immessage.UserMsgTimeItem} message UserMsgTimeItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserMsgTimeItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.msgTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msgTime = options.longs === String ? "0" : 0;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (typeof message.msgTime === "number")
                    object.msgTime = options.longs === String ? String(message.msgTime) : message.msgTime;
                else
                    object.msgTime = options.longs === String ? $util.Long.prototype.toString.call(message.msgTime) : options.longs === Number ? new $util.LongBits(message.msgTime.low >>> 0, message.msgTime.high >>> 0).toNumber() : message.msgTime;
            return object;
        };

        /**
         * Converts this UserMsgTimeItem to JSON.
         * @function toJSON
         * @memberof immessage.UserMsgTimeItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserMsgTimeItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserMsgTimeItem
         * @function getTypeUrl
         * @memberof immessage.UserMsgTimeItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserMsgTimeItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UserMsgTimeItem";
        };

        return UserMsgTimeItem;
    })();

    /**
     * UpdLatestMsgAction enum.
     * @name immessage.UpdLatestMsgAction
     * @enum {number}
     * @property {number} UpdMsg=0 UpdMsg value
     * @property {number} UpdRead=1 UpdRead value
     */
    immessage.UpdLatestMsgAction = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UpdMsg"] = 0;
        values[valuesById[1] = "UpdRead"] = 1;
        return values;
    })();

    immessage.UpdLatestMsgReq = (function() {

        /**
         * Properties of an UpdLatestMsgReq.
         * @memberof immessage
         * @interface IUpdLatestMsgReq
         * @property {string|null} [targetId] UpdLatestMsgReq targetId
         * @property {immessage.ChannelType|null} [channelType] UpdLatestMsgReq channelType
         * @property {string|null} [latestMsgId] UpdLatestMsgReq latestMsgId
         * @property {immessage.UpdLatestMsgAction|null} [action] UpdLatestMsgReq action
         * @property {immessage.IDownMsg|null} [msg] UpdLatestMsgReq msg
         * @property {boolean|null} [isRead] UpdLatestMsgReq isRead
         */

        /**
         * Constructs a new UpdLatestMsgReq.
         * @memberof immessage
         * @classdesc Represents an UpdLatestMsgReq.
         * @implements IUpdLatestMsgReq
         * @constructor
         * @param {immessage.IUpdLatestMsgReq=} [properties] Properties to set
         */
        function UpdLatestMsgReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdLatestMsgReq targetId.
         * @member {string} targetId
         * @memberof immessage.UpdLatestMsgReq
         * @instance
         */
        UpdLatestMsgReq.prototype.targetId = "";

        /**
         * UpdLatestMsgReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.UpdLatestMsgReq
         * @instance
         */
        UpdLatestMsgReq.prototype.channelType = 0;

        /**
         * UpdLatestMsgReq latestMsgId.
         * @member {string} latestMsgId
         * @memberof immessage.UpdLatestMsgReq
         * @instance
         */
        UpdLatestMsgReq.prototype.latestMsgId = "";

        /**
         * UpdLatestMsgReq action.
         * @member {immessage.UpdLatestMsgAction} action
         * @memberof immessage.UpdLatestMsgReq
         * @instance
         */
        UpdLatestMsgReq.prototype.action = 0;

        /**
         * UpdLatestMsgReq msg.
         * @member {immessage.IDownMsg|null|undefined} msg
         * @memberof immessage.UpdLatestMsgReq
         * @instance
         */
        UpdLatestMsgReq.prototype.msg = null;

        /**
         * UpdLatestMsgReq isRead.
         * @member {boolean} isRead
         * @memberof immessage.UpdLatestMsgReq
         * @instance
         */
        UpdLatestMsgReq.prototype.isRead = false;

        /**
         * Creates a new UpdLatestMsgReq instance using the specified properties.
         * @function create
         * @memberof immessage.UpdLatestMsgReq
         * @static
         * @param {immessage.IUpdLatestMsgReq=} [properties] Properties to set
         * @returns {immessage.UpdLatestMsgReq} UpdLatestMsgReq instance
         */
        UpdLatestMsgReq.create = function create(properties) {
            return new UpdLatestMsgReq(properties);
        };

        /**
         * Encodes the specified UpdLatestMsgReq message. Does not implicitly {@link immessage.UpdLatestMsgReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.UpdLatestMsgReq
         * @static
         * @param {immessage.IUpdLatestMsgReq} message UpdLatestMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdLatestMsgReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.latestMsgId != null && Object.hasOwnProperty.call(message, "latestMsgId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.latestMsgId);
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.action);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                $root.immessage.DownMsg.encode(message.msg, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.isRead != null && Object.hasOwnProperty.call(message, "isRead"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isRead);
            return writer;
        };

        /**
         * Encodes the specified UpdLatestMsgReq message, length delimited. Does not implicitly {@link immessage.UpdLatestMsgReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UpdLatestMsgReq
         * @static
         * @param {immessage.IUpdLatestMsgReq} message UpdLatestMsgReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdLatestMsgReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdLatestMsgReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UpdLatestMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UpdLatestMsgReq} UpdLatestMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdLatestMsgReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UpdLatestMsgReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        message.latestMsgId = reader.string();
                        break;
                    }
                case 4: {
                        message.action = reader.int32();
                        break;
                    }
                case 5: {
                        message.msg = $root.immessage.DownMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.isRead = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdLatestMsgReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UpdLatestMsgReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UpdLatestMsgReq} UpdLatestMsgReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdLatestMsgReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdLatestMsgReq message.
         * @function verify
         * @memberof immessage.UpdLatestMsgReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdLatestMsgReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.latestMsgId != null && message.hasOwnProperty("latestMsgId"))
                if (!$util.isString(message.latestMsgId))
                    return "latestMsgId: string expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.msg != null && message.hasOwnProperty("msg")) {
                let error = $root.immessage.DownMsg.verify(message.msg);
                if (error)
                    return "msg." + error;
            }
            if (message.isRead != null && message.hasOwnProperty("isRead"))
                if (typeof message.isRead !== "boolean")
                    return "isRead: boolean expected";
            return null;
        };

        /**
         * Creates an UpdLatestMsgReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UpdLatestMsgReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UpdLatestMsgReq} UpdLatestMsgReq
         */
        UpdLatestMsgReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UpdLatestMsgReq)
                return object;
            let message = new $root.immessage.UpdLatestMsgReq();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.latestMsgId != null)
                message.latestMsgId = String(object.latestMsgId);
            switch (object.action) {
            default:
                if (typeof object.action === "number") {
                    message.action = object.action;
                    break;
                }
                break;
            case "UpdMsg":
            case 0:
                message.action = 0;
                break;
            case "UpdRead":
            case 1:
                message.action = 1;
                break;
            }
            if (object.msg != null) {
                if (typeof object.msg !== "object")
                    throw TypeError(".immessage.UpdLatestMsgReq.msg: object expected");
                message.msg = $root.immessage.DownMsg.fromObject(object.msg);
            }
            if (object.isRead != null)
                message.isRead = Boolean(object.isRead);
            return message;
        };

        /**
         * Creates a plain object from an UpdLatestMsgReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UpdLatestMsgReq
         * @static
         * @param {immessage.UpdLatestMsgReq} message UpdLatestMsgReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdLatestMsgReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                object.latestMsgId = "";
                object.action = options.enums === String ? "UpdMsg" : 0;
                object.msg = null;
                object.isRead = false;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.latestMsgId != null && message.hasOwnProperty("latestMsgId"))
                object.latestMsgId = message.latestMsgId;
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.immessage.UpdLatestMsgAction[message.action] === undefined ? message.action : $root.immessage.UpdLatestMsgAction[message.action] : message.action;
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = $root.immessage.DownMsg.toObject(message.msg, options);
            if (message.isRead != null && message.hasOwnProperty("isRead"))
                object.isRead = message.isRead;
            return object;
        };

        /**
         * Converts this UpdLatestMsgReq to JSON.
         * @function toJSON
         * @memberof immessage.UpdLatestMsgReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdLatestMsgReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UpdLatestMsgReq
         * @function getTypeUrl
         * @memberof immessage.UpdLatestMsgReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UpdLatestMsgReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UpdLatestMsgReq";
        };

        return UpdLatestMsgReq;
    })();

    immessage.Mentions = (function() {

        /**
         * Properties of a Mentions.
         * @memberof immessage
         * @interface IMentions
         * @property {boolean|null} [isMentioned] Mentions isMentioned
         * @property {number|null} [mentionMsgCount] Mentions mentionMsgCount
         * @property {Array.<immessage.IUserInfo>|null} [senders] Mentions senders
         * @property {Array.<immessage.IMentionMsg>|null} [mentionMsgs] Mentions mentionMsgs
         */

        /**
         * Constructs a new Mentions.
         * @memberof immessage
         * @classdesc Represents a Mentions.
         * @implements IMentions
         * @constructor
         * @param {immessage.IMentions=} [properties] Properties to set
         */
        function Mentions(properties) {
            this.senders = [];
            this.mentionMsgs = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Mentions isMentioned.
         * @member {boolean} isMentioned
         * @memberof immessage.Mentions
         * @instance
         */
        Mentions.prototype.isMentioned = false;

        /**
         * Mentions mentionMsgCount.
         * @member {number} mentionMsgCount
         * @memberof immessage.Mentions
         * @instance
         */
        Mentions.prototype.mentionMsgCount = 0;

        /**
         * Mentions senders.
         * @member {Array.<immessage.IUserInfo>} senders
         * @memberof immessage.Mentions
         * @instance
         */
        Mentions.prototype.senders = $util.emptyArray;

        /**
         * Mentions mentionMsgs.
         * @member {Array.<immessage.IMentionMsg>} mentionMsgs
         * @memberof immessage.Mentions
         * @instance
         */
        Mentions.prototype.mentionMsgs = $util.emptyArray;

        /**
         * Creates a new Mentions instance using the specified properties.
         * @function create
         * @memberof immessage.Mentions
         * @static
         * @param {immessage.IMentions=} [properties] Properties to set
         * @returns {immessage.Mentions} Mentions instance
         */
        Mentions.create = function create(properties) {
            return new Mentions(properties);
        };

        /**
         * Encodes the specified Mentions message. Does not implicitly {@link immessage.Mentions.verify|verify} messages.
         * @function encode
         * @memberof immessage.Mentions
         * @static
         * @param {immessage.IMentions} message Mentions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Mentions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isMentioned != null && Object.hasOwnProperty.call(message, "isMentioned"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isMentioned);
            if (message.mentionMsgCount != null && Object.hasOwnProperty.call(message, "mentionMsgCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mentionMsgCount);
            if (message.senders != null && message.senders.length)
                for (let i = 0; i < message.senders.length; ++i)
                    $root.immessage.UserInfo.encode(message.senders[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.mentionMsgs != null && message.mentionMsgs.length)
                for (let i = 0; i < message.mentionMsgs.length; ++i)
                    $root.immessage.MentionMsg.encode(message.mentionMsgs[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Mentions message, length delimited. Does not implicitly {@link immessage.Mentions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.Mentions
         * @static
         * @param {immessage.IMentions} message Mentions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Mentions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Mentions message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.Mentions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.Mentions} Mentions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Mentions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.Mentions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.isMentioned = reader.bool();
                        break;
                    }
                case 2: {
                        message.mentionMsgCount = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.senders && message.senders.length))
                            message.senders = [];
                        message.senders.push($root.immessage.UserInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (!(message.mentionMsgs && message.mentionMsgs.length))
                            message.mentionMsgs = [];
                        message.mentionMsgs.push($root.immessage.MentionMsg.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Mentions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.Mentions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.Mentions} Mentions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Mentions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Mentions message.
         * @function verify
         * @memberof immessage.Mentions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Mentions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isMentioned != null && message.hasOwnProperty("isMentioned"))
                if (typeof message.isMentioned !== "boolean")
                    return "isMentioned: boolean expected";
            if (message.mentionMsgCount != null && message.hasOwnProperty("mentionMsgCount"))
                if (!$util.isInteger(message.mentionMsgCount))
                    return "mentionMsgCount: integer expected";
            if (message.senders != null && message.hasOwnProperty("senders")) {
                if (!Array.isArray(message.senders))
                    return "senders: array expected";
                for (let i = 0; i < message.senders.length; ++i) {
                    let error = $root.immessage.UserInfo.verify(message.senders[i]);
                    if (error)
                        return "senders." + error;
                }
            }
            if (message.mentionMsgs != null && message.hasOwnProperty("mentionMsgs")) {
                if (!Array.isArray(message.mentionMsgs))
                    return "mentionMsgs: array expected";
                for (let i = 0; i < message.mentionMsgs.length; ++i) {
                    let error = $root.immessage.MentionMsg.verify(message.mentionMsgs[i]);
                    if (error)
                        return "mentionMsgs." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Mentions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.Mentions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.Mentions} Mentions
         */
        Mentions.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.Mentions)
                return object;
            let message = new $root.immessage.Mentions();
            if (object.isMentioned != null)
                message.isMentioned = Boolean(object.isMentioned);
            if (object.mentionMsgCount != null)
                message.mentionMsgCount = object.mentionMsgCount | 0;
            if (object.senders) {
                if (!Array.isArray(object.senders))
                    throw TypeError(".immessage.Mentions.senders: array expected");
                message.senders = [];
                for (let i = 0; i < object.senders.length; ++i) {
                    if (typeof object.senders[i] !== "object")
                        throw TypeError(".immessage.Mentions.senders: object expected");
                    message.senders[i] = $root.immessage.UserInfo.fromObject(object.senders[i]);
                }
            }
            if (object.mentionMsgs) {
                if (!Array.isArray(object.mentionMsgs))
                    throw TypeError(".immessage.Mentions.mentionMsgs: array expected");
                message.mentionMsgs = [];
                for (let i = 0; i < object.mentionMsgs.length; ++i) {
                    if (typeof object.mentionMsgs[i] !== "object")
                        throw TypeError(".immessage.Mentions.mentionMsgs: object expected");
                    message.mentionMsgs[i] = $root.immessage.MentionMsg.fromObject(object.mentionMsgs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Mentions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.Mentions
         * @static
         * @param {immessage.Mentions} message Mentions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Mentions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.senders = [];
                object.mentionMsgs = [];
            }
            if (options.defaults) {
                object.isMentioned = false;
                object.mentionMsgCount = 0;
            }
            if (message.isMentioned != null && message.hasOwnProperty("isMentioned"))
                object.isMentioned = message.isMentioned;
            if (message.mentionMsgCount != null && message.hasOwnProperty("mentionMsgCount"))
                object.mentionMsgCount = message.mentionMsgCount;
            if (message.senders && message.senders.length) {
                object.senders = [];
                for (let j = 0; j < message.senders.length; ++j)
                    object.senders[j] = $root.immessage.UserInfo.toObject(message.senders[j], options);
            }
            if (message.mentionMsgs && message.mentionMsgs.length) {
                object.mentionMsgs = [];
                for (let j = 0; j < message.mentionMsgs.length; ++j)
                    object.mentionMsgs[j] = $root.immessage.MentionMsg.toObject(message.mentionMsgs[j], options);
            }
            return object;
        };

        /**
         * Converts this Mentions to JSON.
         * @function toJSON
         * @memberof immessage.Mentions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Mentions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Mentions
         * @function getTypeUrl
         * @memberof immessage.Mentions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Mentions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.Mentions";
        };

        return Mentions;
    })();

    immessage.MentionMsg = (function() {

        /**
         * Properties of a MentionMsg.
         * @memberof immessage
         * @interface IMentionMsg
         * @property {string|null} [senderId] MentionMsg senderId
         * @property {string|null} [msgId] MentionMsg msgId
         * @property {number|Long|null} [msgTime] MentionMsg msgTime
         * @property {immessage.MentionType|null} [mentionType] MentionMsg mentionType
         */

        /**
         * Constructs a new MentionMsg.
         * @memberof immessage
         * @classdesc Represents a MentionMsg.
         * @implements IMentionMsg
         * @constructor
         * @param {immessage.IMentionMsg=} [properties] Properties to set
         */
        function MentionMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MentionMsg senderId.
         * @member {string} senderId
         * @memberof immessage.MentionMsg
         * @instance
         */
        MentionMsg.prototype.senderId = "";

        /**
         * MentionMsg msgId.
         * @member {string} msgId
         * @memberof immessage.MentionMsg
         * @instance
         */
        MentionMsg.prototype.msgId = "";

        /**
         * MentionMsg msgTime.
         * @member {number|Long} msgTime
         * @memberof immessage.MentionMsg
         * @instance
         */
        MentionMsg.prototype.msgTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MentionMsg mentionType.
         * @member {immessage.MentionType} mentionType
         * @memberof immessage.MentionMsg
         * @instance
         */
        MentionMsg.prototype.mentionType = 0;

        /**
         * Creates a new MentionMsg instance using the specified properties.
         * @function create
         * @memberof immessage.MentionMsg
         * @static
         * @param {immessage.IMentionMsg=} [properties] Properties to set
         * @returns {immessage.MentionMsg} MentionMsg instance
         */
        MentionMsg.create = function create(properties) {
            return new MentionMsg(properties);
        };

        /**
         * Encodes the specified MentionMsg message. Does not implicitly {@link immessage.MentionMsg.verify|verify} messages.
         * @function encode
         * @memberof immessage.MentionMsg
         * @static
         * @param {immessage.IMentionMsg} message MentionMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MentionMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.senderId != null && Object.hasOwnProperty.call(message, "senderId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.senderId);
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.msgId);
            if (message.msgTime != null && Object.hasOwnProperty.call(message, "msgTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.msgTime);
            if (message.mentionType != null && Object.hasOwnProperty.call(message, "mentionType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.mentionType);
            return writer;
        };

        /**
         * Encodes the specified MentionMsg message, length delimited. Does not implicitly {@link immessage.MentionMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.MentionMsg
         * @static
         * @param {immessage.IMentionMsg} message MentionMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MentionMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MentionMsg message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.MentionMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.MentionMsg} MentionMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MentionMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.MentionMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.senderId = reader.string();
                        break;
                    }
                case 2: {
                        message.msgId = reader.string();
                        break;
                    }
                case 3: {
                        message.msgTime = reader.int64();
                        break;
                    }
                case 4: {
                        message.mentionType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MentionMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.MentionMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.MentionMsg} MentionMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MentionMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MentionMsg message.
         * @function verify
         * @memberof immessage.MentionMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MentionMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.senderId != null && message.hasOwnProperty("senderId"))
                if (!$util.isString(message.senderId))
                    return "senderId: string expected";
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (!$util.isInteger(message.msgTime) && !(message.msgTime && $util.isInteger(message.msgTime.low) && $util.isInteger(message.msgTime.high)))
                    return "msgTime: integer|Long expected";
            if (message.mentionType != null && message.hasOwnProperty("mentionType"))
                switch (message.mentionType) {
                default:
                    return "mentionType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a MentionMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.MentionMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.MentionMsg} MentionMsg
         */
        MentionMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.MentionMsg)
                return object;
            let message = new $root.immessage.MentionMsg();
            if (object.senderId != null)
                message.senderId = String(object.senderId);
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            if (object.msgTime != null)
                if ($util.Long)
                    (message.msgTime = $util.Long.fromValue(object.msgTime)).unsigned = false;
                else if (typeof object.msgTime === "string")
                    message.msgTime = parseInt(object.msgTime, 10);
                else if (typeof object.msgTime === "number")
                    message.msgTime = object.msgTime;
                else if (typeof object.msgTime === "object")
                    message.msgTime = new $util.LongBits(object.msgTime.low >>> 0, object.msgTime.high >>> 0).toNumber();
            switch (object.mentionType) {
            default:
                if (typeof object.mentionType === "number") {
                    message.mentionType = object.mentionType;
                    break;
                }
                break;
            case "MentionDefault":
            case 0:
                message.mentionType = 0;
                break;
            case "All":
            case 1:
                message.mentionType = 1;
                break;
            case "Someone":
            case 2:
                message.mentionType = 2;
                break;
            case "AllAndSomeone":
            case 3:
                message.mentionType = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a MentionMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.MentionMsg
         * @static
         * @param {immessage.MentionMsg} message MentionMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MentionMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.senderId = "";
                object.msgId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.msgTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msgTime = options.longs === String ? "0" : 0;
                object.mentionType = options.enums === String ? "MentionDefault" : 0;
            }
            if (message.senderId != null && message.hasOwnProperty("senderId"))
                object.senderId = message.senderId;
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                if (typeof message.msgTime === "number")
                    object.msgTime = options.longs === String ? String(message.msgTime) : message.msgTime;
                else
                    object.msgTime = options.longs === String ? $util.Long.prototype.toString.call(message.msgTime) : options.longs === Number ? new $util.LongBits(message.msgTime.low >>> 0, message.msgTime.high >>> 0).toNumber() : message.msgTime;
            if (message.mentionType != null && message.hasOwnProperty("mentionType"))
                object.mentionType = options.enums === String ? $root.immessage.MentionType[message.mentionType] === undefined ? message.mentionType : $root.immessage.MentionType[message.mentionType] : message.mentionType;
            return object;
        };

        /**
         * Converts this MentionMsg to JSON.
         * @function toJSON
         * @memberof immessage.MentionMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MentionMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MentionMsg
         * @function getTypeUrl
         * @memberof immessage.MentionMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MentionMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.MentionMsg";
        };

        return MentionMsg;
    })();

    immessage.QryMentionMsgsReq = (function() {

        /**
         * Properties of a QryMentionMsgsReq.
         * @memberof immessage
         * @interface IQryMentionMsgsReq
         * @property {string|null} [targetId] QryMentionMsgsReq targetId
         * @property {immessage.ChannelType|null} [channelType] QryMentionMsgsReq channelType
         * @property {number|Long|null} [startTime] QryMentionMsgsReq startTime
         * @property {number|null} [count] QryMentionMsgsReq count
         * @property {number|null} [order] QryMentionMsgsReq order
         * @property {number|Long|null} [latestReadIndex] QryMentionMsgsReq latestReadIndex
         * @property {number|null} [maxHisMsgCount] QryMentionMsgsReq maxHisMsgCount
         * @property {string|null} [targetIdAlias] QryMentionMsgsReq targetIdAlias
         */

        /**
         * Constructs a new QryMentionMsgsReq.
         * @memberof immessage
         * @classdesc Represents a QryMentionMsgsReq.
         * @implements IQryMentionMsgsReq
         * @constructor
         * @param {immessage.IQryMentionMsgsReq=} [properties] Properties to set
         */
        function QryMentionMsgsReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryMentionMsgsReq targetId.
         * @member {string} targetId
         * @memberof immessage.QryMentionMsgsReq
         * @instance
         */
        QryMentionMsgsReq.prototype.targetId = "";

        /**
         * QryMentionMsgsReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.QryMentionMsgsReq
         * @instance
         */
        QryMentionMsgsReq.prototype.channelType = 0;

        /**
         * QryMentionMsgsReq startTime.
         * @member {number|Long} startTime
         * @memberof immessage.QryMentionMsgsReq
         * @instance
         */
        QryMentionMsgsReq.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QryMentionMsgsReq count.
         * @member {number} count
         * @memberof immessage.QryMentionMsgsReq
         * @instance
         */
        QryMentionMsgsReq.prototype.count = 0;

        /**
         * QryMentionMsgsReq order.
         * @member {number} order
         * @memberof immessage.QryMentionMsgsReq
         * @instance
         */
        QryMentionMsgsReq.prototype.order = 0;

        /**
         * QryMentionMsgsReq latestReadIndex.
         * @member {number|Long} latestReadIndex
         * @memberof immessage.QryMentionMsgsReq
         * @instance
         */
        QryMentionMsgsReq.prototype.latestReadIndex = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QryMentionMsgsReq maxHisMsgCount.
         * @member {number} maxHisMsgCount
         * @memberof immessage.QryMentionMsgsReq
         * @instance
         */
        QryMentionMsgsReq.prototype.maxHisMsgCount = 0;

        /**
         * QryMentionMsgsReq targetIdAlias.
         * @member {string} targetIdAlias
         * @memberof immessage.QryMentionMsgsReq
         * @instance
         */
        QryMentionMsgsReq.prototype.targetIdAlias = "";

        /**
         * Creates a new QryMentionMsgsReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryMentionMsgsReq
         * @static
         * @param {immessage.IQryMentionMsgsReq=} [properties] Properties to set
         * @returns {immessage.QryMentionMsgsReq} QryMentionMsgsReq instance
         */
        QryMentionMsgsReq.create = function create(properties) {
            return new QryMentionMsgsReq(properties);
        };

        /**
         * Encodes the specified QryMentionMsgsReq message. Does not implicitly {@link immessage.QryMentionMsgsReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryMentionMsgsReq
         * @static
         * @param {immessage.IQryMentionMsgsReq} message QryMentionMsgsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryMentionMsgsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.startTime);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.count);
            if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.order);
            if (message.latestReadIndex != null && Object.hasOwnProperty.call(message, "latestReadIndex"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.latestReadIndex);
            if (message.maxHisMsgCount != null && Object.hasOwnProperty.call(message, "maxHisMsgCount"))
                writer.uint32(/* id 51, wireType 0 =*/408).int32(message.maxHisMsgCount);
            if (message.targetIdAlias != null && Object.hasOwnProperty.call(message, "targetIdAlias"))
                writer.uint32(/* id 52, wireType 2 =*/418).string(message.targetIdAlias);
            return writer;
        };

        /**
         * Encodes the specified QryMentionMsgsReq message, length delimited. Does not implicitly {@link immessage.QryMentionMsgsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryMentionMsgsReq
         * @static
         * @param {immessage.IQryMentionMsgsReq} message QryMentionMsgsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryMentionMsgsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryMentionMsgsReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryMentionMsgsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryMentionMsgsReq} QryMentionMsgsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryMentionMsgsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryMentionMsgsReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        message.startTime = reader.int64();
                        break;
                    }
                case 4: {
                        message.count = reader.int32();
                        break;
                    }
                case 5: {
                        message.order = reader.int32();
                        break;
                    }
                case 6: {
                        message.latestReadIndex = reader.int64();
                        break;
                    }
                case 51: {
                        message.maxHisMsgCount = reader.int32();
                        break;
                    }
                case 52: {
                        message.targetIdAlias = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryMentionMsgsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryMentionMsgsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryMentionMsgsReq} QryMentionMsgsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryMentionMsgsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryMentionMsgsReq message.
         * @function verify
         * @memberof immessage.QryMentionMsgsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryMentionMsgsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            if (message.order != null && message.hasOwnProperty("order"))
                if (!$util.isInteger(message.order))
                    return "order: integer expected";
            if (message.latestReadIndex != null && message.hasOwnProperty("latestReadIndex"))
                if (!$util.isInteger(message.latestReadIndex) && !(message.latestReadIndex && $util.isInteger(message.latestReadIndex.low) && $util.isInteger(message.latestReadIndex.high)))
                    return "latestReadIndex: integer|Long expected";
            if (message.maxHisMsgCount != null && message.hasOwnProperty("maxHisMsgCount"))
                if (!$util.isInteger(message.maxHisMsgCount))
                    return "maxHisMsgCount: integer expected";
            if (message.targetIdAlias != null && message.hasOwnProperty("targetIdAlias"))
                if (!$util.isString(message.targetIdAlias))
                    return "targetIdAlias: string expected";
            return null;
        };

        /**
         * Creates a QryMentionMsgsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryMentionMsgsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryMentionMsgsReq} QryMentionMsgsReq
         */
        QryMentionMsgsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryMentionMsgsReq)
                return object;
            let message = new $root.immessage.QryMentionMsgsReq();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = false;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber();
            if (object.count != null)
                message.count = object.count | 0;
            if (object.order != null)
                message.order = object.order | 0;
            if (object.latestReadIndex != null)
                if ($util.Long)
                    (message.latestReadIndex = $util.Long.fromValue(object.latestReadIndex)).unsigned = false;
                else if (typeof object.latestReadIndex === "string")
                    message.latestReadIndex = parseInt(object.latestReadIndex, 10);
                else if (typeof object.latestReadIndex === "number")
                    message.latestReadIndex = object.latestReadIndex;
                else if (typeof object.latestReadIndex === "object")
                    message.latestReadIndex = new $util.LongBits(object.latestReadIndex.low >>> 0, object.latestReadIndex.high >>> 0).toNumber();
            if (object.maxHisMsgCount != null)
                message.maxHisMsgCount = object.maxHisMsgCount | 0;
            if (object.targetIdAlias != null)
                message.targetIdAlias = String(object.targetIdAlias);
            return message;
        };

        /**
         * Creates a plain object from a QryMentionMsgsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryMentionMsgsReq
         * @static
         * @param {immessage.QryMentionMsgsReq} message QryMentionMsgsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryMentionMsgsReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTime = options.longs === String ? "0" : 0;
                object.count = 0;
                object.order = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.latestReadIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latestReadIndex = options.longs === String ? "0" : 0;
                object.maxHisMsgCount = 0;
                object.targetIdAlias = "";
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (typeof message.startTime === "number")
                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                else
                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber() : message.startTime;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            if (message.order != null && message.hasOwnProperty("order"))
                object.order = message.order;
            if (message.latestReadIndex != null && message.hasOwnProperty("latestReadIndex"))
                if (typeof message.latestReadIndex === "number")
                    object.latestReadIndex = options.longs === String ? String(message.latestReadIndex) : message.latestReadIndex;
                else
                    object.latestReadIndex = options.longs === String ? $util.Long.prototype.toString.call(message.latestReadIndex) : options.longs === Number ? new $util.LongBits(message.latestReadIndex.low >>> 0, message.latestReadIndex.high >>> 0).toNumber() : message.latestReadIndex;
            if (message.maxHisMsgCount != null && message.hasOwnProperty("maxHisMsgCount"))
                object.maxHisMsgCount = message.maxHisMsgCount;
            if (message.targetIdAlias != null && message.hasOwnProperty("targetIdAlias"))
                object.targetIdAlias = message.targetIdAlias;
            return object;
        };

        /**
         * Converts this QryMentionMsgsReq to JSON.
         * @function toJSON
         * @memberof immessage.QryMentionMsgsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryMentionMsgsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryMentionMsgsReq
         * @function getTypeUrl
         * @memberof immessage.QryMentionMsgsReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryMentionMsgsReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryMentionMsgsReq";
        };

        return QryMentionMsgsReq;
    })();

    immessage.QryMentionMsgsResp = (function() {

        /**
         * Properties of a QryMentionMsgsResp.
         * @memberof immessage
         * @interface IQryMentionMsgsResp
         * @property {Array.<immessage.IDownMsg>|null} [mentionMsgs] QryMentionMsgsResp mentionMsgs
         * @property {boolean|null} [isFinished] QryMentionMsgsResp isFinished
         */

        /**
         * Constructs a new QryMentionMsgsResp.
         * @memberof immessage
         * @classdesc Represents a QryMentionMsgsResp.
         * @implements IQryMentionMsgsResp
         * @constructor
         * @param {immessage.IQryMentionMsgsResp=} [properties] Properties to set
         */
        function QryMentionMsgsResp(properties) {
            this.mentionMsgs = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryMentionMsgsResp mentionMsgs.
         * @member {Array.<immessage.IDownMsg>} mentionMsgs
         * @memberof immessage.QryMentionMsgsResp
         * @instance
         */
        QryMentionMsgsResp.prototype.mentionMsgs = $util.emptyArray;

        /**
         * QryMentionMsgsResp isFinished.
         * @member {boolean} isFinished
         * @memberof immessage.QryMentionMsgsResp
         * @instance
         */
        QryMentionMsgsResp.prototype.isFinished = false;

        /**
         * Creates a new QryMentionMsgsResp instance using the specified properties.
         * @function create
         * @memberof immessage.QryMentionMsgsResp
         * @static
         * @param {immessage.IQryMentionMsgsResp=} [properties] Properties to set
         * @returns {immessage.QryMentionMsgsResp} QryMentionMsgsResp instance
         */
        QryMentionMsgsResp.create = function create(properties) {
            return new QryMentionMsgsResp(properties);
        };

        /**
         * Encodes the specified QryMentionMsgsResp message. Does not implicitly {@link immessage.QryMentionMsgsResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryMentionMsgsResp
         * @static
         * @param {immessage.IQryMentionMsgsResp} message QryMentionMsgsResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryMentionMsgsResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mentionMsgs != null && message.mentionMsgs.length)
                for (let i = 0; i < message.mentionMsgs.length; ++i)
                    $root.immessage.DownMsg.encode(message.mentionMsgs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.isFinished != null && Object.hasOwnProperty.call(message, "isFinished"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isFinished);
            return writer;
        };

        /**
         * Encodes the specified QryMentionMsgsResp message, length delimited. Does not implicitly {@link immessage.QryMentionMsgsResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryMentionMsgsResp
         * @static
         * @param {immessage.IQryMentionMsgsResp} message QryMentionMsgsResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryMentionMsgsResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryMentionMsgsResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryMentionMsgsResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryMentionMsgsResp} QryMentionMsgsResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryMentionMsgsResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryMentionMsgsResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.mentionMsgs && message.mentionMsgs.length))
                            message.mentionMsgs = [];
                        message.mentionMsgs.push($root.immessage.DownMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.isFinished = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryMentionMsgsResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryMentionMsgsResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryMentionMsgsResp} QryMentionMsgsResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryMentionMsgsResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryMentionMsgsResp message.
         * @function verify
         * @memberof immessage.QryMentionMsgsResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryMentionMsgsResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mentionMsgs != null && message.hasOwnProperty("mentionMsgs")) {
                if (!Array.isArray(message.mentionMsgs))
                    return "mentionMsgs: array expected";
                for (let i = 0; i < message.mentionMsgs.length; ++i) {
                    let error = $root.immessage.DownMsg.verify(message.mentionMsgs[i]);
                    if (error)
                        return "mentionMsgs." + error;
                }
            }
            if (message.isFinished != null && message.hasOwnProperty("isFinished"))
                if (typeof message.isFinished !== "boolean")
                    return "isFinished: boolean expected";
            return null;
        };

        /**
         * Creates a QryMentionMsgsResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryMentionMsgsResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryMentionMsgsResp} QryMentionMsgsResp
         */
        QryMentionMsgsResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryMentionMsgsResp)
                return object;
            let message = new $root.immessage.QryMentionMsgsResp();
            if (object.mentionMsgs) {
                if (!Array.isArray(object.mentionMsgs))
                    throw TypeError(".immessage.QryMentionMsgsResp.mentionMsgs: array expected");
                message.mentionMsgs = [];
                for (let i = 0; i < object.mentionMsgs.length; ++i) {
                    if (typeof object.mentionMsgs[i] !== "object")
                        throw TypeError(".immessage.QryMentionMsgsResp.mentionMsgs: object expected");
                    message.mentionMsgs[i] = $root.immessage.DownMsg.fromObject(object.mentionMsgs[i]);
                }
            }
            if (object.isFinished != null)
                message.isFinished = Boolean(object.isFinished);
            return message;
        };

        /**
         * Creates a plain object from a QryMentionMsgsResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryMentionMsgsResp
         * @static
         * @param {immessage.QryMentionMsgsResp} message QryMentionMsgsResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryMentionMsgsResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.mentionMsgs = [];
            if (options.defaults)
                object.isFinished = false;
            if (message.mentionMsgs && message.mentionMsgs.length) {
                object.mentionMsgs = [];
                for (let j = 0; j < message.mentionMsgs.length; ++j)
                    object.mentionMsgs[j] = $root.immessage.DownMsg.toObject(message.mentionMsgs[j], options);
            }
            if (message.isFinished != null && message.hasOwnProperty("isFinished"))
                object.isFinished = message.isFinished;
            return object;
        };

        /**
         * Converts this QryMentionMsgsResp to JSON.
         * @function toJSON
         * @memberof immessage.QryMentionMsgsResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryMentionMsgsResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryMentionMsgsResp
         * @function getTypeUrl
         * @memberof immessage.QryMentionMsgsResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryMentionMsgsResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryMentionMsgsResp";
        };

        return QryMentionMsgsResp;
    })();

    immessage.SyncConversationsReq = (function() {

        /**
         * Properties of a SyncConversationsReq.
         * @memberof immessage
         * @interface ISyncConversationsReq
         * @property {number|Long|null} [startTime] SyncConversationsReq startTime
         * @property {number|null} [count] SyncConversationsReq count
         */

        /**
         * Constructs a new SyncConversationsReq.
         * @memberof immessage
         * @classdesc Represents a SyncConversationsReq.
         * @implements ISyncConversationsReq
         * @constructor
         * @param {immessage.ISyncConversationsReq=} [properties] Properties to set
         */
        function SyncConversationsReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncConversationsReq startTime.
         * @member {number|Long} startTime
         * @memberof immessage.SyncConversationsReq
         * @instance
         */
        SyncConversationsReq.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SyncConversationsReq count.
         * @member {number} count
         * @memberof immessage.SyncConversationsReq
         * @instance
         */
        SyncConversationsReq.prototype.count = 0;

        /**
         * Creates a new SyncConversationsReq instance using the specified properties.
         * @function create
         * @memberof immessage.SyncConversationsReq
         * @static
         * @param {immessage.ISyncConversationsReq=} [properties] Properties to set
         * @returns {immessage.SyncConversationsReq} SyncConversationsReq instance
         */
        SyncConversationsReq.create = function create(properties) {
            return new SyncConversationsReq(properties);
        };

        /**
         * Encodes the specified SyncConversationsReq message. Does not implicitly {@link immessage.SyncConversationsReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.SyncConversationsReq
         * @static
         * @param {immessage.ISyncConversationsReq} message SyncConversationsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncConversationsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.startTime);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified SyncConversationsReq message, length delimited. Does not implicitly {@link immessage.SyncConversationsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.SyncConversationsReq
         * @static
         * @param {immessage.ISyncConversationsReq} message SyncConversationsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncConversationsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncConversationsReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.SyncConversationsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.SyncConversationsReq} SyncConversationsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncConversationsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.SyncConversationsReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.startTime = reader.int64();
                        break;
                    }
                case 2: {
                        message.count = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncConversationsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.SyncConversationsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.SyncConversationsReq} SyncConversationsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncConversationsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncConversationsReq message.
         * @function verify
         * @memberof immessage.SyncConversationsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncConversationsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        /**
         * Creates a SyncConversationsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.SyncConversationsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.SyncConversationsReq} SyncConversationsReq
         */
        SyncConversationsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.SyncConversationsReq)
                return object;
            let message = new $root.immessage.SyncConversationsReq();
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = false;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber();
            if (object.count != null)
                message.count = object.count | 0;
            return message;
        };

        /**
         * Creates a plain object from a SyncConversationsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.SyncConversationsReq
         * @static
         * @param {immessage.SyncConversationsReq} message SyncConversationsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncConversationsReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTime = options.longs === String ? "0" : 0;
                object.count = 0;
            }
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (typeof message.startTime === "number")
                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                else
                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber() : message.startTime;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this SyncConversationsReq to JSON.
         * @function toJSON
         * @memberof immessage.SyncConversationsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncConversationsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SyncConversationsReq
         * @function getTypeUrl
         * @memberof immessage.SyncConversationsReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SyncConversationsReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.SyncConversationsReq";
        };

        return SyncConversationsReq;
    })();

    immessage.QryTotalUnreadCountReq = (function() {

        /**
         * Properties of a QryTotalUnreadCountReq.
         * @memberof immessage
         * @interface IQryTotalUnreadCountReq
         * @property {number|Long|null} [time] QryTotalUnreadCountReq time
         * @property {immessage.IConverFilter|null} [filter] QryTotalUnreadCountReq filter
         */

        /**
         * Constructs a new QryTotalUnreadCountReq.
         * @memberof immessage
         * @classdesc Represents a QryTotalUnreadCountReq.
         * @implements IQryTotalUnreadCountReq
         * @constructor
         * @param {immessage.IQryTotalUnreadCountReq=} [properties] Properties to set
         */
        function QryTotalUnreadCountReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryTotalUnreadCountReq time.
         * @member {number|Long} time
         * @memberof immessage.QryTotalUnreadCountReq
         * @instance
         */
        QryTotalUnreadCountReq.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QryTotalUnreadCountReq filter.
         * @member {immessage.IConverFilter|null|undefined} filter
         * @memberof immessage.QryTotalUnreadCountReq
         * @instance
         */
        QryTotalUnreadCountReq.prototype.filter = null;

        /**
         * Creates a new QryTotalUnreadCountReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryTotalUnreadCountReq
         * @static
         * @param {immessage.IQryTotalUnreadCountReq=} [properties] Properties to set
         * @returns {immessage.QryTotalUnreadCountReq} QryTotalUnreadCountReq instance
         */
        QryTotalUnreadCountReq.create = function create(properties) {
            return new QryTotalUnreadCountReq(properties);
        };

        /**
         * Encodes the specified QryTotalUnreadCountReq message. Does not implicitly {@link immessage.QryTotalUnreadCountReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryTotalUnreadCountReq
         * @static
         * @param {immessage.IQryTotalUnreadCountReq} message QryTotalUnreadCountReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryTotalUnreadCountReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.time);
            if (message.filter != null && Object.hasOwnProperty.call(message, "filter"))
                $root.immessage.ConverFilter.encode(message.filter, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QryTotalUnreadCountReq message, length delimited. Does not implicitly {@link immessage.QryTotalUnreadCountReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryTotalUnreadCountReq
         * @static
         * @param {immessage.IQryTotalUnreadCountReq} message QryTotalUnreadCountReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryTotalUnreadCountReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryTotalUnreadCountReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryTotalUnreadCountReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryTotalUnreadCountReq} QryTotalUnreadCountReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryTotalUnreadCountReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryTotalUnreadCountReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.time = reader.int64();
                        break;
                    }
                case 2: {
                        message.filter = $root.immessage.ConverFilter.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryTotalUnreadCountReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryTotalUnreadCountReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryTotalUnreadCountReq} QryTotalUnreadCountReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryTotalUnreadCountReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryTotalUnreadCountReq message.
         * @function verify
         * @memberof immessage.QryTotalUnreadCountReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryTotalUnreadCountReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.filter != null && message.hasOwnProperty("filter")) {
                let error = $root.immessage.ConverFilter.verify(message.filter);
                if (error)
                    return "filter." + error;
            }
            return null;
        };

        /**
         * Creates a QryTotalUnreadCountReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryTotalUnreadCountReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryTotalUnreadCountReq} QryTotalUnreadCountReq
         */
        QryTotalUnreadCountReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryTotalUnreadCountReq)
                return object;
            let message = new $root.immessage.QryTotalUnreadCountReq();
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            if (object.filter != null) {
                if (typeof object.filter !== "object")
                    throw TypeError(".immessage.QryTotalUnreadCountReq.filter: object expected");
                message.filter = $root.immessage.ConverFilter.fromObject(object.filter);
            }
            return message;
        };

        /**
         * Creates a plain object from a QryTotalUnreadCountReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryTotalUnreadCountReq
         * @static
         * @param {immessage.QryTotalUnreadCountReq} message QryTotalUnreadCountReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryTotalUnreadCountReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
                object.filter = null;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            if (message.filter != null && message.hasOwnProperty("filter"))
                object.filter = $root.immessage.ConverFilter.toObject(message.filter, options);
            return object;
        };

        /**
         * Converts this QryTotalUnreadCountReq to JSON.
         * @function toJSON
         * @memberof immessage.QryTotalUnreadCountReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryTotalUnreadCountReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryTotalUnreadCountReq
         * @function getTypeUrl
         * @memberof immessage.QryTotalUnreadCountReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryTotalUnreadCountReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryTotalUnreadCountReq";
        };

        return QryTotalUnreadCountReq;
    })();

    immessage.ConverFilter = (function() {

        /**
         * Properties of a ConverFilter.
         * @memberof immessage
         * @interface IConverFilter
         * @property {Array.<immessage.ChannelType>|null} [channelTypes] ConverFilter channelTypes
         * @property {Array.<immessage.ISimpleConversation>|null} [excludeConvers] ConverFilter excludeConvers
         * @property {Array.<immessage.ISimpleConversation>|null} [includeConvers] ConverFilter includeConvers
         * @property {string|null} [tag] ConverFilter tag
         */

        /**
         * Constructs a new ConverFilter.
         * @memberof immessage
         * @classdesc Represents a ConverFilter.
         * @implements IConverFilter
         * @constructor
         * @param {immessage.IConverFilter=} [properties] Properties to set
         */
        function ConverFilter(properties) {
            this.channelTypes = [];
            this.excludeConvers = [];
            this.includeConvers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConverFilter channelTypes.
         * @member {Array.<immessage.ChannelType>} channelTypes
         * @memberof immessage.ConverFilter
         * @instance
         */
        ConverFilter.prototype.channelTypes = $util.emptyArray;

        /**
         * ConverFilter excludeConvers.
         * @member {Array.<immessage.ISimpleConversation>} excludeConvers
         * @memberof immessage.ConverFilter
         * @instance
         */
        ConverFilter.prototype.excludeConvers = $util.emptyArray;

        /**
         * ConverFilter includeConvers.
         * @member {Array.<immessage.ISimpleConversation>} includeConvers
         * @memberof immessage.ConverFilter
         * @instance
         */
        ConverFilter.prototype.includeConvers = $util.emptyArray;

        /**
         * ConverFilter tag.
         * @member {string} tag
         * @memberof immessage.ConverFilter
         * @instance
         */
        ConverFilter.prototype.tag = "";

        /**
         * Creates a new ConverFilter instance using the specified properties.
         * @function create
         * @memberof immessage.ConverFilter
         * @static
         * @param {immessage.IConverFilter=} [properties] Properties to set
         * @returns {immessage.ConverFilter} ConverFilter instance
         */
        ConverFilter.create = function create(properties) {
            return new ConverFilter(properties);
        };

        /**
         * Encodes the specified ConverFilter message. Does not implicitly {@link immessage.ConverFilter.verify|verify} messages.
         * @function encode
         * @memberof immessage.ConverFilter
         * @static
         * @param {immessage.IConverFilter} message ConverFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConverFilter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelTypes != null && message.channelTypes.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.channelTypes.length; ++i)
                    writer.int32(message.channelTypes[i]);
                writer.ldelim();
            }
            if (message.excludeConvers != null && message.excludeConvers.length)
                for (let i = 0; i < message.excludeConvers.length; ++i)
                    $root.immessage.SimpleConversation.encode(message.excludeConvers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.includeConvers != null && message.includeConvers.length)
                for (let i = 0; i < message.includeConvers.length; ++i)
                    $root.immessage.SimpleConversation.encode(message.includeConvers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.tag != null && Object.hasOwnProperty.call(message, "tag"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.tag);
            return writer;
        };

        /**
         * Encodes the specified ConverFilter message, length delimited. Does not implicitly {@link immessage.ConverFilter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.ConverFilter
         * @static
         * @param {immessage.IConverFilter} message ConverFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConverFilter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConverFilter message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.ConverFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.ConverFilter} ConverFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConverFilter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.ConverFilter();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.channelTypes && message.channelTypes.length))
                            message.channelTypes = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.channelTypes.push(reader.int32());
                        } else
                            message.channelTypes.push(reader.int32());
                        break;
                    }
                case 2: {
                        if (!(message.excludeConvers && message.excludeConvers.length))
                            message.excludeConvers = [];
                        message.excludeConvers.push($root.immessage.SimpleConversation.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.includeConvers && message.includeConvers.length))
                            message.includeConvers = [];
                        message.includeConvers.push($root.immessage.SimpleConversation.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.tag = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConverFilter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.ConverFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.ConverFilter} ConverFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConverFilter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConverFilter message.
         * @function verify
         * @memberof immessage.ConverFilter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConverFilter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelTypes != null && message.hasOwnProperty("channelTypes")) {
                if (!Array.isArray(message.channelTypes))
                    return "channelTypes: array expected";
                for (let i = 0; i < message.channelTypes.length; ++i)
                    switch (message.channelTypes[i]) {
                    default:
                        return "channelTypes: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
            }
            if (message.excludeConvers != null && message.hasOwnProperty("excludeConvers")) {
                if (!Array.isArray(message.excludeConvers))
                    return "excludeConvers: array expected";
                for (let i = 0; i < message.excludeConvers.length; ++i) {
                    let error = $root.immessage.SimpleConversation.verify(message.excludeConvers[i]);
                    if (error)
                        return "excludeConvers." + error;
                }
            }
            if (message.includeConvers != null && message.hasOwnProperty("includeConvers")) {
                if (!Array.isArray(message.includeConvers))
                    return "includeConvers: array expected";
                for (let i = 0; i < message.includeConvers.length; ++i) {
                    let error = $root.immessage.SimpleConversation.verify(message.includeConvers[i]);
                    if (error)
                        return "includeConvers." + error;
                }
            }
            if (message.tag != null && message.hasOwnProperty("tag"))
                if (!$util.isString(message.tag))
                    return "tag: string expected";
            return null;
        };

        /**
         * Creates a ConverFilter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.ConverFilter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.ConverFilter} ConverFilter
         */
        ConverFilter.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.ConverFilter)
                return object;
            let message = new $root.immessage.ConverFilter();
            if (object.channelTypes) {
                if (!Array.isArray(object.channelTypes))
                    throw TypeError(".immessage.ConverFilter.channelTypes: array expected");
                message.channelTypes = [];
                for (let i = 0; i < object.channelTypes.length; ++i)
                    switch (object.channelTypes[i]) {
                    default:
                        if (typeof object.channelTypes[i] === "number") {
                            message.channelTypes[i] = object.channelTypes[i];
                            break;
                        }
                    case "Unknown":
                    case 0:
                        message.channelTypes[i] = 0;
                        break;
                    case "Private":
                    case 1:
                        message.channelTypes[i] = 1;
                        break;
                    case "Group":
                    case 2:
                        message.channelTypes[i] = 2;
                        break;
                    case "Chatroom":
                    case 3:
                        message.channelTypes[i] = 3;
                        break;
                    case "System":
                    case 4:
                        message.channelTypes[i] = 4;
                        break;
                    case "GroupCast":
                    case 5:
                        message.channelTypes[i] = 5;
                        break;
                    case "BroadCast":
                    case 6:
                        message.channelTypes[i] = 6;
                        break;
                    }
            }
            if (object.excludeConvers) {
                if (!Array.isArray(object.excludeConvers))
                    throw TypeError(".immessage.ConverFilter.excludeConvers: array expected");
                message.excludeConvers = [];
                for (let i = 0; i < object.excludeConvers.length; ++i) {
                    if (typeof object.excludeConvers[i] !== "object")
                        throw TypeError(".immessage.ConverFilter.excludeConvers: object expected");
                    message.excludeConvers[i] = $root.immessage.SimpleConversation.fromObject(object.excludeConvers[i]);
                }
            }
            if (object.includeConvers) {
                if (!Array.isArray(object.includeConvers))
                    throw TypeError(".immessage.ConverFilter.includeConvers: array expected");
                message.includeConvers = [];
                for (let i = 0; i < object.includeConvers.length; ++i) {
                    if (typeof object.includeConvers[i] !== "object")
                        throw TypeError(".immessage.ConverFilter.includeConvers: object expected");
                    message.includeConvers[i] = $root.immessage.SimpleConversation.fromObject(object.includeConvers[i]);
                }
            }
            if (object.tag != null)
                message.tag = String(object.tag);
            return message;
        };

        /**
         * Creates a plain object from a ConverFilter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.ConverFilter
         * @static
         * @param {immessage.ConverFilter} message ConverFilter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConverFilter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.channelTypes = [];
                object.excludeConvers = [];
                object.includeConvers = [];
            }
            if (options.defaults)
                object.tag = "";
            if (message.channelTypes && message.channelTypes.length) {
                object.channelTypes = [];
                for (let j = 0; j < message.channelTypes.length; ++j)
                    object.channelTypes[j] = options.enums === String ? $root.immessage.ChannelType[message.channelTypes[j]] === undefined ? message.channelTypes[j] : $root.immessage.ChannelType[message.channelTypes[j]] : message.channelTypes[j];
            }
            if (message.excludeConvers && message.excludeConvers.length) {
                object.excludeConvers = [];
                for (let j = 0; j < message.excludeConvers.length; ++j)
                    object.excludeConvers[j] = $root.immessage.SimpleConversation.toObject(message.excludeConvers[j], options);
            }
            if (message.includeConvers && message.includeConvers.length) {
                object.includeConvers = [];
                for (let j = 0; j < message.includeConvers.length; ++j)
                    object.includeConvers[j] = $root.immessage.SimpleConversation.toObject(message.includeConvers[j], options);
            }
            if (message.tag != null && message.hasOwnProperty("tag"))
                object.tag = message.tag;
            return object;
        };

        /**
         * Converts this ConverFilter to JSON.
         * @function toJSON
         * @memberof immessage.ConverFilter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConverFilter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ConverFilter
         * @function getTypeUrl
         * @memberof immessage.ConverFilter
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConverFilter.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.ConverFilter";
        };

        return ConverFilter;
    })();

    immessage.QryTotalUnreadCountResp = (function() {

        /**
         * Properties of a QryTotalUnreadCountResp.
         * @memberof immessage
         * @interface IQryTotalUnreadCountResp
         * @property {number|Long|null} [totalCount] QryTotalUnreadCountResp totalCount
         */

        /**
         * Constructs a new QryTotalUnreadCountResp.
         * @memberof immessage
         * @classdesc Represents a QryTotalUnreadCountResp.
         * @implements IQryTotalUnreadCountResp
         * @constructor
         * @param {immessage.IQryTotalUnreadCountResp=} [properties] Properties to set
         */
        function QryTotalUnreadCountResp(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryTotalUnreadCountResp totalCount.
         * @member {number|Long} totalCount
         * @memberof immessage.QryTotalUnreadCountResp
         * @instance
         */
        QryTotalUnreadCountResp.prototype.totalCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new QryTotalUnreadCountResp instance using the specified properties.
         * @function create
         * @memberof immessage.QryTotalUnreadCountResp
         * @static
         * @param {immessage.IQryTotalUnreadCountResp=} [properties] Properties to set
         * @returns {immessage.QryTotalUnreadCountResp} QryTotalUnreadCountResp instance
         */
        QryTotalUnreadCountResp.create = function create(properties) {
            return new QryTotalUnreadCountResp(properties);
        };

        /**
         * Encodes the specified QryTotalUnreadCountResp message. Does not implicitly {@link immessage.QryTotalUnreadCountResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryTotalUnreadCountResp
         * @static
         * @param {immessage.IQryTotalUnreadCountResp} message QryTotalUnreadCountResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryTotalUnreadCountResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.totalCount != null && Object.hasOwnProperty.call(message, "totalCount"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.totalCount);
            return writer;
        };

        /**
         * Encodes the specified QryTotalUnreadCountResp message, length delimited. Does not implicitly {@link immessage.QryTotalUnreadCountResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryTotalUnreadCountResp
         * @static
         * @param {immessage.IQryTotalUnreadCountResp} message QryTotalUnreadCountResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryTotalUnreadCountResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryTotalUnreadCountResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryTotalUnreadCountResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryTotalUnreadCountResp} QryTotalUnreadCountResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryTotalUnreadCountResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryTotalUnreadCountResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.totalCount = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryTotalUnreadCountResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryTotalUnreadCountResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryTotalUnreadCountResp} QryTotalUnreadCountResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryTotalUnreadCountResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryTotalUnreadCountResp message.
         * @function verify
         * @memberof immessage.QryTotalUnreadCountResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryTotalUnreadCountResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.totalCount != null && message.hasOwnProperty("totalCount"))
                if (!$util.isInteger(message.totalCount) && !(message.totalCount && $util.isInteger(message.totalCount.low) && $util.isInteger(message.totalCount.high)))
                    return "totalCount: integer|Long expected";
            return null;
        };

        /**
         * Creates a QryTotalUnreadCountResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryTotalUnreadCountResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryTotalUnreadCountResp} QryTotalUnreadCountResp
         */
        QryTotalUnreadCountResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryTotalUnreadCountResp)
                return object;
            let message = new $root.immessage.QryTotalUnreadCountResp();
            if (object.totalCount != null)
                if ($util.Long)
                    (message.totalCount = $util.Long.fromValue(object.totalCount)).unsigned = false;
                else if (typeof object.totalCount === "string")
                    message.totalCount = parseInt(object.totalCount, 10);
                else if (typeof object.totalCount === "number")
                    message.totalCount = object.totalCount;
                else if (typeof object.totalCount === "object")
                    message.totalCount = new $util.LongBits(object.totalCount.low >>> 0, object.totalCount.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a QryTotalUnreadCountResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryTotalUnreadCountResp
         * @static
         * @param {immessage.QryTotalUnreadCountResp} message QryTotalUnreadCountResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryTotalUnreadCountResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalCount = options.longs === String ? "0" : 0;
            if (message.totalCount != null && message.hasOwnProperty("totalCount"))
                if (typeof message.totalCount === "number")
                    object.totalCount = options.longs === String ? String(message.totalCount) : message.totalCount;
                else
                    object.totalCount = options.longs === String ? $util.Long.prototype.toString.call(message.totalCount) : options.longs === Number ? new $util.LongBits(message.totalCount.low >>> 0, message.totalCount.high >>> 0).toNumber() : message.totalCount;
            return object;
        };

        /**
         * Converts this QryTotalUnreadCountResp to JSON.
         * @function toJSON
         * @memberof immessage.QryTotalUnreadCountResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryTotalUnreadCountResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryTotalUnreadCountResp
         * @function getTypeUrl
         * @memberof immessage.QryTotalUnreadCountResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryTotalUnreadCountResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryTotalUnreadCountResp";
        };

        return QryTotalUnreadCountResp;
    })();

    immessage.ConversationsReq = (function() {

        /**
         * Properties of a ConversationsReq.
         * @memberof immessage
         * @interface IConversationsReq
         * @property {Array.<immessage.IConversation>|null} [conversations] ConversationsReq conversations
         */

        /**
         * Constructs a new ConversationsReq.
         * @memberof immessage
         * @classdesc Represents a ConversationsReq.
         * @implements IConversationsReq
         * @constructor
         * @param {immessage.IConversationsReq=} [properties] Properties to set
         */
        function ConversationsReq(properties) {
            this.conversations = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConversationsReq conversations.
         * @member {Array.<immessage.IConversation>} conversations
         * @memberof immessage.ConversationsReq
         * @instance
         */
        ConversationsReq.prototype.conversations = $util.emptyArray;

        /**
         * Creates a new ConversationsReq instance using the specified properties.
         * @function create
         * @memberof immessage.ConversationsReq
         * @static
         * @param {immessage.IConversationsReq=} [properties] Properties to set
         * @returns {immessage.ConversationsReq} ConversationsReq instance
         */
        ConversationsReq.create = function create(properties) {
            return new ConversationsReq(properties);
        };

        /**
         * Encodes the specified ConversationsReq message. Does not implicitly {@link immessage.ConversationsReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.ConversationsReq
         * @static
         * @param {immessage.IConversationsReq} message ConversationsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConversationsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.conversations != null && message.conversations.length)
                for (let i = 0; i < message.conversations.length; ++i)
                    $root.immessage.Conversation.encode(message.conversations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ConversationsReq message, length delimited. Does not implicitly {@link immessage.ConversationsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.ConversationsReq
         * @static
         * @param {immessage.IConversationsReq} message ConversationsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConversationsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConversationsReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.ConversationsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.ConversationsReq} ConversationsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConversationsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.ConversationsReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.conversations && message.conversations.length))
                            message.conversations = [];
                        message.conversations.push($root.immessage.Conversation.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConversationsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.ConversationsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.ConversationsReq} ConversationsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConversationsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConversationsReq message.
         * @function verify
         * @memberof immessage.ConversationsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConversationsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.conversations != null && message.hasOwnProperty("conversations")) {
                if (!Array.isArray(message.conversations))
                    return "conversations: array expected";
                for (let i = 0; i < message.conversations.length; ++i) {
                    let error = $root.immessage.Conversation.verify(message.conversations[i]);
                    if (error)
                        return "conversations." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ConversationsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.ConversationsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.ConversationsReq} ConversationsReq
         */
        ConversationsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.ConversationsReq)
                return object;
            let message = new $root.immessage.ConversationsReq();
            if (object.conversations) {
                if (!Array.isArray(object.conversations))
                    throw TypeError(".immessage.ConversationsReq.conversations: array expected");
                message.conversations = [];
                for (let i = 0; i < object.conversations.length; ++i) {
                    if (typeof object.conversations[i] !== "object")
                        throw TypeError(".immessage.ConversationsReq.conversations: object expected");
                    message.conversations[i] = $root.immessage.Conversation.fromObject(object.conversations[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ConversationsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.ConversationsReq
         * @static
         * @param {immessage.ConversationsReq} message ConversationsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConversationsReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.conversations = [];
            if (message.conversations && message.conversations.length) {
                object.conversations = [];
                for (let j = 0; j < message.conversations.length; ++j)
                    object.conversations[j] = $root.immessage.Conversation.toObject(message.conversations[j], options);
            }
            return object;
        };

        /**
         * Converts this ConversationsReq to JSON.
         * @function toJSON
         * @memberof immessage.ConversationsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConversationsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ConversationsReq
         * @function getTypeUrl
         * @memberof immessage.ConversationsReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConversationsReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.ConversationsReq";
        };

        return ConversationsReq;
    })();

    immessage.ClearUnreadReq = (function() {

        /**
         * Properties of a ClearUnreadReq.
         * @memberof immessage
         * @interface IClearUnreadReq
         * @property {Array.<immessage.IConversation>|null} [conversations] ClearUnreadReq conversations
         * @property {boolean|null} [noCmdMsg] ClearUnreadReq noCmdMsg
         */

        /**
         * Constructs a new ClearUnreadReq.
         * @memberof immessage
         * @classdesc Represents a ClearUnreadReq.
         * @implements IClearUnreadReq
         * @constructor
         * @param {immessage.IClearUnreadReq=} [properties] Properties to set
         */
        function ClearUnreadReq(properties) {
            this.conversations = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClearUnreadReq conversations.
         * @member {Array.<immessage.IConversation>} conversations
         * @memberof immessage.ClearUnreadReq
         * @instance
         */
        ClearUnreadReq.prototype.conversations = $util.emptyArray;

        /**
         * ClearUnreadReq noCmdMsg.
         * @member {boolean} noCmdMsg
         * @memberof immessage.ClearUnreadReq
         * @instance
         */
        ClearUnreadReq.prototype.noCmdMsg = false;

        /**
         * Creates a new ClearUnreadReq instance using the specified properties.
         * @function create
         * @memberof immessage.ClearUnreadReq
         * @static
         * @param {immessage.IClearUnreadReq=} [properties] Properties to set
         * @returns {immessage.ClearUnreadReq} ClearUnreadReq instance
         */
        ClearUnreadReq.create = function create(properties) {
            return new ClearUnreadReq(properties);
        };

        /**
         * Encodes the specified ClearUnreadReq message. Does not implicitly {@link immessage.ClearUnreadReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.ClearUnreadReq
         * @static
         * @param {immessage.IClearUnreadReq} message ClearUnreadReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClearUnreadReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.conversations != null && message.conversations.length)
                for (let i = 0; i < message.conversations.length; ++i)
                    $root.immessage.Conversation.encode(message.conversations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.noCmdMsg != null && Object.hasOwnProperty.call(message, "noCmdMsg"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noCmdMsg);
            return writer;
        };

        /**
         * Encodes the specified ClearUnreadReq message, length delimited. Does not implicitly {@link immessage.ClearUnreadReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.ClearUnreadReq
         * @static
         * @param {immessage.IClearUnreadReq} message ClearUnreadReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClearUnreadReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClearUnreadReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.ClearUnreadReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.ClearUnreadReq} ClearUnreadReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClearUnreadReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.ClearUnreadReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.conversations && message.conversations.length))
                            message.conversations = [];
                        message.conversations.push($root.immessage.Conversation.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.noCmdMsg = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClearUnreadReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.ClearUnreadReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.ClearUnreadReq} ClearUnreadReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClearUnreadReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClearUnreadReq message.
         * @function verify
         * @memberof immessage.ClearUnreadReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClearUnreadReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.conversations != null && message.hasOwnProperty("conversations")) {
                if (!Array.isArray(message.conversations))
                    return "conversations: array expected";
                for (let i = 0; i < message.conversations.length; ++i) {
                    let error = $root.immessage.Conversation.verify(message.conversations[i]);
                    if (error)
                        return "conversations." + error;
                }
            }
            if (message.noCmdMsg != null && message.hasOwnProperty("noCmdMsg"))
                if (typeof message.noCmdMsg !== "boolean")
                    return "noCmdMsg: boolean expected";
            return null;
        };

        /**
         * Creates a ClearUnreadReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.ClearUnreadReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.ClearUnreadReq} ClearUnreadReq
         */
        ClearUnreadReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.ClearUnreadReq)
                return object;
            let message = new $root.immessage.ClearUnreadReq();
            if (object.conversations) {
                if (!Array.isArray(object.conversations))
                    throw TypeError(".immessage.ClearUnreadReq.conversations: array expected");
                message.conversations = [];
                for (let i = 0; i < object.conversations.length; ++i) {
                    if (typeof object.conversations[i] !== "object")
                        throw TypeError(".immessage.ClearUnreadReq.conversations: object expected");
                    message.conversations[i] = $root.immessage.Conversation.fromObject(object.conversations[i]);
                }
            }
            if (object.noCmdMsg != null)
                message.noCmdMsg = Boolean(object.noCmdMsg);
            return message;
        };

        /**
         * Creates a plain object from a ClearUnreadReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.ClearUnreadReq
         * @static
         * @param {immessage.ClearUnreadReq} message ClearUnreadReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClearUnreadReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.conversations = [];
            if (options.defaults)
                object.noCmdMsg = false;
            if (message.conversations && message.conversations.length) {
                object.conversations = [];
                for (let j = 0; j < message.conversations.length; ++j)
                    object.conversations[j] = $root.immessage.Conversation.toObject(message.conversations[j], options);
            }
            if (message.noCmdMsg != null && message.hasOwnProperty("noCmdMsg"))
                object.noCmdMsg = message.noCmdMsg;
            return object;
        };

        /**
         * Converts this ClearUnreadReq to JSON.
         * @function toJSON
         * @memberof immessage.ClearUnreadReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClearUnreadReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClearUnreadReq
         * @function getTypeUrl
         * @memberof immessage.ClearUnreadReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClearUnreadReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.ClearUnreadReq";
        };

        return ClearUnreadReq;
    })();

    immessage.UndisturbConversReq = (function() {

        /**
         * Properties of an UndisturbConversReq.
         * @memberof immessage
         * @interface IUndisturbConversReq
         * @property {Array.<immessage.IUndisturbConverItem>|null} [items] UndisturbConversReq items
         */

        /**
         * Constructs a new UndisturbConversReq.
         * @memberof immessage
         * @classdesc Represents an UndisturbConversReq.
         * @implements IUndisturbConversReq
         * @constructor
         * @param {immessage.IUndisturbConversReq=} [properties] Properties to set
         */
        function UndisturbConversReq(properties) {
            this.items = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UndisturbConversReq items.
         * @member {Array.<immessage.IUndisturbConverItem>} items
         * @memberof immessage.UndisturbConversReq
         * @instance
         */
        UndisturbConversReq.prototype.items = $util.emptyArray;

        /**
         * Creates a new UndisturbConversReq instance using the specified properties.
         * @function create
         * @memberof immessage.UndisturbConversReq
         * @static
         * @param {immessage.IUndisturbConversReq=} [properties] Properties to set
         * @returns {immessage.UndisturbConversReq} UndisturbConversReq instance
         */
        UndisturbConversReq.create = function create(properties) {
            return new UndisturbConversReq(properties);
        };

        /**
         * Encodes the specified UndisturbConversReq message. Does not implicitly {@link immessage.UndisturbConversReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.UndisturbConversReq
         * @static
         * @param {immessage.IUndisturbConversReq} message UndisturbConversReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UndisturbConversReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (let i = 0; i < message.items.length; ++i)
                    $root.immessage.UndisturbConverItem.encode(message.items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UndisturbConversReq message, length delimited. Does not implicitly {@link immessage.UndisturbConversReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UndisturbConversReq
         * @static
         * @param {immessage.IUndisturbConversReq} message UndisturbConversReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UndisturbConversReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UndisturbConversReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UndisturbConversReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UndisturbConversReq} UndisturbConversReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UndisturbConversReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UndisturbConversReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.immessage.UndisturbConverItem.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UndisturbConversReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UndisturbConversReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UndisturbConversReq} UndisturbConversReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UndisturbConversReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UndisturbConversReq message.
         * @function verify
         * @memberof immessage.UndisturbConversReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UndisturbConversReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (let i = 0; i < message.items.length; ++i) {
                    let error = $root.immessage.UndisturbConverItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates an UndisturbConversReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UndisturbConversReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UndisturbConversReq} UndisturbConversReq
         */
        UndisturbConversReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UndisturbConversReq)
                return object;
            let message = new $root.immessage.UndisturbConversReq();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".immessage.UndisturbConversReq.items: array expected");
                message.items = [];
                for (let i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".immessage.UndisturbConversReq.items: object expected");
                    message.items[i] = $root.immessage.UndisturbConverItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an UndisturbConversReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UndisturbConversReq
         * @static
         * @param {immessage.UndisturbConversReq} message UndisturbConversReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UndisturbConversReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (message.items && message.items.length) {
                object.items = [];
                for (let j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.immessage.UndisturbConverItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this UndisturbConversReq to JSON.
         * @function toJSON
         * @memberof immessage.UndisturbConversReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UndisturbConversReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UndisturbConversReq
         * @function getTypeUrl
         * @memberof immessage.UndisturbConversReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UndisturbConversReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UndisturbConversReq";
        };

        return UndisturbConversReq;
    })();

    immessage.UndisturbConverItem = (function() {

        /**
         * Properties of an UndisturbConverItem.
         * @memberof immessage
         * @interface IUndisturbConverItem
         * @property {string|null} [targetId] UndisturbConverItem targetId
         * @property {immessage.ChannelType|null} [channelType] UndisturbConverItem channelType
         * @property {number|null} [undisturbType] UndisturbConverItem undisturbType
         */

        /**
         * Constructs a new UndisturbConverItem.
         * @memberof immessage
         * @classdesc Represents an UndisturbConverItem.
         * @implements IUndisturbConverItem
         * @constructor
         * @param {immessage.IUndisturbConverItem=} [properties] Properties to set
         */
        function UndisturbConverItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UndisturbConverItem targetId.
         * @member {string} targetId
         * @memberof immessage.UndisturbConverItem
         * @instance
         */
        UndisturbConverItem.prototype.targetId = "";

        /**
         * UndisturbConverItem channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.UndisturbConverItem
         * @instance
         */
        UndisturbConverItem.prototype.channelType = 0;

        /**
         * UndisturbConverItem undisturbType.
         * @member {number} undisturbType
         * @memberof immessage.UndisturbConverItem
         * @instance
         */
        UndisturbConverItem.prototype.undisturbType = 0;

        /**
         * Creates a new UndisturbConverItem instance using the specified properties.
         * @function create
         * @memberof immessage.UndisturbConverItem
         * @static
         * @param {immessage.IUndisturbConverItem=} [properties] Properties to set
         * @returns {immessage.UndisturbConverItem} UndisturbConverItem instance
         */
        UndisturbConverItem.create = function create(properties) {
            return new UndisturbConverItem(properties);
        };

        /**
         * Encodes the specified UndisturbConverItem message. Does not implicitly {@link immessage.UndisturbConverItem.verify|verify} messages.
         * @function encode
         * @memberof immessage.UndisturbConverItem
         * @static
         * @param {immessage.IUndisturbConverItem} message UndisturbConverItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UndisturbConverItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.undisturbType != null && Object.hasOwnProperty.call(message, "undisturbType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.undisturbType);
            return writer;
        };

        /**
         * Encodes the specified UndisturbConverItem message, length delimited. Does not implicitly {@link immessage.UndisturbConverItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UndisturbConverItem
         * @static
         * @param {immessage.IUndisturbConverItem} message UndisturbConverItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UndisturbConverItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UndisturbConverItem message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UndisturbConverItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UndisturbConverItem} UndisturbConverItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UndisturbConverItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UndisturbConverItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        message.undisturbType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UndisturbConverItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UndisturbConverItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UndisturbConverItem} UndisturbConverItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UndisturbConverItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UndisturbConverItem message.
         * @function verify
         * @memberof immessage.UndisturbConverItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UndisturbConverItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.undisturbType != null && message.hasOwnProperty("undisturbType"))
                if (!$util.isInteger(message.undisturbType))
                    return "undisturbType: integer expected";
            return null;
        };

        /**
         * Creates an UndisturbConverItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UndisturbConverItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UndisturbConverItem} UndisturbConverItem
         */
        UndisturbConverItem.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UndisturbConverItem)
                return object;
            let message = new $root.immessage.UndisturbConverItem();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.undisturbType != null)
                message.undisturbType = object.undisturbType | 0;
            return message;
        };

        /**
         * Creates a plain object from an UndisturbConverItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UndisturbConverItem
         * @static
         * @param {immessage.UndisturbConverItem} message UndisturbConverItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UndisturbConverItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                object.undisturbType = 0;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.undisturbType != null && message.hasOwnProperty("undisturbType"))
                object.undisturbType = message.undisturbType;
            return object;
        };

        /**
         * Converts this UndisturbConverItem to JSON.
         * @function toJSON
         * @memberof immessage.UndisturbConverItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UndisturbConverItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UndisturbConverItem
         * @function getTypeUrl
         * @memberof immessage.UndisturbConverItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UndisturbConverItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UndisturbConverItem";
        };

        return UndisturbConverItem;
    })();

    immessage.QryTopConversReq = (function() {

        /**
         * Properties of a QryTopConversReq.
         * @memberof immessage
         * @interface IQryTopConversReq
         * @property {number|Long|null} [startTime] QryTopConversReq startTime
         * @property {immessage.TopConverSortType|null} [sortType] QryTopConversReq sortType
         * @property {number|null} [order] QryTopConversReq order
         */

        /**
         * Constructs a new QryTopConversReq.
         * @memberof immessage
         * @classdesc Represents a QryTopConversReq.
         * @implements IQryTopConversReq
         * @constructor
         * @param {immessage.IQryTopConversReq=} [properties] Properties to set
         */
        function QryTopConversReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryTopConversReq startTime.
         * @member {number|Long} startTime
         * @memberof immessage.QryTopConversReq
         * @instance
         */
        QryTopConversReq.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QryTopConversReq sortType.
         * @member {immessage.TopConverSortType} sortType
         * @memberof immessage.QryTopConversReq
         * @instance
         */
        QryTopConversReq.prototype.sortType = 0;

        /**
         * QryTopConversReq order.
         * @member {number} order
         * @memberof immessage.QryTopConversReq
         * @instance
         */
        QryTopConversReq.prototype.order = 0;

        /**
         * Creates a new QryTopConversReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryTopConversReq
         * @static
         * @param {immessage.IQryTopConversReq=} [properties] Properties to set
         * @returns {immessage.QryTopConversReq} QryTopConversReq instance
         */
        QryTopConversReq.create = function create(properties) {
            return new QryTopConversReq(properties);
        };

        /**
         * Encodes the specified QryTopConversReq message. Does not implicitly {@link immessage.QryTopConversReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryTopConversReq
         * @static
         * @param {immessage.IQryTopConversReq} message QryTopConversReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryTopConversReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.startTime);
            if (message.sortType != null && Object.hasOwnProperty.call(message, "sortType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.sortType);
            if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.order);
            return writer;
        };

        /**
         * Encodes the specified QryTopConversReq message, length delimited. Does not implicitly {@link immessage.QryTopConversReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryTopConversReq
         * @static
         * @param {immessage.IQryTopConversReq} message QryTopConversReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryTopConversReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryTopConversReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryTopConversReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryTopConversReq} QryTopConversReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryTopConversReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryTopConversReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.startTime = reader.int64();
                        break;
                    }
                case 2: {
                        message.sortType = reader.int32();
                        break;
                    }
                case 3: {
                        message.order = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryTopConversReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryTopConversReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryTopConversReq} QryTopConversReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryTopConversReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryTopConversReq message.
         * @function verify
         * @memberof immessage.QryTopConversReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryTopConversReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            if (message.sortType != null && message.hasOwnProperty("sortType"))
                switch (message.sortType) {
                default:
                    return "sortType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.order != null && message.hasOwnProperty("order"))
                if (!$util.isInteger(message.order))
                    return "order: integer expected";
            return null;
        };

        /**
         * Creates a QryTopConversReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryTopConversReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryTopConversReq} QryTopConversReq
         */
        QryTopConversReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryTopConversReq)
                return object;
            let message = new $root.immessage.QryTopConversReq();
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = false;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber();
            switch (object.sortType) {
            default:
                if (typeof object.sortType === "number") {
                    message.sortType = object.sortType;
                    break;
                }
                break;
            case "ByTopTime":
            case 0:
                message.sortType = 0;
                break;
            case "BySortTime":
            case 1:
                message.sortType = 1;
                break;
            }
            if (object.order != null)
                message.order = object.order | 0;
            return message;
        };

        /**
         * Creates a plain object from a QryTopConversReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryTopConversReq
         * @static
         * @param {immessage.QryTopConversReq} message QryTopConversReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryTopConversReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTime = options.longs === String ? "0" : 0;
                object.sortType = options.enums === String ? "ByTopTime" : 0;
                object.order = 0;
            }
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (typeof message.startTime === "number")
                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                else
                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber() : message.startTime;
            if (message.sortType != null && message.hasOwnProperty("sortType"))
                object.sortType = options.enums === String ? $root.immessage.TopConverSortType[message.sortType] === undefined ? message.sortType : $root.immessage.TopConverSortType[message.sortType] : message.sortType;
            if (message.order != null && message.hasOwnProperty("order"))
                object.order = message.order;
            return object;
        };

        /**
         * Converts this QryTopConversReq to JSON.
         * @function toJSON
         * @memberof immessage.QryTopConversReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryTopConversReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryTopConversReq
         * @function getTypeUrl
         * @memberof immessage.QryTopConversReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryTopConversReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryTopConversReq";
        };

        return QryTopConversReq;
    })();

    /**
     * TopConverSortType enum.
     * @name immessage.TopConverSortType
     * @enum {number}
     * @property {number} ByTopTime=0 ByTopTime value
     * @property {number} BySortTime=1 BySortTime value
     */
    immessage.TopConverSortType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ByTopTime"] = 0;
        values[valuesById[1] = "BySortTime"] = 1;
        return values;
    })();

    immessage.TopConversResp = (function() {

        /**
         * Properties of a TopConversResp.
         * @memberof immessage
         * @interface ITopConversResp
         * @property {number|Long|null} [optTime] TopConversResp optTime
         */

        /**
         * Constructs a new TopConversResp.
         * @memberof immessage
         * @classdesc Represents a TopConversResp.
         * @implements ITopConversResp
         * @constructor
         * @param {immessage.ITopConversResp=} [properties] Properties to set
         */
        function TopConversResp(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TopConversResp optTime.
         * @member {number|Long} optTime
         * @memberof immessage.TopConversResp
         * @instance
         */
        TopConversResp.prototype.optTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TopConversResp instance using the specified properties.
         * @function create
         * @memberof immessage.TopConversResp
         * @static
         * @param {immessage.ITopConversResp=} [properties] Properties to set
         * @returns {immessage.TopConversResp} TopConversResp instance
         */
        TopConversResp.create = function create(properties) {
            return new TopConversResp(properties);
        };

        /**
         * Encodes the specified TopConversResp message. Does not implicitly {@link immessage.TopConversResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.TopConversResp
         * @static
         * @param {immessage.ITopConversResp} message TopConversResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TopConversResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.optTime != null && Object.hasOwnProperty.call(message, "optTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.optTime);
            return writer;
        };

        /**
         * Encodes the specified TopConversResp message, length delimited. Does not implicitly {@link immessage.TopConversResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.TopConversResp
         * @static
         * @param {immessage.ITopConversResp} message TopConversResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TopConversResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TopConversResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.TopConversResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.TopConversResp} TopConversResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TopConversResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.TopConversResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.optTime = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TopConversResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.TopConversResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.TopConversResp} TopConversResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TopConversResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TopConversResp message.
         * @function verify
         * @memberof immessage.TopConversResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TopConversResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.optTime != null && message.hasOwnProperty("optTime"))
                if (!$util.isInteger(message.optTime) && !(message.optTime && $util.isInteger(message.optTime.low) && $util.isInteger(message.optTime.high)))
                    return "optTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a TopConversResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.TopConversResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.TopConversResp} TopConversResp
         */
        TopConversResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.TopConversResp)
                return object;
            let message = new $root.immessage.TopConversResp();
            if (object.optTime != null)
                if ($util.Long)
                    (message.optTime = $util.Long.fromValue(object.optTime)).unsigned = false;
                else if (typeof object.optTime === "string")
                    message.optTime = parseInt(object.optTime, 10);
                else if (typeof object.optTime === "number")
                    message.optTime = object.optTime;
                else if (typeof object.optTime === "object")
                    message.optTime = new $util.LongBits(object.optTime.low >>> 0, object.optTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TopConversResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.TopConversResp
         * @static
         * @param {immessage.TopConversResp} message TopConversResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TopConversResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.optTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.optTime = options.longs === String ? "0" : 0;
            if (message.optTime != null && message.hasOwnProperty("optTime"))
                if (typeof message.optTime === "number")
                    object.optTime = options.longs === String ? String(message.optTime) : message.optTime;
                else
                    object.optTime = options.longs === String ? $util.Long.prototype.toString.call(message.optTime) : options.longs === Number ? new $util.LongBits(message.optTime.low >>> 0, message.optTime.high >>> 0).toNumber() : message.optTime;
            return object;
        };

        /**
         * Converts this TopConversResp to JSON.
         * @function toJSON
         * @memberof immessage.TopConversResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TopConversResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TopConversResp
         * @function getTypeUrl
         * @memberof immessage.TopConversResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TopConversResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.TopConversResp";
        };

        return TopConversResp;
    })();

    immessage.QryReadInfosReq = (function() {

        /**
         * Properties of a QryReadInfosReq.
         * @memberof immessage
         * @interface IQryReadInfosReq
         * @property {string|null} [targetId] QryReadInfosReq targetId
         * @property {immessage.ChannelType|null} [channelType] QryReadInfosReq channelType
         * @property {Array.<string>|null} [msgIds] QryReadInfosReq msgIds
         */

        /**
         * Constructs a new QryReadInfosReq.
         * @memberof immessage
         * @classdesc Represents a QryReadInfosReq.
         * @implements IQryReadInfosReq
         * @constructor
         * @param {immessage.IQryReadInfosReq=} [properties] Properties to set
         */
        function QryReadInfosReq(properties) {
            this.msgIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryReadInfosReq targetId.
         * @member {string} targetId
         * @memberof immessage.QryReadInfosReq
         * @instance
         */
        QryReadInfosReq.prototype.targetId = "";

        /**
         * QryReadInfosReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.QryReadInfosReq
         * @instance
         */
        QryReadInfosReq.prototype.channelType = 0;

        /**
         * QryReadInfosReq msgIds.
         * @member {Array.<string>} msgIds
         * @memberof immessage.QryReadInfosReq
         * @instance
         */
        QryReadInfosReq.prototype.msgIds = $util.emptyArray;

        /**
         * Creates a new QryReadInfosReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryReadInfosReq
         * @static
         * @param {immessage.IQryReadInfosReq=} [properties] Properties to set
         * @returns {immessage.QryReadInfosReq} QryReadInfosReq instance
         */
        QryReadInfosReq.create = function create(properties) {
            return new QryReadInfosReq(properties);
        };

        /**
         * Encodes the specified QryReadInfosReq message. Does not implicitly {@link immessage.QryReadInfosReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryReadInfosReq
         * @static
         * @param {immessage.IQryReadInfosReq} message QryReadInfosReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryReadInfosReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.msgIds != null && message.msgIds.length)
                for (let i = 0; i < message.msgIds.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.msgIds[i]);
            return writer;
        };

        /**
         * Encodes the specified QryReadInfosReq message, length delimited. Does not implicitly {@link immessage.QryReadInfosReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryReadInfosReq
         * @static
         * @param {immessage.IQryReadInfosReq} message QryReadInfosReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryReadInfosReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryReadInfosReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryReadInfosReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryReadInfosReq} QryReadInfosReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryReadInfosReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryReadInfosReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.msgIds && message.msgIds.length))
                            message.msgIds = [];
                        message.msgIds.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryReadInfosReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryReadInfosReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryReadInfosReq} QryReadInfosReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryReadInfosReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryReadInfosReq message.
         * @function verify
         * @memberof immessage.QryReadInfosReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryReadInfosReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.msgIds != null && message.hasOwnProperty("msgIds")) {
                if (!Array.isArray(message.msgIds))
                    return "msgIds: array expected";
                for (let i = 0; i < message.msgIds.length; ++i)
                    if (!$util.isString(message.msgIds[i]))
                        return "msgIds: string[] expected";
            }
            return null;
        };

        /**
         * Creates a QryReadInfosReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryReadInfosReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryReadInfosReq} QryReadInfosReq
         */
        QryReadInfosReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryReadInfosReq)
                return object;
            let message = new $root.immessage.QryReadInfosReq();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.msgIds) {
                if (!Array.isArray(object.msgIds))
                    throw TypeError(".immessage.QryReadInfosReq.msgIds: array expected");
                message.msgIds = [];
                for (let i = 0; i < object.msgIds.length; ++i)
                    message.msgIds[i] = String(object.msgIds[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a QryReadInfosReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryReadInfosReq
         * @static
         * @param {immessage.QryReadInfosReq} message QryReadInfosReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryReadInfosReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.msgIds = [];
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.msgIds && message.msgIds.length) {
                object.msgIds = [];
                for (let j = 0; j < message.msgIds.length; ++j)
                    object.msgIds[j] = message.msgIds[j];
            }
            return object;
        };

        /**
         * Converts this QryReadInfosReq to JSON.
         * @function toJSON
         * @memberof immessage.QryReadInfosReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryReadInfosReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryReadInfosReq
         * @function getTypeUrl
         * @memberof immessage.QryReadInfosReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryReadInfosReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryReadInfosReq";
        };

        return QryReadInfosReq;
    })();

    immessage.QryReadInfosResp = (function() {

        /**
         * Properties of a QryReadInfosResp.
         * @memberof immessage
         * @interface IQryReadInfosResp
         * @property {Array.<immessage.IReadInfoItem>|null} [items] QryReadInfosResp items
         */

        /**
         * Constructs a new QryReadInfosResp.
         * @memberof immessage
         * @classdesc Represents a QryReadInfosResp.
         * @implements IQryReadInfosResp
         * @constructor
         * @param {immessage.IQryReadInfosResp=} [properties] Properties to set
         */
        function QryReadInfosResp(properties) {
            this.items = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryReadInfosResp items.
         * @member {Array.<immessage.IReadInfoItem>} items
         * @memberof immessage.QryReadInfosResp
         * @instance
         */
        QryReadInfosResp.prototype.items = $util.emptyArray;

        /**
         * Creates a new QryReadInfosResp instance using the specified properties.
         * @function create
         * @memberof immessage.QryReadInfosResp
         * @static
         * @param {immessage.IQryReadInfosResp=} [properties] Properties to set
         * @returns {immessage.QryReadInfosResp} QryReadInfosResp instance
         */
        QryReadInfosResp.create = function create(properties) {
            return new QryReadInfosResp(properties);
        };

        /**
         * Encodes the specified QryReadInfosResp message. Does not implicitly {@link immessage.QryReadInfosResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryReadInfosResp
         * @static
         * @param {immessage.IQryReadInfosResp} message QryReadInfosResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryReadInfosResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (let i = 0; i < message.items.length; ++i)
                    $root.immessage.ReadInfoItem.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QryReadInfosResp message, length delimited. Does not implicitly {@link immessage.QryReadInfosResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryReadInfosResp
         * @static
         * @param {immessage.IQryReadInfosResp} message QryReadInfosResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryReadInfosResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryReadInfosResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryReadInfosResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryReadInfosResp} QryReadInfosResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryReadInfosResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryReadInfosResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.immessage.ReadInfoItem.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryReadInfosResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryReadInfosResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryReadInfosResp} QryReadInfosResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryReadInfosResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryReadInfosResp message.
         * @function verify
         * @memberof immessage.QryReadInfosResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryReadInfosResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (let i = 0; i < message.items.length; ++i) {
                    let error = $root.immessage.ReadInfoItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a QryReadInfosResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryReadInfosResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryReadInfosResp} QryReadInfosResp
         */
        QryReadInfosResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryReadInfosResp)
                return object;
            let message = new $root.immessage.QryReadInfosResp();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".immessage.QryReadInfosResp.items: array expected");
                message.items = [];
                for (let i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".immessage.QryReadInfosResp.items: object expected");
                    message.items[i] = $root.immessage.ReadInfoItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a QryReadInfosResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryReadInfosResp
         * @static
         * @param {immessage.QryReadInfosResp} message QryReadInfosResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryReadInfosResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (message.items && message.items.length) {
                object.items = [];
                for (let j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.immessage.ReadInfoItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this QryReadInfosResp to JSON.
         * @function toJSON
         * @memberof immessage.QryReadInfosResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryReadInfosResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryReadInfosResp
         * @function getTypeUrl
         * @memberof immessage.QryReadInfosResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryReadInfosResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryReadInfosResp";
        };

        return QryReadInfosResp;
    })();

    immessage.ReadInfoItem = (function() {

        /**
         * Properties of a ReadInfoItem.
         * @memberof immessage
         * @interface IReadInfoItem
         * @property {string|null} [msgId] ReadInfoItem msgId
         * @property {number|null} [readCount] ReadInfoItem readCount
         * @property {number|null} [totalCount] ReadInfoItem totalCount
         */

        /**
         * Constructs a new ReadInfoItem.
         * @memberof immessage
         * @classdesc Represents a ReadInfoItem.
         * @implements IReadInfoItem
         * @constructor
         * @param {immessage.IReadInfoItem=} [properties] Properties to set
         */
        function ReadInfoItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReadInfoItem msgId.
         * @member {string} msgId
         * @memberof immessage.ReadInfoItem
         * @instance
         */
        ReadInfoItem.prototype.msgId = "";

        /**
         * ReadInfoItem readCount.
         * @member {number} readCount
         * @memberof immessage.ReadInfoItem
         * @instance
         */
        ReadInfoItem.prototype.readCount = 0;

        /**
         * ReadInfoItem totalCount.
         * @member {number} totalCount
         * @memberof immessage.ReadInfoItem
         * @instance
         */
        ReadInfoItem.prototype.totalCount = 0;

        /**
         * Creates a new ReadInfoItem instance using the specified properties.
         * @function create
         * @memberof immessage.ReadInfoItem
         * @static
         * @param {immessage.IReadInfoItem=} [properties] Properties to set
         * @returns {immessage.ReadInfoItem} ReadInfoItem instance
         */
        ReadInfoItem.create = function create(properties) {
            return new ReadInfoItem(properties);
        };

        /**
         * Encodes the specified ReadInfoItem message. Does not implicitly {@link immessage.ReadInfoItem.verify|verify} messages.
         * @function encode
         * @memberof immessage.ReadInfoItem
         * @static
         * @param {immessage.IReadInfoItem} message ReadInfoItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReadInfoItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.msgId);
            if (message.readCount != null && Object.hasOwnProperty.call(message, "readCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.readCount);
            if (message.totalCount != null && Object.hasOwnProperty.call(message, "totalCount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.totalCount);
            return writer;
        };

        /**
         * Encodes the specified ReadInfoItem message, length delimited. Does not implicitly {@link immessage.ReadInfoItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.ReadInfoItem
         * @static
         * @param {immessage.IReadInfoItem} message ReadInfoItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReadInfoItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReadInfoItem message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.ReadInfoItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.ReadInfoItem} ReadInfoItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReadInfoItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.ReadInfoItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.msgId = reader.string();
                        break;
                    }
                case 2: {
                        message.readCount = reader.int32();
                        break;
                    }
                case 3: {
                        message.totalCount = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReadInfoItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.ReadInfoItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.ReadInfoItem} ReadInfoItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReadInfoItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReadInfoItem message.
         * @function verify
         * @memberof immessage.ReadInfoItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReadInfoItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            if (message.readCount != null && message.hasOwnProperty("readCount"))
                if (!$util.isInteger(message.readCount))
                    return "readCount: integer expected";
            if (message.totalCount != null && message.hasOwnProperty("totalCount"))
                if (!$util.isInteger(message.totalCount))
                    return "totalCount: integer expected";
            return null;
        };

        /**
         * Creates a ReadInfoItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.ReadInfoItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.ReadInfoItem} ReadInfoItem
         */
        ReadInfoItem.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.ReadInfoItem)
                return object;
            let message = new $root.immessage.ReadInfoItem();
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            if (object.readCount != null)
                message.readCount = object.readCount | 0;
            if (object.totalCount != null)
                message.totalCount = object.totalCount | 0;
            return message;
        };

        /**
         * Creates a plain object from a ReadInfoItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.ReadInfoItem
         * @static
         * @param {immessage.ReadInfoItem} message ReadInfoItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReadInfoItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.msgId = "";
                object.readCount = 0;
                object.totalCount = 0;
            }
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            if (message.readCount != null && message.hasOwnProperty("readCount"))
                object.readCount = message.readCount;
            if (message.totalCount != null && message.hasOwnProperty("totalCount"))
                object.totalCount = message.totalCount;
            return object;
        };

        /**
         * Converts this ReadInfoItem to JSON.
         * @function toJSON
         * @memberof immessage.ReadInfoItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReadInfoItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ReadInfoItem
         * @function getTypeUrl
         * @memberof immessage.ReadInfoItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ReadInfoItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.ReadInfoItem";
        };

        return ReadInfoItem;
    })();

    immessage.QryReadDetailReq = (function() {

        /**
         * Properties of a QryReadDetailReq.
         * @memberof immessage
         * @interface IQryReadDetailReq
         * @property {string|null} [targetId] QryReadDetailReq targetId
         * @property {immessage.ChannelType|null} [channelType] QryReadDetailReq channelType
         * @property {string|null} [msgId] QryReadDetailReq msgId
         */

        /**
         * Constructs a new QryReadDetailReq.
         * @memberof immessage
         * @classdesc Represents a QryReadDetailReq.
         * @implements IQryReadDetailReq
         * @constructor
         * @param {immessage.IQryReadDetailReq=} [properties] Properties to set
         */
        function QryReadDetailReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryReadDetailReq targetId.
         * @member {string} targetId
         * @memberof immessage.QryReadDetailReq
         * @instance
         */
        QryReadDetailReq.prototype.targetId = "";

        /**
         * QryReadDetailReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.QryReadDetailReq
         * @instance
         */
        QryReadDetailReq.prototype.channelType = 0;

        /**
         * QryReadDetailReq msgId.
         * @member {string} msgId
         * @memberof immessage.QryReadDetailReq
         * @instance
         */
        QryReadDetailReq.prototype.msgId = "";

        /**
         * Creates a new QryReadDetailReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryReadDetailReq
         * @static
         * @param {immessage.IQryReadDetailReq=} [properties] Properties to set
         * @returns {immessage.QryReadDetailReq} QryReadDetailReq instance
         */
        QryReadDetailReq.create = function create(properties) {
            return new QryReadDetailReq(properties);
        };

        /**
         * Encodes the specified QryReadDetailReq message. Does not implicitly {@link immessage.QryReadDetailReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryReadDetailReq
         * @static
         * @param {immessage.IQryReadDetailReq} message QryReadDetailReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryReadDetailReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.msgId);
            return writer;
        };

        /**
         * Encodes the specified QryReadDetailReq message, length delimited. Does not implicitly {@link immessage.QryReadDetailReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryReadDetailReq
         * @static
         * @param {immessage.IQryReadDetailReq} message QryReadDetailReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryReadDetailReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryReadDetailReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryReadDetailReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryReadDetailReq} QryReadDetailReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryReadDetailReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryReadDetailReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        message.msgId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryReadDetailReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryReadDetailReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryReadDetailReq} QryReadDetailReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryReadDetailReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryReadDetailReq message.
         * @function verify
         * @memberof immessage.QryReadDetailReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryReadDetailReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            return null;
        };

        /**
         * Creates a QryReadDetailReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryReadDetailReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryReadDetailReq} QryReadDetailReq
         */
        QryReadDetailReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryReadDetailReq)
                return object;
            let message = new $root.immessage.QryReadDetailReq();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            return message;
        };

        /**
         * Creates a plain object from a QryReadDetailReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryReadDetailReq
         * @static
         * @param {immessage.QryReadDetailReq} message QryReadDetailReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryReadDetailReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                object.msgId = "";
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            return object;
        };

        /**
         * Converts this QryReadDetailReq to JSON.
         * @function toJSON
         * @memberof immessage.QryReadDetailReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryReadDetailReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryReadDetailReq
         * @function getTypeUrl
         * @memberof immessage.QryReadDetailReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryReadDetailReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryReadDetailReq";
        };

        return QryReadDetailReq;
    })();

    immessage.QryReadDetailResp = (function() {

        /**
         * Properties of a QryReadDetailResp.
         * @memberof immessage
         * @interface IQryReadDetailResp
         * @property {number|null} [readCount] QryReadDetailResp readCount
         * @property {number|null} [memberCount] QryReadDetailResp memberCount
         * @property {Array.<immessage.IMemberReadDetailItem>|null} [readMembers] QryReadDetailResp readMembers
         * @property {Array.<immessage.IMemberReadDetailItem>|null} [unreadMembers] QryReadDetailResp unreadMembers
         */

        /**
         * Constructs a new QryReadDetailResp.
         * @memberof immessage
         * @classdesc Represents a QryReadDetailResp.
         * @implements IQryReadDetailResp
         * @constructor
         * @param {immessage.IQryReadDetailResp=} [properties] Properties to set
         */
        function QryReadDetailResp(properties) {
            this.readMembers = [];
            this.unreadMembers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryReadDetailResp readCount.
         * @member {number} readCount
         * @memberof immessage.QryReadDetailResp
         * @instance
         */
        QryReadDetailResp.prototype.readCount = 0;

        /**
         * QryReadDetailResp memberCount.
         * @member {number} memberCount
         * @memberof immessage.QryReadDetailResp
         * @instance
         */
        QryReadDetailResp.prototype.memberCount = 0;

        /**
         * QryReadDetailResp readMembers.
         * @member {Array.<immessage.IMemberReadDetailItem>} readMembers
         * @memberof immessage.QryReadDetailResp
         * @instance
         */
        QryReadDetailResp.prototype.readMembers = $util.emptyArray;

        /**
         * QryReadDetailResp unreadMembers.
         * @member {Array.<immessage.IMemberReadDetailItem>} unreadMembers
         * @memberof immessage.QryReadDetailResp
         * @instance
         */
        QryReadDetailResp.prototype.unreadMembers = $util.emptyArray;

        /**
         * Creates a new QryReadDetailResp instance using the specified properties.
         * @function create
         * @memberof immessage.QryReadDetailResp
         * @static
         * @param {immessage.IQryReadDetailResp=} [properties] Properties to set
         * @returns {immessage.QryReadDetailResp} QryReadDetailResp instance
         */
        QryReadDetailResp.create = function create(properties) {
            return new QryReadDetailResp(properties);
        };

        /**
         * Encodes the specified QryReadDetailResp message. Does not implicitly {@link immessage.QryReadDetailResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryReadDetailResp
         * @static
         * @param {immessage.IQryReadDetailResp} message QryReadDetailResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryReadDetailResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.readCount != null && Object.hasOwnProperty.call(message, "readCount"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.readCount);
            if (message.memberCount != null && Object.hasOwnProperty.call(message, "memberCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.memberCount);
            if (message.readMembers != null && message.readMembers.length)
                for (let i = 0; i < message.readMembers.length; ++i)
                    $root.immessage.MemberReadDetailItem.encode(message.readMembers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.unreadMembers != null && message.unreadMembers.length)
                for (let i = 0; i < message.unreadMembers.length; ++i)
                    $root.immessage.MemberReadDetailItem.encode(message.unreadMembers[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QryReadDetailResp message, length delimited. Does not implicitly {@link immessage.QryReadDetailResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryReadDetailResp
         * @static
         * @param {immessage.IQryReadDetailResp} message QryReadDetailResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryReadDetailResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryReadDetailResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryReadDetailResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryReadDetailResp} QryReadDetailResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryReadDetailResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryReadDetailResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.readCount = reader.int32();
                        break;
                    }
                case 2: {
                        message.memberCount = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.readMembers && message.readMembers.length))
                            message.readMembers = [];
                        message.readMembers.push($root.immessage.MemberReadDetailItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (!(message.unreadMembers && message.unreadMembers.length))
                            message.unreadMembers = [];
                        message.unreadMembers.push($root.immessage.MemberReadDetailItem.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryReadDetailResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryReadDetailResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryReadDetailResp} QryReadDetailResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryReadDetailResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryReadDetailResp message.
         * @function verify
         * @memberof immessage.QryReadDetailResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryReadDetailResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.readCount != null && message.hasOwnProperty("readCount"))
                if (!$util.isInteger(message.readCount))
                    return "readCount: integer expected";
            if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                if (!$util.isInteger(message.memberCount))
                    return "memberCount: integer expected";
            if (message.readMembers != null && message.hasOwnProperty("readMembers")) {
                if (!Array.isArray(message.readMembers))
                    return "readMembers: array expected";
                for (let i = 0; i < message.readMembers.length; ++i) {
                    let error = $root.immessage.MemberReadDetailItem.verify(message.readMembers[i]);
                    if (error)
                        return "readMembers." + error;
                }
            }
            if (message.unreadMembers != null && message.hasOwnProperty("unreadMembers")) {
                if (!Array.isArray(message.unreadMembers))
                    return "unreadMembers: array expected";
                for (let i = 0; i < message.unreadMembers.length; ++i) {
                    let error = $root.immessage.MemberReadDetailItem.verify(message.unreadMembers[i]);
                    if (error)
                        return "unreadMembers." + error;
                }
            }
            return null;
        };

        /**
         * Creates a QryReadDetailResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryReadDetailResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryReadDetailResp} QryReadDetailResp
         */
        QryReadDetailResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryReadDetailResp)
                return object;
            let message = new $root.immessage.QryReadDetailResp();
            if (object.readCount != null)
                message.readCount = object.readCount | 0;
            if (object.memberCount != null)
                message.memberCount = object.memberCount | 0;
            if (object.readMembers) {
                if (!Array.isArray(object.readMembers))
                    throw TypeError(".immessage.QryReadDetailResp.readMembers: array expected");
                message.readMembers = [];
                for (let i = 0; i < object.readMembers.length; ++i) {
                    if (typeof object.readMembers[i] !== "object")
                        throw TypeError(".immessage.QryReadDetailResp.readMembers: object expected");
                    message.readMembers[i] = $root.immessage.MemberReadDetailItem.fromObject(object.readMembers[i]);
                }
            }
            if (object.unreadMembers) {
                if (!Array.isArray(object.unreadMembers))
                    throw TypeError(".immessage.QryReadDetailResp.unreadMembers: array expected");
                message.unreadMembers = [];
                for (let i = 0; i < object.unreadMembers.length; ++i) {
                    if (typeof object.unreadMembers[i] !== "object")
                        throw TypeError(".immessage.QryReadDetailResp.unreadMembers: object expected");
                    message.unreadMembers[i] = $root.immessage.MemberReadDetailItem.fromObject(object.unreadMembers[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a QryReadDetailResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryReadDetailResp
         * @static
         * @param {immessage.QryReadDetailResp} message QryReadDetailResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryReadDetailResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.readMembers = [];
                object.unreadMembers = [];
            }
            if (options.defaults) {
                object.readCount = 0;
                object.memberCount = 0;
            }
            if (message.readCount != null && message.hasOwnProperty("readCount"))
                object.readCount = message.readCount;
            if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                object.memberCount = message.memberCount;
            if (message.readMembers && message.readMembers.length) {
                object.readMembers = [];
                for (let j = 0; j < message.readMembers.length; ++j)
                    object.readMembers[j] = $root.immessage.MemberReadDetailItem.toObject(message.readMembers[j], options);
            }
            if (message.unreadMembers && message.unreadMembers.length) {
                object.unreadMembers = [];
                for (let j = 0; j < message.unreadMembers.length; ++j)
                    object.unreadMembers[j] = $root.immessage.MemberReadDetailItem.toObject(message.unreadMembers[j], options);
            }
            return object;
        };

        /**
         * Converts this QryReadDetailResp to JSON.
         * @function toJSON
         * @memberof immessage.QryReadDetailResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryReadDetailResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryReadDetailResp
         * @function getTypeUrl
         * @memberof immessage.QryReadDetailResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryReadDetailResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryReadDetailResp";
        };

        return QryReadDetailResp;
    })();

    immessage.MemberReadDetailItem = (function() {

        /**
         * Properties of a MemberReadDetailItem.
         * @memberof immessage
         * @interface IMemberReadDetailItem
         * @property {immessage.IUserInfo|null} [member] MemberReadDetailItem member
         * @property {number|Long|null} [time] MemberReadDetailItem time
         */

        /**
         * Constructs a new MemberReadDetailItem.
         * @memberof immessage
         * @classdesc Represents a MemberReadDetailItem.
         * @implements IMemberReadDetailItem
         * @constructor
         * @param {immessage.IMemberReadDetailItem=} [properties] Properties to set
         */
        function MemberReadDetailItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MemberReadDetailItem member.
         * @member {immessage.IUserInfo|null|undefined} member
         * @memberof immessage.MemberReadDetailItem
         * @instance
         */
        MemberReadDetailItem.prototype.member = null;

        /**
         * MemberReadDetailItem time.
         * @member {number|Long} time
         * @memberof immessage.MemberReadDetailItem
         * @instance
         */
        MemberReadDetailItem.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new MemberReadDetailItem instance using the specified properties.
         * @function create
         * @memberof immessage.MemberReadDetailItem
         * @static
         * @param {immessage.IMemberReadDetailItem=} [properties] Properties to set
         * @returns {immessage.MemberReadDetailItem} MemberReadDetailItem instance
         */
        MemberReadDetailItem.create = function create(properties) {
            return new MemberReadDetailItem(properties);
        };

        /**
         * Encodes the specified MemberReadDetailItem message. Does not implicitly {@link immessage.MemberReadDetailItem.verify|verify} messages.
         * @function encode
         * @memberof immessage.MemberReadDetailItem
         * @static
         * @param {immessage.IMemberReadDetailItem} message MemberReadDetailItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemberReadDetailItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.member != null && Object.hasOwnProperty.call(message, "member"))
                $root.immessage.UserInfo.encode(message.member, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.time);
            return writer;
        };

        /**
         * Encodes the specified MemberReadDetailItem message, length delimited. Does not implicitly {@link immessage.MemberReadDetailItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.MemberReadDetailItem
         * @static
         * @param {immessage.IMemberReadDetailItem} message MemberReadDetailItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemberReadDetailItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MemberReadDetailItem message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.MemberReadDetailItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.MemberReadDetailItem} MemberReadDetailItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemberReadDetailItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.MemberReadDetailItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.member = $root.immessage.UserInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.time = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MemberReadDetailItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.MemberReadDetailItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.MemberReadDetailItem} MemberReadDetailItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemberReadDetailItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MemberReadDetailItem message.
         * @function verify
         * @memberof immessage.MemberReadDetailItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MemberReadDetailItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.member != null && message.hasOwnProperty("member")) {
                let error = $root.immessage.UserInfo.verify(message.member);
                if (error)
                    return "member." + error;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            return null;
        };

        /**
         * Creates a MemberReadDetailItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.MemberReadDetailItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.MemberReadDetailItem} MemberReadDetailItem
         */
        MemberReadDetailItem.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.MemberReadDetailItem)
                return object;
            let message = new $root.immessage.MemberReadDetailItem();
            if (object.member != null) {
                if (typeof object.member !== "object")
                    throw TypeError(".immessage.MemberReadDetailItem.member: object expected");
                message.member = $root.immessage.UserInfo.fromObject(object.member);
            }
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a MemberReadDetailItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.MemberReadDetailItem
         * @static
         * @param {immessage.MemberReadDetailItem} message MemberReadDetailItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MemberReadDetailItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.member = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
            }
            if (message.member != null && message.hasOwnProperty("member"))
                object.member = $root.immessage.UserInfo.toObject(message.member, options);
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            return object;
        };

        /**
         * Converts this MemberReadDetailItem to JSON.
         * @function toJSON
         * @memberof immessage.MemberReadDetailItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MemberReadDetailItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MemberReadDetailItem
         * @function getTypeUrl
         * @memberof immessage.MemberReadDetailItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MemberReadDetailItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.MemberReadDetailItem";
        };

        return MemberReadDetailItem;
    })();

    immessage.QryConverReq = (function() {

        /**
         * Properties of a QryConverReq.
         * @memberof immessage
         * @interface IQryConverReq
         * @property {string|null} [targetId] QryConverReq targetId
         * @property {immessage.ChannelType|null} [channelType] QryConverReq channelType
         * @property {boolean|null} [isInner] QryConverReq isInner
         * @property {Array.<string>|null} [userIds] QryConverReq userIds
         * @property {string|null} [targetIdAlias] QryConverReq targetIdAlias
         */

        /**
         * Constructs a new QryConverReq.
         * @memberof immessage
         * @classdesc Represents a QryConverReq.
         * @implements IQryConverReq
         * @constructor
         * @param {immessage.IQryConverReq=} [properties] Properties to set
         */
        function QryConverReq(properties) {
            this.userIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryConverReq targetId.
         * @member {string} targetId
         * @memberof immessage.QryConverReq
         * @instance
         */
        QryConverReq.prototype.targetId = "";

        /**
         * QryConverReq channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.QryConverReq
         * @instance
         */
        QryConverReq.prototype.channelType = 0;

        /**
         * QryConverReq isInner.
         * @member {boolean} isInner
         * @memberof immessage.QryConverReq
         * @instance
         */
        QryConverReq.prototype.isInner = false;

        /**
         * QryConverReq userIds.
         * @member {Array.<string>} userIds
         * @memberof immessage.QryConverReq
         * @instance
         */
        QryConverReq.prototype.userIds = $util.emptyArray;

        /**
         * QryConverReq targetIdAlias.
         * @member {string} targetIdAlias
         * @memberof immessage.QryConverReq
         * @instance
         */
        QryConverReq.prototype.targetIdAlias = "";

        /**
         * Creates a new QryConverReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryConverReq
         * @static
         * @param {immessage.IQryConverReq=} [properties] Properties to set
         * @returns {immessage.QryConverReq} QryConverReq instance
         */
        QryConverReq.create = function create(properties) {
            return new QryConverReq(properties);
        };

        /**
         * Encodes the specified QryConverReq message. Does not implicitly {@link immessage.QryConverReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryConverReq
         * @static
         * @param {immessage.IQryConverReq} message QryConverReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryConverReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.isInner != null && Object.hasOwnProperty.call(message, "isInner"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isInner);
            if (message.userIds != null && message.userIds.length)
                for (let i = 0; i < message.userIds.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.userIds[i]);
            if (message.targetIdAlias != null && Object.hasOwnProperty.call(message, "targetIdAlias"))
                writer.uint32(/* id 51, wireType 2 =*/410).string(message.targetIdAlias);
            return writer;
        };

        /**
         * Encodes the specified QryConverReq message, length delimited. Does not implicitly {@link immessage.QryConverReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryConverReq
         * @static
         * @param {immessage.IQryConverReq} message QryConverReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryConverReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryConverReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryConverReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryConverReq} QryConverReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryConverReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryConverReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        message.isInner = reader.bool();
                        break;
                    }
                case 4: {
                        if (!(message.userIds && message.userIds.length))
                            message.userIds = [];
                        message.userIds.push(reader.string());
                        break;
                    }
                case 51: {
                        message.targetIdAlias = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryConverReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryConverReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryConverReq} QryConverReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryConverReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryConverReq message.
         * @function verify
         * @memberof immessage.QryConverReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryConverReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.isInner != null && message.hasOwnProperty("isInner"))
                if (typeof message.isInner !== "boolean")
                    return "isInner: boolean expected";
            if (message.userIds != null && message.hasOwnProperty("userIds")) {
                if (!Array.isArray(message.userIds))
                    return "userIds: array expected";
                for (let i = 0; i < message.userIds.length; ++i)
                    if (!$util.isString(message.userIds[i]))
                        return "userIds: string[] expected";
            }
            if (message.targetIdAlias != null && message.hasOwnProperty("targetIdAlias"))
                if (!$util.isString(message.targetIdAlias))
                    return "targetIdAlias: string expected";
            return null;
        };

        /**
         * Creates a QryConverReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryConverReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryConverReq} QryConverReq
         */
        QryConverReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryConverReq)
                return object;
            let message = new $root.immessage.QryConverReq();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.isInner != null)
                message.isInner = Boolean(object.isInner);
            if (object.userIds) {
                if (!Array.isArray(object.userIds))
                    throw TypeError(".immessage.QryConverReq.userIds: array expected");
                message.userIds = [];
                for (let i = 0; i < object.userIds.length; ++i)
                    message.userIds[i] = String(object.userIds[i]);
            }
            if (object.targetIdAlias != null)
                message.targetIdAlias = String(object.targetIdAlias);
            return message;
        };

        /**
         * Creates a plain object from a QryConverReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryConverReq
         * @static
         * @param {immessage.QryConverReq} message QryConverReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryConverReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.userIds = [];
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                object.isInner = false;
                object.targetIdAlias = "";
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.isInner != null && message.hasOwnProperty("isInner"))
                object.isInner = message.isInner;
            if (message.userIds && message.userIds.length) {
                object.userIds = [];
                for (let j = 0; j < message.userIds.length; ++j)
                    object.userIds[j] = message.userIds[j];
            }
            if (message.targetIdAlias != null && message.hasOwnProperty("targetIdAlias"))
                object.targetIdAlias = message.targetIdAlias;
            return object;
        };

        /**
         * Converts this QryConverReq to JSON.
         * @function toJSON
         * @memberof immessage.QryConverReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryConverReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryConverReq
         * @function getTypeUrl
         * @memberof immessage.QryConverReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryConverReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryConverReq";
        };

        return QryConverReq;
    })();

    immessage.TagConvers = (function() {

        /**
         * Properties of a TagConvers.
         * @memberof immessage
         * @interface ITagConvers
         * @property {string|null} [tag] TagConvers tag
         * @property {string|null} [tagName] TagConvers tagName
         * @property {Array.<immessage.ISimpleConversation>|null} [convers] TagConvers convers
         */

        /**
         * Constructs a new TagConvers.
         * @memberof immessage
         * @classdesc Represents a TagConvers.
         * @implements ITagConvers
         * @constructor
         * @param {immessage.ITagConvers=} [properties] Properties to set
         */
        function TagConvers(properties) {
            this.convers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TagConvers tag.
         * @member {string} tag
         * @memberof immessage.TagConvers
         * @instance
         */
        TagConvers.prototype.tag = "";

        /**
         * TagConvers tagName.
         * @member {string} tagName
         * @memberof immessage.TagConvers
         * @instance
         */
        TagConvers.prototype.tagName = "";

        /**
         * TagConvers convers.
         * @member {Array.<immessage.ISimpleConversation>} convers
         * @memberof immessage.TagConvers
         * @instance
         */
        TagConvers.prototype.convers = $util.emptyArray;

        /**
         * Creates a new TagConvers instance using the specified properties.
         * @function create
         * @memberof immessage.TagConvers
         * @static
         * @param {immessage.ITagConvers=} [properties] Properties to set
         * @returns {immessage.TagConvers} TagConvers instance
         */
        TagConvers.create = function create(properties) {
            return new TagConvers(properties);
        };

        /**
         * Encodes the specified TagConvers message. Does not implicitly {@link immessage.TagConvers.verify|verify} messages.
         * @function encode
         * @memberof immessage.TagConvers
         * @static
         * @param {immessage.ITagConvers} message TagConvers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TagConvers.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tag != null && Object.hasOwnProperty.call(message, "tag"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tag);
            if (message.tagName != null && Object.hasOwnProperty.call(message, "tagName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.tagName);
            if (message.convers != null && message.convers.length)
                for (let i = 0; i < message.convers.length; ++i)
                    $root.immessage.SimpleConversation.encode(message.convers[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TagConvers message, length delimited. Does not implicitly {@link immessage.TagConvers.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.TagConvers
         * @static
         * @param {immessage.ITagConvers} message TagConvers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TagConvers.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TagConvers message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.TagConvers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.TagConvers} TagConvers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TagConvers.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.TagConvers();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.tag = reader.string();
                        break;
                    }
                case 2: {
                        message.tagName = reader.string();
                        break;
                    }
                case 11: {
                        if (!(message.convers && message.convers.length))
                            message.convers = [];
                        message.convers.push($root.immessage.SimpleConversation.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TagConvers message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.TagConvers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.TagConvers} TagConvers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TagConvers.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TagConvers message.
         * @function verify
         * @memberof immessage.TagConvers
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TagConvers.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tag != null && message.hasOwnProperty("tag"))
                if (!$util.isString(message.tag))
                    return "tag: string expected";
            if (message.tagName != null && message.hasOwnProperty("tagName"))
                if (!$util.isString(message.tagName))
                    return "tagName: string expected";
            if (message.convers != null && message.hasOwnProperty("convers")) {
                if (!Array.isArray(message.convers))
                    return "convers: array expected";
                for (let i = 0; i < message.convers.length; ++i) {
                    let error = $root.immessage.SimpleConversation.verify(message.convers[i]);
                    if (error)
                        return "convers." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TagConvers message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.TagConvers
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.TagConvers} TagConvers
         */
        TagConvers.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.TagConvers)
                return object;
            let message = new $root.immessage.TagConvers();
            if (object.tag != null)
                message.tag = String(object.tag);
            if (object.tagName != null)
                message.tagName = String(object.tagName);
            if (object.convers) {
                if (!Array.isArray(object.convers))
                    throw TypeError(".immessage.TagConvers.convers: array expected");
                message.convers = [];
                for (let i = 0; i < object.convers.length; ++i) {
                    if (typeof object.convers[i] !== "object")
                        throw TypeError(".immessage.TagConvers.convers: object expected");
                    message.convers[i] = $root.immessage.SimpleConversation.fromObject(object.convers[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TagConvers message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.TagConvers
         * @static
         * @param {immessage.TagConvers} message TagConvers
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TagConvers.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.convers = [];
            if (options.defaults) {
                object.tag = "";
                object.tagName = "";
            }
            if (message.tag != null && message.hasOwnProperty("tag"))
                object.tag = message.tag;
            if (message.tagName != null && message.hasOwnProperty("tagName"))
                object.tagName = message.tagName;
            if (message.convers && message.convers.length) {
                object.convers = [];
                for (let j = 0; j < message.convers.length; ++j)
                    object.convers[j] = $root.immessage.SimpleConversation.toObject(message.convers[j], options);
            }
            return object;
        };

        /**
         * Converts this TagConvers to JSON.
         * @function toJSON
         * @memberof immessage.TagConvers
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TagConvers.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TagConvers
         * @function getTypeUrl
         * @memberof immessage.TagConvers
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TagConvers.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.TagConvers";
        };

        return TagConvers;
    })();

    immessage.UserConverTags = (function() {

        /**
         * Properties of a UserConverTags.
         * @memberof immessage
         * @interface IUserConverTags
         * @property {Array.<immessage.IConverTag>|null} [tags] UserConverTags tags
         */

        /**
         * Constructs a new UserConverTags.
         * @memberof immessage
         * @classdesc Represents a UserConverTags.
         * @implements IUserConverTags
         * @constructor
         * @param {immessage.IUserConverTags=} [properties] Properties to set
         */
        function UserConverTags(properties) {
            this.tags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserConverTags tags.
         * @member {Array.<immessage.IConverTag>} tags
         * @memberof immessage.UserConverTags
         * @instance
         */
        UserConverTags.prototype.tags = $util.emptyArray;

        /**
         * Creates a new UserConverTags instance using the specified properties.
         * @function create
         * @memberof immessage.UserConverTags
         * @static
         * @param {immessage.IUserConverTags=} [properties] Properties to set
         * @returns {immessage.UserConverTags} UserConverTags instance
         */
        UserConverTags.create = function create(properties) {
            return new UserConverTags(properties);
        };

        /**
         * Encodes the specified UserConverTags message. Does not implicitly {@link immessage.UserConverTags.verify|verify} messages.
         * @function encode
         * @memberof immessage.UserConverTags
         * @static
         * @param {immessage.IUserConverTags} message UserConverTags message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserConverTags.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    $root.immessage.ConverTag.encode(message.tags[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UserConverTags message, length delimited. Does not implicitly {@link immessage.UserConverTags.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UserConverTags
         * @static
         * @param {immessage.IUserConverTags} message UserConverTags message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserConverTags.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserConverTags message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UserConverTags
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UserConverTags} UserConverTags
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserConverTags.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UserConverTags();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push($root.immessage.ConverTag.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserConverTags message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UserConverTags
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UserConverTags} UserConverTags
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserConverTags.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserConverTags message.
         * @function verify
         * @memberof immessage.UserConverTags
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserConverTags.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i) {
                    let error = $root.immessage.ConverTag.verify(message.tags[i]);
                    if (error)
                        return "tags." + error;
                }
            }
            return null;
        };

        /**
         * Creates a UserConverTags message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UserConverTags
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UserConverTags} UserConverTags
         */
        UserConverTags.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UserConverTags)
                return object;
            let message = new $root.immessage.UserConverTags();
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".immessage.UserConverTags.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i) {
                    if (typeof object.tags[i] !== "object")
                        throw TypeError(".immessage.UserConverTags.tags: object expected");
                    message.tags[i] = $root.immessage.ConverTag.fromObject(object.tags[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a UserConverTags message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UserConverTags
         * @static
         * @param {immessage.UserConverTags} message UserConverTags
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserConverTags.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.tags = [];
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = $root.immessage.ConverTag.toObject(message.tags[j], options);
            }
            return object;
        };

        /**
         * Converts this UserConverTags to JSON.
         * @function toJSON
         * @memberof immessage.UserConverTags
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserConverTags.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserConverTags
         * @function getTypeUrl
         * @memberof immessage.UserConverTags
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserConverTags.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UserConverTags";
        };

        return UserConverTags;
    })();

    immessage.ConverTag = (function() {

        /**
         * Properties of a ConverTag.
         * @memberof immessage
         * @interface IConverTag
         * @property {string|null} [tag] ConverTag tag
         * @property {string|null} [tagName] ConverTag tagName
         * @property {immessage.ConverTagType|null} [tagType] ConverTag tagType
         */

        /**
         * Constructs a new ConverTag.
         * @memberof immessage
         * @classdesc Represents a ConverTag.
         * @implements IConverTag
         * @constructor
         * @param {immessage.IConverTag=} [properties] Properties to set
         */
        function ConverTag(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConverTag tag.
         * @member {string} tag
         * @memberof immessage.ConverTag
         * @instance
         */
        ConverTag.prototype.tag = "";

        /**
         * ConverTag tagName.
         * @member {string} tagName
         * @memberof immessage.ConverTag
         * @instance
         */
        ConverTag.prototype.tagName = "";

        /**
         * ConverTag tagType.
         * @member {immessage.ConverTagType} tagType
         * @memberof immessage.ConverTag
         * @instance
         */
        ConverTag.prototype.tagType = 0;

        /**
         * Creates a new ConverTag instance using the specified properties.
         * @function create
         * @memberof immessage.ConverTag
         * @static
         * @param {immessage.IConverTag=} [properties] Properties to set
         * @returns {immessage.ConverTag} ConverTag instance
         */
        ConverTag.create = function create(properties) {
            return new ConverTag(properties);
        };

        /**
         * Encodes the specified ConverTag message. Does not implicitly {@link immessage.ConverTag.verify|verify} messages.
         * @function encode
         * @memberof immessage.ConverTag
         * @static
         * @param {immessage.IConverTag} message ConverTag message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConverTag.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tag != null && Object.hasOwnProperty.call(message, "tag"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tag);
            if (message.tagName != null && Object.hasOwnProperty.call(message, "tagName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.tagName);
            if (message.tagType != null && Object.hasOwnProperty.call(message, "tagType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tagType);
            return writer;
        };

        /**
         * Encodes the specified ConverTag message, length delimited. Does not implicitly {@link immessage.ConverTag.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.ConverTag
         * @static
         * @param {immessage.IConverTag} message ConverTag message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConverTag.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConverTag message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.ConverTag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.ConverTag} ConverTag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConverTag.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.ConverTag();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.tag = reader.string();
                        break;
                    }
                case 2: {
                        message.tagName = reader.string();
                        break;
                    }
                case 3: {
                        message.tagType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConverTag message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.ConverTag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.ConverTag} ConverTag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConverTag.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConverTag message.
         * @function verify
         * @memberof immessage.ConverTag
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConverTag.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tag != null && message.hasOwnProperty("tag"))
                if (!$util.isString(message.tag))
                    return "tag: string expected";
            if (message.tagName != null && message.hasOwnProperty("tagName"))
                if (!$util.isString(message.tagName))
                    return "tagName: string expected";
            if (message.tagType != null && message.hasOwnProperty("tagType"))
                switch (message.tagType) {
                default:
                    return "tagType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a ConverTag message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.ConverTag
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.ConverTag} ConverTag
         */
        ConverTag.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.ConverTag)
                return object;
            let message = new $root.immessage.ConverTag();
            if (object.tag != null)
                message.tag = String(object.tag);
            if (object.tagName != null)
                message.tagName = String(object.tagName);
            switch (object.tagType) {
            default:
                if (typeof object.tagType === "number") {
                    message.tagType = object.tagType;
                    break;
                }
                break;
            case "UserConverTag":
            case 0:
                message.tagType = 0;
                break;
            case "SystemConverTag":
            case 1:
                message.tagType = 1;
                break;
            case "GlobalConverTag":
            case 2:
                message.tagType = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ConverTag message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.ConverTag
         * @static
         * @param {immessage.ConverTag} message ConverTag
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConverTag.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.tag = "";
                object.tagName = "";
                object.tagType = options.enums === String ? "UserConverTag" : 0;
            }
            if (message.tag != null && message.hasOwnProperty("tag"))
                object.tag = message.tag;
            if (message.tagName != null && message.hasOwnProperty("tagName"))
                object.tagName = message.tagName;
            if (message.tagType != null && message.hasOwnProperty("tagType"))
                object.tagType = options.enums === String ? $root.immessage.ConverTagType[message.tagType] === undefined ? message.tagType : $root.immessage.ConverTagType[message.tagType] : message.tagType;
            return object;
        };

        /**
         * Converts this ConverTag to JSON.
         * @function toJSON
         * @memberof immessage.ConverTag
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConverTag.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ConverTag
         * @function getTypeUrl
         * @memberof immessage.ConverTag
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConverTag.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.ConverTag";
        };

        return ConverTag;
    })();

    immessage.ConverExts = (function() {

        /**
         * Properties of a ConverExts.
         * @memberof immessage
         * @interface IConverExts
         * @property {Object.<string,boolean>|null} [converTags] ConverExts converTags
         */

        /**
         * Constructs a new ConverExts.
         * @memberof immessage
         * @classdesc Represents a ConverExts.
         * @implements IConverExts
         * @constructor
         * @param {immessage.IConverExts=} [properties] Properties to set
         */
        function ConverExts(properties) {
            this.converTags = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConverExts converTags.
         * @member {Object.<string,boolean>} converTags
         * @memberof immessage.ConverExts
         * @instance
         */
        ConverExts.prototype.converTags = $util.emptyObject;

        /**
         * Creates a new ConverExts instance using the specified properties.
         * @function create
         * @memberof immessage.ConverExts
         * @static
         * @param {immessage.IConverExts=} [properties] Properties to set
         * @returns {immessage.ConverExts} ConverExts instance
         */
        ConverExts.create = function create(properties) {
            return new ConverExts(properties);
        };

        /**
         * Encodes the specified ConverExts message. Does not implicitly {@link immessage.ConverExts.verify|verify} messages.
         * @function encode
         * @memberof immessage.ConverExts
         * @static
         * @param {immessage.IConverExts} message ConverExts message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConverExts.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.converTags != null && Object.hasOwnProperty.call(message, "converTags"))
                for (let keys = Object.keys(message.converTags), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).bool(message.converTags[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ConverExts message, length delimited. Does not implicitly {@link immessage.ConverExts.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.ConverExts
         * @static
         * @param {immessage.IConverExts} message ConverExts message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConverExts.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConverExts message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.ConverExts
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.ConverExts} ConverExts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConverExts.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.ConverExts(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (message.converTags === $util.emptyObject)
                            message.converTags = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = false;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.bool();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.converTags[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConverExts message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.ConverExts
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.ConverExts} ConverExts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConverExts.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConverExts message.
         * @function verify
         * @memberof immessage.ConverExts
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConverExts.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.converTags != null && message.hasOwnProperty("converTags")) {
                if (!$util.isObject(message.converTags))
                    return "converTags: object expected";
                let key = Object.keys(message.converTags);
                for (let i = 0; i < key.length; ++i)
                    if (typeof message.converTags[key[i]] !== "boolean")
                        return "converTags: boolean{k:string} expected";
            }
            return null;
        };

        /**
         * Creates a ConverExts message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.ConverExts
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.ConverExts} ConverExts
         */
        ConverExts.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.ConverExts)
                return object;
            let message = new $root.immessage.ConverExts();
            if (object.converTags) {
                if (typeof object.converTags !== "object")
                    throw TypeError(".immessage.ConverExts.converTags: object expected");
                message.converTags = {};
                for (let keys = Object.keys(object.converTags), i = 0; i < keys.length; ++i)
                    message.converTags[keys[i]] = Boolean(object.converTags[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from a ConverExts message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.ConverExts
         * @static
         * @param {immessage.ConverExts} message ConverExts
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConverExts.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.converTags = {};
            let keys2;
            if (message.converTags && (keys2 = Object.keys(message.converTags)).length) {
                object.converTags = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.converTags[keys2[j]] = message.converTags[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this ConverExts to JSON.
         * @function toJSON
         * @memberof immessage.ConverExts
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConverExts.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ConverExts
         * @function getTypeUrl
         * @memberof immessage.ConverExts
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConverExts.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.ConverExts";
        };

        return ConverExts;
    })();

    /**
     * ConverTagType enum.
     * @name immessage.ConverTagType
     * @enum {number}
     * @property {number} UserConverTag=0 UserConverTag value
     * @property {number} SystemConverTag=1 SystemConverTag value
     * @property {number} GlobalConverTag=2 GlobalConverTag value
     */
    immessage.ConverTagType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UserConverTag"] = 0;
        values[valuesById[1] = "SystemConverTag"] = 1;
        values[valuesById[2] = "GlobalConverTag"] = 2;
        return values;
    })();

    immessage.UserInfo = (function() {

        /**
         * Properties of a UserInfo.
         * @memberof immessage
         * @interface IUserInfo
         * @property {string|null} [userId] UserInfo userId
         * @property {string|null} [nickname] UserInfo nickname
         * @property {string|null} [userPortrait] UserInfo userPortrait
         * @property {Array.<immessage.IKvItem>|null} [extFields] UserInfo extFields
         * @property {number|Long|null} [updatedTime] UserInfo updatedTime
         * @property {Array.<immessage.IKvItem>|null} [settings] UserInfo settings
         * @property {Array.<immessage.IKvItem>|null} [statuses] UserInfo statuses
         * @property {immessage.UserType|null} [userType] UserInfo userType
         * @property {boolean|null} [noCover] UserInfo noCover
         * @property {Array.<immessage.IPermitConver>|null} [permitConvers] UserInfo permitConvers
         */

        /**
         * Constructs a new UserInfo.
         * @memberof immessage
         * @classdesc Represents a UserInfo.
         * @implements IUserInfo
         * @constructor
         * @param {immessage.IUserInfo=} [properties] Properties to set
         */
        function UserInfo(properties) {
            this.extFields = [];
            this.settings = [];
            this.statuses = [];
            this.permitConvers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserInfo userId.
         * @member {string} userId
         * @memberof immessage.UserInfo
         * @instance
         */
        UserInfo.prototype.userId = "";

        /**
         * UserInfo nickname.
         * @member {string} nickname
         * @memberof immessage.UserInfo
         * @instance
         */
        UserInfo.prototype.nickname = "";

        /**
         * UserInfo userPortrait.
         * @member {string} userPortrait
         * @memberof immessage.UserInfo
         * @instance
         */
        UserInfo.prototype.userPortrait = "";

        /**
         * UserInfo extFields.
         * @member {Array.<immessage.IKvItem>} extFields
         * @memberof immessage.UserInfo
         * @instance
         */
        UserInfo.prototype.extFields = $util.emptyArray;

        /**
         * UserInfo updatedTime.
         * @member {number|Long} updatedTime
         * @memberof immessage.UserInfo
         * @instance
         */
        UserInfo.prototype.updatedTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserInfo settings.
         * @member {Array.<immessage.IKvItem>} settings
         * @memberof immessage.UserInfo
         * @instance
         */
        UserInfo.prototype.settings = $util.emptyArray;

        /**
         * UserInfo statuses.
         * @member {Array.<immessage.IKvItem>} statuses
         * @memberof immessage.UserInfo
         * @instance
         */
        UserInfo.prototype.statuses = $util.emptyArray;

        /**
         * UserInfo userType.
         * @member {immessage.UserType} userType
         * @memberof immessage.UserInfo
         * @instance
         */
        UserInfo.prototype.userType = 0;

        /**
         * UserInfo noCover.
         * @member {boolean} noCover
         * @memberof immessage.UserInfo
         * @instance
         */
        UserInfo.prototype.noCover = false;

        /**
         * UserInfo permitConvers.
         * @member {Array.<immessage.IPermitConver>} permitConvers
         * @memberof immessage.UserInfo
         * @instance
         */
        UserInfo.prototype.permitConvers = $util.emptyArray;

        /**
         * Creates a new UserInfo instance using the specified properties.
         * @function create
         * @memberof immessage.UserInfo
         * @static
         * @param {immessage.IUserInfo=} [properties] Properties to set
         * @returns {immessage.UserInfo} UserInfo instance
         */
        UserInfo.create = function create(properties) {
            return new UserInfo(properties);
        };

        /**
         * Encodes the specified UserInfo message. Does not implicitly {@link immessage.UserInfo.verify|verify} messages.
         * @function encode
         * @memberof immessage.UserInfo
         * @static
         * @param {immessage.IUserInfo} message UserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickname);
            if (message.userPortrait != null && Object.hasOwnProperty.call(message, "userPortrait"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.userPortrait);
            if (message.extFields != null && message.extFields.length)
                for (let i = 0; i < message.extFields.length; ++i)
                    $root.immessage.KvItem.encode(message.extFields[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.updatedTime != null && Object.hasOwnProperty.call(message, "updatedTime"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.updatedTime);
            if (message.settings != null && message.settings.length)
                for (let i = 0; i < message.settings.length; ++i)
                    $root.immessage.KvItem.encode(message.settings[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.statuses != null && message.statuses.length)
                for (let i = 0; i < message.statuses.length; ++i)
                    $root.immessage.KvItem.encode(message.statuses[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.userType != null && Object.hasOwnProperty.call(message, "userType"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.userType);
            if (message.noCover != null && Object.hasOwnProperty.call(message, "noCover"))
                writer.uint32(/* id 100, wireType 0 =*/800).bool(message.noCover);
            if (message.permitConvers != null && message.permitConvers.length)
                for (let i = 0; i < message.permitConvers.length; ++i)
                    $root.immessage.PermitConver.encode(message.permitConvers[i], writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UserInfo message, length delimited. Does not implicitly {@link immessage.UserInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UserInfo
         * @static
         * @param {immessage.IUserInfo} message UserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserInfo message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UserInfo} UserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UserInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.nickname = reader.string();
                        break;
                    }
                case 3: {
                        message.userPortrait = reader.string();
                        break;
                    }
                case 4: {
                        if (!(message.extFields && message.extFields.length))
                            message.extFields = [];
                        message.extFields.push($root.immessage.KvItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.updatedTime = reader.int64();
                        break;
                    }
                case 6: {
                        if (!(message.settings && message.settings.length))
                            message.settings = [];
                        message.settings.push($root.immessage.KvItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        if (!(message.statuses && message.statuses.length))
                            message.statuses = [];
                        message.statuses.push($root.immessage.KvItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 8: {
                        message.userType = reader.int32();
                        break;
                    }
                case 100: {
                        message.noCover = reader.bool();
                        break;
                    }
                case 101: {
                        if (!(message.permitConvers && message.permitConvers.length))
                            message.permitConvers = [];
                        message.permitConvers.push($root.immessage.PermitConver.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UserInfo} UserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserInfo message.
         * @function verify
         * @memberof immessage.UserInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                if (!$util.isString(message.nickname))
                    return "nickname: string expected";
            if (message.userPortrait != null && message.hasOwnProperty("userPortrait"))
                if (!$util.isString(message.userPortrait))
                    return "userPortrait: string expected";
            if (message.extFields != null && message.hasOwnProperty("extFields")) {
                if (!Array.isArray(message.extFields))
                    return "extFields: array expected";
                for (let i = 0; i < message.extFields.length; ++i) {
                    let error = $root.immessage.KvItem.verify(message.extFields[i]);
                    if (error)
                        return "extFields." + error;
                }
            }
            if (message.updatedTime != null && message.hasOwnProperty("updatedTime"))
                if (!$util.isInteger(message.updatedTime) && !(message.updatedTime && $util.isInteger(message.updatedTime.low) && $util.isInteger(message.updatedTime.high)))
                    return "updatedTime: integer|Long expected";
            if (message.settings != null && message.hasOwnProperty("settings")) {
                if (!Array.isArray(message.settings))
                    return "settings: array expected";
                for (let i = 0; i < message.settings.length; ++i) {
                    let error = $root.immessage.KvItem.verify(message.settings[i]);
                    if (error)
                        return "settings." + error;
                }
            }
            if (message.statuses != null && message.hasOwnProperty("statuses")) {
                if (!Array.isArray(message.statuses))
                    return "statuses: array expected";
                for (let i = 0; i < message.statuses.length; ++i) {
                    let error = $root.immessage.KvItem.verify(message.statuses[i]);
                    if (error)
                        return "statuses." + error;
                }
            }
            if (message.userType != null && message.hasOwnProperty("userType"))
                switch (message.userType) {
                default:
                    return "userType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.noCover != null && message.hasOwnProperty("noCover"))
                if (typeof message.noCover !== "boolean")
                    return "noCover: boolean expected";
            if (message.permitConvers != null && message.hasOwnProperty("permitConvers")) {
                if (!Array.isArray(message.permitConvers))
                    return "permitConvers: array expected";
                for (let i = 0; i < message.permitConvers.length; ++i) {
                    let error = $root.immessage.PermitConver.verify(message.permitConvers[i]);
                    if (error)
                        return "permitConvers." + error;
                }
            }
            return null;
        };

        /**
         * Creates a UserInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UserInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UserInfo} UserInfo
         */
        UserInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UserInfo)
                return object;
            let message = new $root.immessage.UserInfo();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.nickname != null)
                message.nickname = String(object.nickname);
            if (object.userPortrait != null)
                message.userPortrait = String(object.userPortrait);
            if (object.extFields) {
                if (!Array.isArray(object.extFields))
                    throw TypeError(".immessage.UserInfo.extFields: array expected");
                message.extFields = [];
                for (let i = 0; i < object.extFields.length; ++i) {
                    if (typeof object.extFields[i] !== "object")
                        throw TypeError(".immessage.UserInfo.extFields: object expected");
                    message.extFields[i] = $root.immessage.KvItem.fromObject(object.extFields[i]);
                }
            }
            if (object.updatedTime != null)
                if ($util.Long)
                    (message.updatedTime = $util.Long.fromValue(object.updatedTime)).unsigned = false;
                else if (typeof object.updatedTime === "string")
                    message.updatedTime = parseInt(object.updatedTime, 10);
                else if (typeof object.updatedTime === "number")
                    message.updatedTime = object.updatedTime;
                else if (typeof object.updatedTime === "object")
                    message.updatedTime = new $util.LongBits(object.updatedTime.low >>> 0, object.updatedTime.high >>> 0).toNumber();
            if (object.settings) {
                if (!Array.isArray(object.settings))
                    throw TypeError(".immessage.UserInfo.settings: array expected");
                message.settings = [];
                for (let i = 0; i < object.settings.length; ++i) {
                    if (typeof object.settings[i] !== "object")
                        throw TypeError(".immessage.UserInfo.settings: object expected");
                    message.settings[i] = $root.immessage.KvItem.fromObject(object.settings[i]);
                }
            }
            if (object.statuses) {
                if (!Array.isArray(object.statuses))
                    throw TypeError(".immessage.UserInfo.statuses: array expected");
                message.statuses = [];
                for (let i = 0; i < object.statuses.length; ++i) {
                    if (typeof object.statuses[i] !== "object")
                        throw TypeError(".immessage.UserInfo.statuses: object expected");
                    message.statuses[i] = $root.immessage.KvItem.fromObject(object.statuses[i]);
                }
            }
            switch (object.userType) {
            default:
                if (typeof object.userType === "number") {
                    message.userType = object.userType;
                    break;
                }
                break;
            case "User":
            case 0:
                message.userType = 0;
                break;
            case "Bot":
            case 1:
                message.userType = 1;
                break;
            }
            if (object.noCover != null)
                message.noCover = Boolean(object.noCover);
            if (object.permitConvers) {
                if (!Array.isArray(object.permitConvers))
                    throw TypeError(".immessage.UserInfo.permitConvers: array expected");
                message.permitConvers = [];
                for (let i = 0; i < object.permitConvers.length; ++i) {
                    if (typeof object.permitConvers[i] !== "object")
                        throw TypeError(".immessage.UserInfo.permitConvers: object expected");
                    message.permitConvers[i] = $root.immessage.PermitConver.fromObject(object.permitConvers[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a UserInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UserInfo
         * @static
         * @param {immessage.UserInfo} message UserInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.extFields = [];
                object.settings = [];
                object.statuses = [];
                object.permitConvers = [];
            }
            if (options.defaults) {
                object.userId = "";
                object.nickname = "";
                object.userPortrait = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.updatedTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.updatedTime = options.longs === String ? "0" : 0;
                object.userType = options.enums === String ? "User" : 0;
                object.noCover = false;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                object.nickname = message.nickname;
            if (message.userPortrait != null && message.hasOwnProperty("userPortrait"))
                object.userPortrait = message.userPortrait;
            if (message.extFields && message.extFields.length) {
                object.extFields = [];
                for (let j = 0; j < message.extFields.length; ++j)
                    object.extFields[j] = $root.immessage.KvItem.toObject(message.extFields[j], options);
            }
            if (message.updatedTime != null && message.hasOwnProperty("updatedTime"))
                if (typeof message.updatedTime === "number")
                    object.updatedTime = options.longs === String ? String(message.updatedTime) : message.updatedTime;
                else
                    object.updatedTime = options.longs === String ? $util.Long.prototype.toString.call(message.updatedTime) : options.longs === Number ? new $util.LongBits(message.updatedTime.low >>> 0, message.updatedTime.high >>> 0).toNumber() : message.updatedTime;
            if (message.settings && message.settings.length) {
                object.settings = [];
                for (let j = 0; j < message.settings.length; ++j)
                    object.settings[j] = $root.immessage.KvItem.toObject(message.settings[j], options);
            }
            if (message.statuses && message.statuses.length) {
                object.statuses = [];
                for (let j = 0; j < message.statuses.length; ++j)
                    object.statuses[j] = $root.immessage.KvItem.toObject(message.statuses[j], options);
            }
            if (message.userType != null && message.hasOwnProperty("userType"))
                object.userType = options.enums === String ? $root.immessage.UserType[message.userType] === undefined ? message.userType : $root.immessage.UserType[message.userType] : message.userType;
            if (message.noCover != null && message.hasOwnProperty("noCover"))
                object.noCover = message.noCover;
            if (message.permitConvers && message.permitConvers.length) {
                object.permitConvers = [];
                for (let j = 0; j < message.permitConvers.length; ++j)
                    object.permitConvers[j] = $root.immessage.PermitConver.toObject(message.permitConvers[j], options);
            }
            return object;
        };

        /**
         * Converts this UserInfo to JSON.
         * @function toJSON
         * @memberof immessage.UserInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserInfo
         * @function getTypeUrl
         * @memberof immessage.UserInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UserInfo";
        };

        return UserInfo;
    })();

    immessage.PermitConver = (function() {

        /**
         * Properties of a PermitConver.
         * @memberof immessage
         * @interface IPermitConver
         * @property {string|null} [targetId] PermitConver targetId
         * @property {immessage.ChannelType|null} [channelType] PermitConver channelType
         * @property {number|null} [maxHisMsgCount] PermitConver maxHisMsgCount
         * @property {string|null} [targetIdAlias] PermitConver targetIdAlias
         * @property {Array.<string>|null} [permitMsgTypes] PermitConver permitMsgTypes
         */

        /**
         * Constructs a new PermitConver.
         * @memberof immessage
         * @classdesc Represents a PermitConver.
         * @implements IPermitConver
         * @constructor
         * @param {immessage.IPermitConver=} [properties] Properties to set
         */
        function PermitConver(properties) {
            this.permitMsgTypes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PermitConver targetId.
         * @member {string} targetId
         * @memberof immessage.PermitConver
         * @instance
         */
        PermitConver.prototype.targetId = "";

        /**
         * PermitConver channelType.
         * @member {immessage.ChannelType} channelType
         * @memberof immessage.PermitConver
         * @instance
         */
        PermitConver.prototype.channelType = 0;

        /**
         * PermitConver maxHisMsgCount.
         * @member {number} maxHisMsgCount
         * @memberof immessage.PermitConver
         * @instance
         */
        PermitConver.prototype.maxHisMsgCount = 0;

        /**
         * PermitConver targetIdAlias.
         * @member {string} targetIdAlias
         * @memberof immessage.PermitConver
         * @instance
         */
        PermitConver.prototype.targetIdAlias = "";

        /**
         * PermitConver permitMsgTypes.
         * @member {Array.<string>} permitMsgTypes
         * @memberof immessage.PermitConver
         * @instance
         */
        PermitConver.prototype.permitMsgTypes = $util.emptyArray;

        /**
         * Creates a new PermitConver instance using the specified properties.
         * @function create
         * @memberof immessage.PermitConver
         * @static
         * @param {immessage.IPermitConver=} [properties] Properties to set
         * @returns {immessage.PermitConver} PermitConver instance
         */
        PermitConver.create = function create(properties) {
            return new PermitConver(properties);
        };

        /**
         * Encodes the specified PermitConver message. Does not implicitly {@link immessage.PermitConver.verify|verify} messages.
         * @function encode
         * @memberof immessage.PermitConver
         * @static
         * @param {immessage.IPermitConver} message PermitConver message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PermitConver.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetId);
            if (message.channelType != null && Object.hasOwnProperty.call(message, "channelType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelType);
            if (message.maxHisMsgCount != null && Object.hasOwnProperty.call(message, "maxHisMsgCount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.maxHisMsgCount);
            if (message.targetIdAlias != null && Object.hasOwnProperty.call(message, "targetIdAlias"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.targetIdAlias);
            if (message.permitMsgTypes != null && message.permitMsgTypes.length)
                for (let i = 0; i < message.permitMsgTypes.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.permitMsgTypes[i]);
            return writer;
        };

        /**
         * Encodes the specified PermitConver message, length delimited. Does not implicitly {@link immessage.PermitConver.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.PermitConver
         * @static
         * @param {immessage.IPermitConver} message PermitConver message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PermitConver.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PermitConver message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.PermitConver
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.PermitConver} PermitConver
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PermitConver.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.PermitConver();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.targetId = reader.string();
                        break;
                    }
                case 2: {
                        message.channelType = reader.int32();
                        break;
                    }
                case 3: {
                        message.maxHisMsgCount = reader.int32();
                        break;
                    }
                case 4: {
                        message.targetIdAlias = reader.string();
                        break;
                    }
                case 5: {
                        if (!(message.permitMsgTypes && message.permitMsgTypes.length))
                            message.permitMsgTypes = [];
                        message.permitMsgTypes.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PermitConver message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.PermitConver
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.PermitConver} PermitConver
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PermitConver.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PermitConver message.
         * @function verify
         * @memberof immessage.PermitConver
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PermitConver.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!$util.isString(message.targetId))
                    return "targetId: string expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.maxHisMsgCount != null && message.hasOwnProperty("maxHisMsgCount"))
                if (!$util.isInteger(message.maxHisMsgCount))
                    return "maxHisMsgCount: integer expected";
            if (message.targetIdAlias != null && message.hasOwnProperty("targetIdAlias"))
                if (!$util.isString(message.targetIdAlias))
                    return "targetIdAlias: string expected";
            if (message.permitMsgTypes != null && message.hasOwnProperty("permitMsgTypes")) {
                if (!Array.isArray(message.permitMsgTypes))
                    return "permitMsgTypes: array expected";
                for (let i = 0; i < message.permitMsgTypes.length; ++i)
                    if (!$util.isString(message.permitMsgTypes[i]))
                        return "permitMsgTypes: string[] expected";
            }
            return null;
        };

        /**
         * Creates a PermitConver message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.PermitConver
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.PermitConver} PermitConver
         */
        PermitConver.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.PermitConver)
                return object;
            let message = new $root.immessage.PermitConver();
            if (object.targetId != null)
                message.targetId = String(object.targetId);
            switch (object.channelType) {
            default:
                if (typeof object.channelType === "number") {
                    message.channelType = object.channelType;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.channelType = 0;
                break;
            case "Private":
            case 1:
                message.channelType = 1;
                break;
            case "Group":
            case 2:
                message.channelType = 2;
                break;
            case "Chatroom":
            case 3:
                message.channelType = 3;
                break;
            case "System":
            case 4:
                message.channelType = 4;
                break;
            case "GroupCast":
            case 5:
                message.channelType = 5;
                break;
            case "BroadCast":
            case 6:
                message.channelType = 6;
                break;
            }
            if (object.maxHisMsgCount != null)
                message.maxHisMsgCount = object.maxHisMsgCount | 0;
            if (object.targetIdAlias != null)
                message.targetIdAlias = String(object.targetIdAlias);
            if (object.permitMsgTypes) {
                if (!Array.isArray(object.permitMsgTypes))
                    throw TypeError(".immessage.PermitConver.permitMsgTypes: array expected");
                message.permitMsgTypes = [];
                for (let i = 0; i < object.permitMsgTypes.length; ++i)
                    message.permitMsgTypes[i] = String(object.permitMsgTypes[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a PermitConver message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.PermitConver
         * @static
         * @param {immessage.PermitConver} message PermitConver
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PermitConver.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.permitMsgTypes = [];
            if (options.defaults) {
                object.targetId = "";
                object.channelType = options.enums === String ? "Unknown" : 0;
                object.maxHisMsgCount = 0;
                object.targetIdAlias = "";
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = message.targetId;
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.immessage.ChannelType[message.channelType] === undefined ? message.channelType : $root.immessage.ChannelType[message.channelType] : message.channelType;
            if (message.maxHisMsgCount != null && message.hasOwnProperty("maxHisMsgCount"))
                object.maxHisMsgCount = message.maxHisMsgCount;
            if (message.targetIdAlias != null && message.hasOwnProperty("targetIdAlias"))
                object.targetIdAlias = message.targetIdAlias;
            if (message.permitMsgTypes && message.permitMsgTypes.length) {
                object.permitMsgTypes = [];
                for (let j = 0; j < message.permitMsgTypes.length; ++j)
                    object.permitMsgTypes[j] = message.permitMsgTypes[j];
            }
            return object;
        };

        /**
         * Converts this PermitConver to JSON.
         * @function toJSON
         * @memberof immessage.PermitConver
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PermitConver.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PermitConver
         * @function getTypeUrl
         * @memberof immessage.PermitConver
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PermitConver.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.PermitConver";
        };

        return PermitConver;
    })();

    /**
     * UserType enum.
     * @name immessage.UserType
     * @enum {number}
     * @property {number} User=0 User value
     * @property {number} Bot=1 Bot value
     */
    immessage.UserType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "User"] = 0;
        values[valuesById[1] = "Bot"] = 1;
        return values;
    })();

    immessage.UserInfos = (function() {

        /**
         * Properties of a UserInfos.
         * @memberof immessage
         * @interface IUserInfos
         * @property {Array.<immessage.IUserInfo>|null} [userInfos] UserInfos userInfos
         */

        /**
         * Constructs a new UserInfos.
         * @memberof immessage
         * @classdesc Represents a UserInfos.
         * @implements IUserInfos
         * @constructor
         * @param {immessage.IUserInfos=} [properties] Properties to set
         */
        function UserInfos(properties) {
            this.userInfos = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserInfos userInfos.
         * @member {Array.<immessage.IUserInfo>} userInfos
         * @memberof immessage.UserInfos
         * @instance
         */
        UserInfos.prototype.userInfos = $util.emptyArray;

        /**
         * Creates a new UserInfos instance using the specified properties.
         * @function create
         * @memberof immessage.UserInfos
         * @static
         * @param {immessage.IUserInfos=} [properties] Properties to set
         * @returns {immessage.UserInfos} UserInfos instance
         */
        UserInfos.create = function create(properties) {
            return new UserInfos(properties);
        };

        /**
         * Encodes the specified UserInfos message. Does not implicitly {@link immessage.UserInfos.verify|verify} messages.
         * @function encode
         * @memberof immessage.UserInfos
         * @static
         * @param {immessage.IUserInfos} message UserInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserInfos.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userInfos != null && message.userInfos.length)
                for (let i = 0; i < message.userInfos.length; ++i)
                    $root.immessage.UserInfo.encode(message.userInfos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UserInfos message, length delimited. Does not implicitly {@link immessage.UserInfos.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UserInfos
         * @static
         * @param {immessage.IUserInfos} message UserInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserInfos.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserInfos message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UserInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UserInfos} UserInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInfos.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UserInfos();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.userInfos && message.userInfos.length))
                            message.userInfos = [];
                        message.userInfos.push($root.immessage.UserInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserInfos message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UserInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UserInfos} UserInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInfos.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserInfos message.
         * @function verify
         * @memberof immessage.UserInfos
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserInfos.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userInfos != null && message.hasOwnProperty("userInfos")) {
                if (!Array.isArray(message.userInfos))
                    return "userInfos: array expected";
                for (let i = 0; i < message.userInfos.length; ++i) {
                    let error = $root.immessage.UserInfo.verify(message.userInfos[i]);
                    if (error)
                        return "userInfos." + error;
                }
            }
            return null;
        };

        /**
         * Creates a UserInfos message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UserInfos
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UserInfos} UserInfos
         */
        UserInfos.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UserInfos)
                return object;
            let message = new $root.immessage.UserInfos();
            if (object.userInfos) {
                if (!Array.isArray(object.userInfos))
                    throw TypeError(".immessage.UserInfos.userInfos: array expected");
                message.userInfos = [];
                for (let i = 0; i < object.userInfos.length; ++i) {
                    if (typeof object.userInfos[i] !== "object")
                        throw TypeError(".immessage.UserInfos.userInfos: object expected");
                    message.userInfos[i] = $root.immessage.UserInfo.fromObject(object.userInfos[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a UserInfos message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UserInfos
         * @static
         * @param {immessage.UserInfos} message UserInfos
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserInfos.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.userInfos = [];
            if (message.userInfos && message.userInfos.length) {
                object.userInfos = [];
                for (let j = 0; j < message.userInfos.length; ++j)
                    object.userInfos[j] = $root.immessage.UserInfo.toObject(message.userInfos[j], options);
            }
            return object;
        };

        /**
         * Converts this UserInfos to JSON.
         * @function toJSON
         * @memberof immessage.UserInfos
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserInfos.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserInfos
         * @function getTypeUrl
         * @memberof immessage.UserInfos
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserInfos.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UserInfos";
        };

        return UserInfos;
    })();

    immessage.UserIdsReq = (function() {

        /**
         * Properties of a UserIdsReq.
         * @memberof immessage
         * @interface IUserIdsReq
         * @property {Array.<string>|null} [userIds] UserIdsReq userIds
         * @property {Array.<number>|null} [attTypes] UserIdsReq attTypes
         */

        /**
         * Constructs a new UserIdsReq.
         * @memberof immessage
         * @classdesc Represents a UserIdsReq.
         * @implements IUserIdsReq
         * @constructor
         * @param {immessage.IUserIdsReq=} [properties] Properties to set
         */
        function UserIdsReq(properties) {
            this.userIds = [];
            this.attTypes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserIdsReq userIds.
         * @member {Array.<string>} userIds
         * @memberof immessage.UserIdsReq
         * @instance
         */
        UserIdsReq.prototype.userIds = $util.emptyArray;

        /**
         * UserIdsReq attTypes.
         * @member {Array.<number>} attTypes
         * @memberof immessage.UserIdsReq
         * @instance
         */
        UserIdsReq.prototype.attTypes = $util.emptyArray;

        /**
         * Creates a new UserIdsReq instance using the specified properties.
         * @function create
         * @memberof immessage.UserIdsReq
         * @static
         * @param {immessage.IUserIdsReq=} [properties] Properties to set
         * @returns {immessage.UserIdsReq} UserIdsReq instance
         */
        UserIdsReq.create = function create(properties) {
            return new UserIdsReq(properties);
        };

        /**
         * Encodes the specified UserIdsReq message. Does not implicitly {@link immessage.UserIdsReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.UserIdsReq
         * @static
         * @param {immessage.IUserIdsReq} message UserIdsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserIdsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userIds != null && message.userIds.length)
                for (let i = 0; i < message.userIds.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.userIds[i]);
            if (message.attTypes != null && message.attTypes.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (let i = 0; i < message.attTypes.length; ++i)
                    writer.int32(message.attTypes[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified UserIdsReq message, length delimited. Does not implicitly {@link immessage.UserIdsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UserIdsReq
         * @static
         * @param {immessage.IUserIdsReq} message UserIdsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserIdsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserIdsReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UserIdsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UserIdsReq} UserIdsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserIdsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UserIdsReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.userIds && message.userIds.length))
                            message.userIds = [];
                        message.userIds.push(reader.string());
                        break;
                    }
                case 2: {
                        if (!(message.attTypes && message.attTypes.length))
                            message.attTypes = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.attTypes.push(reader.int32());
                        } else
                            message.attTypes.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserIdsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UserIdsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UserIdsReq} UserIdsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserIdsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserIdsReq message.
         * @function verify
         * @memberof immessage.UserIdsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserIdsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userIds != null && message.hasOwnProperty("userIds")) {
                if (!Array.isArray(message.userIds))
                    return "userIds: array expected";
                for (let i = 0; i < message.userIds.length; ++i)
                    if (!$util.isString(message.userIds[i]))
                        return "userIds: string[] expected";
            }
            if (message.attTypes != null && message.hasOwnProperty("attTypes")) {
                if (!Array.isArray(message.attTypes))
                    return "attTypes: array expected";
                for (let i = 0; i < message.attTypes.length; ++i)
                    if (!$util.isInteger(message.attTypes[i]))
                        return "attTypes: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a UserIdsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UserIdsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UserIdsReq} UserIdsReq
         */
        UserIdsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UserIdsReq)
                return object;
            let message = new $root.immessage.UserIdsReq();
            if (object.userIds) {
                if (!Array.isArray(object.userIds))
                    throw TypeError(".immessage.UserIdsReq.userIds: array expected");
                message.userIds = [];
                for (let i = 0; i < object.userIds.length; ++i)
                    message.userIds[i] = String(object.userIds[i]);
            }
            if (object.attTypes) {
                if (!Array.isArray(object.attTypes))
                    throw TypeError(".immessage.UserIdsReq.attTypes: array expected");
                message.attTypes = [];
                for (let i = 0; i < object.attTypes.length; ++i)
                    message.attTypes[i] = object.attTypes[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a UserIdsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UserIdsReq
         * @static
         * @param {immessage.UserIdsReq} message UserIdsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserIdsReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.userIds = [];
                object.attTypes = [];
            }
            if (message.userIds && message.userIds.length) {
                object.userIds = [];
                for (let j = 0; j < message.userIds.length; ++j)
                    object.userIds[j] = message.userIds[j];
            }
            if (message.attTypes && message.attTypes.length) {
                object.attTypes = [];
                for (let j = 0; j < message.attTypes.length; ++j)
                    object.attTypes[j] = message.attTypes[j];
            }
            return object;
        };

        /**
         * Converts this UserIdsReq to JSON.
         * @function toJSON
         * @memberof immessage.UserIdsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserIdsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserIdsReq
         * @function getTypeUrl
         * @memberof immessage.UserIdsReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserIdsReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UserIdsReq";
        };

        return UserIdsReq;
    })();

    immessage.UserIdReq = (function() {

        /**
         * Properties of a UserIdReq.
         * @memberof immessage
         * @interface IUserIdReq
         * @property {string|null} [userId] UserIdReq userId
         * @property {Array.<number>|null} [attTypes] UserIdReq attTypes
         */

        /**
         * Constructs a new UserIdReq.
         * @memberof immessage
         * @classdesc Represents a UserIdReq.
         * @implements IUserIdReq
         * @constructor
         * @param {immessage.IUserIdReq=} [properties] Properties to set
         */
        function UserIdReq(properties) {
            this.attTypes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserIdReq userId.
         * @member {string} userId
         * @memberof immessage.UserIdReq
         * @instance
         */
        UserIdReq.prototype.userId = "";

        /**
         * UserIdReq attTypes.
         * @member {Array.<number>} attTypes
         * @memberof immessage.UserIdReq
         * @instance
         */
        UserIdReq.prototype.attTypes = $util.emptyArray;

        /**
         * Creates a new UserIdReq instance using the specified properties.
         * @function create
         * @memberof immessage.UserIdReq
         * @static
         * @param {immessage.IUserIdReq=} [properties] Properties to set
         * @returns {immessage.UserIdReq} UserIdReq instance
         */
        UserIdReq.create = function create(properties) {
            return new UserIdReq(properties);
        };

        /**
         * Encodes the specified UserIdReq message. Does not implicitly {@link immessage.UserIdReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.UserIdReq
         * @static
         * @param {immessage.IUserIdReq} message UserIdReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserIdReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.attTypes != null && message.attTypes.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (let i = 0; i < message.attTypes.length; ++i)
                    writer.int32(message.attTypes[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified UserIdReq message, length delimited. Does not implicitly {@link immessage.UserIdReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UserIdReq
         * @static
         * @param {immessage.IUserIdReq} message UserIdReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserIdReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserIdReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UserIdReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UserIdReq} UserIdReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserIdReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UserIdReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.attTypes && message.attTypes.length))
                            message.attTypes = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.attTypes.push(reader.int32());
                        } else
                            message.attTypes.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserIdReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UserIdReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UserIdReq} UserIdReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserIdReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserIdReq message.
         * @function verify
         * @memberof immessage.UserIdReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserIdReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.attTypes != null && message.hasOwnProperty("attTypes")) {
                if (!Array.isArray(message.attTypes))
                    return "attTypes: array expected";
                for (let i = 0; i < message.attTypes.length; ++i)
                    if (!$util.isInteger(message.attTypes[i]))
                        return "attTypes: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a UserIdReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UserIdReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UserIdReq} UserIdReq
         */
        UserIdReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UserIdReq)
                return object;
            let message = new $root.immessage.UserIdReq();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.attTypes) {
                if (!Array.isArray(object.attTypes))
                    throw TypeError(".immessage.UserIdReq.attTypes: array expected");
                message.attTypes = [];
                for (let i = 0; i < object.attTypes.length; ++i)
                    message.attTypes[i] = object.attTypes[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a UserIdReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UserIdReq
         * @static
         * @param {immessage.UserIdReq} message UserIdReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserIdReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.attTypes = [];
            if (options.defaults)
                object.userId = "";
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.attTypes && message.attTypes.length) {
                object.attTypes = [];
                for (let j = 0; j < message.attTypes.length; ++j)
                    object.attTypes[j] = message.attTypes[j];
            }
            return object;
        };

        /**
         * Converts this UserIdReq to JSON.
         * @function toJSON
         * @memberof immessage.UserIdReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserIdReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserIdReq
         * @function getTypeUrl
         * @memberof immessage.UserIdReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserIdReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UserIdReq";
        };

        return UserIdReq;
    })();

    immessage.UserInfosResp = (function() {

        /**
         * Properties of a UserInfosResp.
         * @memberof immessage
         * @interface IUserInfosResp
         * @property {Object.<string,immessage.IUserInfo>|null} [userInfoMap] UserInfosResp userInfoMap
         */

        /**
         * Constructs a new UserInfosResp.
         * @memberof immessage
         * @classdesc Represents a UserInfosResp.
         * @implements IUserInfosResp
         * @constructor
         * @param {immessage.IUserInfosResp=} [properties] Properties to set
         */
        function UserInfosResp(properties) {
            this.userInfoMap = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserInfosResp userInfoMap.
         * @member {Object.<string,immessage.IUserInfo>} userInfoMap
         * @memberof immessage.UserInfosResp
         * @instance
         */
        UserInfosResp.prototype.userInfoMap = $util.emptyObject;

        /**
         * Creates a new UserInfosResp instance using the specified properties.
         * @function create
         * @memberof immessage.UserInfosResp
         * @static
         * @param {immessage.IUserInfosResp=} [properties] Properties to set
         * @returns {immessage.UserInfosResp} UserInfosResp instance
         */
        UserInfosResp.create = function create(properties) {
            return new UserInfosResp(properties);
        };

        /**
         * Encodes the specified UserInfosResp message. Does not implicitly {@link immessage.UserInfosResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.UserInfosResp
         * @static
         * @param {immessage.IUserInfosResp} message UserInfosResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserInfosResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userInfoMap != null && Object.hasOwnProperty.call(message, "userInfoMap"))
                for (let keys = Object.keys(message.userInfoMap), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.immessage.UserInfo.encode(message.userInfoMap[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified UserInfosResp message, length delimited. Does not implicitly {@link immessage.UserInfosResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UserInfosResp
         * @static
         * @param {immessage.IUserInfosResp} message UserInfosResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserInfosResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserInfosResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UserInfosResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UserInfosResp} UserInfosResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInfosResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UserInfosResp(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (message.userInfoMap === $util.emptyObject)
                            message.userInfoMap = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.immessage.UserInfo.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.userInfoMap[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserInfosResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UserInfosResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UserInfosResp} UserInfosResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInfosResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserInfosResp message.
         * @function verify
         * @memberof immessage.UserInfosResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserInfosResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userInfoMap != null && message.hasOwnProperty("userInfoMap")) {
                if (!$util.isObject(message.userInfoMap))
                    return "userInfoMap: object expected";
                let key = Object.keys(message.userInfoMap);
                for (let i = 0; i < key.length; ++i) {
                    let error = $root.immessage.UserInfo.verify(message.userInfoMap[key[i]]);
                    if (error)
                        return "userInfoMap." + error;
                }
            }
            return null;
        };

        /**
         * Creates a UserInfosResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UserInfosResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UserInfosResp} UserInfosResp
         */
        UserInfosResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UserInfosResp)
                return object;
            let message = new $root.immessage.UserInfosResp();
            if (object.userInfoMap) {
                if (typeof object.userInfoMap !== "object")
                    throw TypeError(".immessage.UserInfosResp.userInfoMap: object expected");
                message.userInfoMap = {};
                for (let keys = Object.keys(object.userInfoMap), i = 0; i < keys.length; ++i) {
                    if (typeof object.userInfoMap[keys[i]] !== "object")
                        throw TypeError(".immessage.UserInfosResp.userInfoMap: object expected");
                    message.userInfoMap[keys[i]] = $root.immessage.UserInfo.fromObject(object.userInfoMap[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a UserInfosResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UserInfosResp
         * @static
         * @param {immessage.UserInfosResp} message UserInfosResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserInfosResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.userInfoMap = {};
            let keys2;
            if (message.userInfoMap && (keys2 = Object.keys(message.userInfoMap)).length) {
                object.userInfoMap = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.userInfoMap[keys2[j]] = $root.immessage.UserInfo.toObject(message.userInfoMap[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this UserInfosResp to JSON.
         * @function toJSON
         * @memberof immessage.UserInfosResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserInfosResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserInfosResp
         * @function getTypeUrl
         * @memberof immessage.UserInfosResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserInfosResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UserInfosResp";
        };

        return UserInfosResp;
    })();

    immessage.UserRegResp = (function() {

        /**
         * Properties of a UserRegResp.
         * @memberof immessage
         * @interface IUserRegResp
         * @property {string|null} [userId] UserRegResp userId
         * @property {string|null} [token] UserRegResp token
         * @property {string|null} [nickname] UserRegResp nickname
         * @property {string|null} [userPortrait] UserRegResp userPortrait
         * @property {Array.<immessage.IKvItem>|null} [extFields] UserRegResp extFields
         * @property {number|Long|null} [updatedTime] UserRegResp updatedTime
         */

        /**
         * Constructs a new UserRegResp.
         * @memberof immessage
         * @classdesc Represents a UserRegResp.
         * @implements IUserRegResp
         * @constructor
         * @param {immessage.IUserRegResp=} [properties] Properties to set
         */
        function UserRegResp(properties) {
            this.extFields = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserRegResp userId.
         * @member {string} userId
         * @memberof immessage.UserRegResp
         * @instance
         */
        UserRegResp.prototype.userId = "";

        /**
         * UserRegResp token.
         * @member {string} token
         * @memberof immessage.UserRegResp
         * @instance
         */
        UserRegResp.prototype.token = "";

        /**
         * UserRegResp nickname.
         * @member {string} nickname
         * @memberof immessage.UserRegResp
         * @instance
         */
        UserRegResp.prototype.nickname = "";

        /**
         * UserRegResp userPortrait.
         * @member {string} userPortrait
         * @memberof immessage.UserRegResp
         * @instance
         */
        UserRegResp.prototype.userPortrait = "";

        /**
         * UserRegResp extFields.
         * @member {Array.<immessage.IKvItem>} extFields
         * @memberof immessage.UserRegResp
         * @instance
         */
        UserRegResp.prototype.extFields = $util.emptyArray;

        /**
         * UserRegResp updatedTime.
         * @member {number|Long} updatedTime
         * @memberof immessage.UserRegResp
         * @instance
         */
        UserRegResp.prototype.updatedTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UserRegResp instance using the specified properties.
         * @function create
         * @memberof immessage.UserRegResp
         * @static
         * @param {immessage.IUserRegResp=} [properties] Properties to set
         * @returns {immessage.UserRegResp} UserRegResp instance
         */
        UserRegResp.create = function create(properties) {
            return new UserRegResp(properties);
        };

        /**
         * Encodes the specified UserRegResp message. Does not implicitly {@link immessage.UserRegResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.UserRegResp
         * @static
         * @param {immessage.IUserRegResp} message UserRegResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserRegResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
            if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.nickname);
            if (message.userPortrait != null && Object.hasOwnProperty.call(message, "userPortrait"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.userPortrait);
            if (message.extFields != null && message.extFields.length)
                for (let i = 0; i < message.extFields.length; ++i)
                    $root.immessage.KvItem.encode(message.extFields[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.updatedTime != null && Object.hasOwnProperty.call(message, "updatedTime"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.updatedTime);
            return writer;
        };

        /**
         * Encodes the specified UserRegResp message, length delimited. Does not implicitly {@link immessage.UserRegResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UserRegResp
         * @static
         * @param {immessage.IUserRegResp} message UserRegResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserRegResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserRegResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UserRegResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UserRegResp} UserRegResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserRegResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UserRegResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.token = reader.string();
                        break;
                    }
                case 3: {
                        message.nickname = reader.string();
                        break;
                    }
                case 4: {
                        message.userPortrait = reader.string();
                        break;
                    }
                case 5: {
                        if (!(message.extFields && message.extFields.length))
                            message.extFields = [];
                        message.extFields.push($root.immessage.KvItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        message.updatedTime = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserRegResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UserRegResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UserRegResp} UserRegResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserRegResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserRegResp message.
         * @function verify
         * @memberof immessage.UserRegResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserRegResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!$util.isString(message.token))
                    return "token: string expected";
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                if (!$util.isString(message.nickname))
                    return "nickname: string expected";
            if (message.userPortrait != null && message.hasOwnProperty("userPortrait"))
                if (!$util.isString(message.userPortrait))
                    return "userPortrait: string expected";
            if (message.extFields != null && message.hasOwnProperty("extFields")) {
                if (!Array.isArray(message.extFields))
                    return "extFields: array expected";
                for (let i = 0; i < message.extFields.length; ++i) {
                    let error = $root.immessage.KvItem.verify(message.extFields[i]);
                    if (error)
                        return "extFields." + error;
                }
            }
            if (message.updatedTime != null && message.hasOwnProperty("updatedTime"))
                if (!$util.isInteger(message.updatedTime) && !(message.updatedTime && $util.isInteger(message.updatedTime.low) && $util.isInteger(message.updatedTime.high)))
                    return "updatedTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a UserRegResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UserRegResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UserRegResp} UserRegResp
         */
        UserRegResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UserRegResp)
                return object;
            let message = new $root.immessage.UserRegResp();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.token != null)
                message.token = String(object.token);
            if (object.nickname != null)
                message.nickname = String(object.nickname);
            if (object.userPortrait != null)
                message.userPortrait = String(object.userPortrait);
            if (object.extFields) {
                if (!Array.isArray(object.extFields))
                    throw TypeError(".immessage.UserRegResp.extFields: array expected");
                message.extFields = [];
                for (let i = 0; i < object.extFields.length; ++i) {
                    if (typeof object.extFields[i] !== "object")
                        throw TypeError(".immessage.UserRegResp.extFields: object expected");
                    message.extFields[i] = $root.immessage.KvItem.fromObject(object.extFields[i]);
                }
            }
            if (object.updatedTime != null)
                if ($util.Long)
                    (message.updatedTime = $util.Long.fromValue(object.updatedTime)).unsigned = false;
                else if (typeof object.updatedTime === "string")
                    message.updatedTime = parseInt(object.updatedTime, 10);
                else if (typeof object.updatedTime === "number")
                    message.updatedTime = object.updatedTime;
                else if (typeof object.updatedTime === "object")
                    message.updatedTime = new $util.LongBits(object.updatedTime.low >>> 0, object.updatedTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a UserRegResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UserRegResp
         * @static
         * @param {immessage.UserRegResp} message UserRegResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserRegResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.extFields = [];
            if (options.defaults) {
                object.userId = "";
                object.token = "";
                object.nickname = "";
                object.userPortrait = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.updatedTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.updatedTime = options.longs === String ? "0" : 0;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = message.token;
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                object.nickname = message.nickname;
            if (message.userPortrait != null && message.hasOwnProperty("userPortrait"))
                object.userPortrait = message.userPortrait;
            if (message.extFields && message.extFields.length) {
                object.extFields = [];
                for (let j = 0; j < message.extFields.length; ++j)
                    object.extFields[j] = $root.immessage.KvItem.toObject(message.extFields[j], options);
            }
            if (message.updatedTime != null && message.hasOwnProperty("updatedTime"))
                if (typeof message.updatedTime === "number")
                    object.updatedTime = options.longs === String ? String(message.updatedTime) : message.updatedTime;
                else
                    object.updatedTime = options.longs === String ? $util.Long.prototype.toString.call(message.updatedTime) : options.longs === Number ? new $util.LongBits(message.updatedTime.low >>> 0, message.updatedTime.high >>> 0).toNumber() : message.updatedTime;
            return object;
        };

        /**
         * Converts this UserRegResp to JSON.
         * @function toJSON
         * @memberof immessage.UserRegResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserRegResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserRegResp
         * @function getTypeUrl
         * @memberof immessage.UserRegResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserRegResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UserRegResp";
        };

        return UserRegResp;
    })();

    immessage.UserOnlineStatusReq = (function() {

        /**
         * Properties of a UserOnlineStatusReq.
         * @memberof immessage
         * @interface IUserOnlineStatusReq
         * @property {Array.<string>|null} [userIds] UserOnlineStatusReq userIds
         */

        /**
         * Constructs a new UserOnlineStatusReq.
         * @memberof immessage
         * @classdesc Represents a UserOnlineStatusReq.
         * @implements IUserOnlineStatusReq
         * @constructor
         * @param {immessage.IUserOnlineStatusReq=} [properties] Properties to set
         */
        function UserOnlineStatusReq(properties) {
            this.userIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserOnlineStatusReq userIds.
         * @member {Array.<string>} userIds
         * @memberof immessage.UserOnlineStatusReq
         * @instance
         */
        UserOnlineStatusReq.prototype.userIds = $util.emptyArray;

        /**
         * Creates a new UserOnlineStatusReq instance using the specified properties.
         * @function create
         * @memberof immessage.UserOnlineStatusReq
         * @static
         * @param {immessage.IUserOnlineStatusReq=} [properties] Properties to set
         * @returns {immessage.UserOnlineStatusReq} UserOnlineStatusReq instance
         */
        UserOnlineStatusReq.create = function create(properties) {
            return new UserOnlineStatusReq(properties);
        };

        /**
         * Encodes the specified UserOnlineStatusReq message. Does not implicitly {@link immessage.UserOnlineStatusReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.UserOnlineStatusReq
         * @static
         * @param {immessage.IUserOnlineStatusReq} message UserOnlineStatusReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserOnlineStatusReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userIds != null && message.userIds.length)
                for (let i = 0; i < message.userIds.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.userIds[i]);
            return writer;
        };

        /**
         * Encodes the specified UserOnlineStatusReq message, length delimited. Does not implicitly {@link immessage.UserOnlineStatusReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UserOnlineStatusReq
         * @static
         * @param {immessage.IUserOnlineStatusReq} message UserOnlineStatusReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserOnlineStatusReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserOnlineStatusReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UserOnlineStatusReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UserOnlineStatusReq} UserOnlineStatusReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserOnlineStatusReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UserOnlineStatusReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.userIds && message.userIds.length))
                            message.userIds = [];
                        message.userIds.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserOnlineStatusReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UserOnlineStatusReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UserOnlineStatusReq} UserOnlineStatusReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserOnlineStatusReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserOnlineStatusReq message.
         * @function verify
         * @memberof immessage.UserOnlineStatusReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserOnlineStatusReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userIds != null && message.hasOwnProperty("userIds")) {
                if (!Array.isArray(message.userIds))
                    return "userIds: array expected";
                for (let i = 0; i < message.userIds.length; ++i)
                    if (!$util.isString(message.userIds[i]))
                        return "userIds: string[] expected";
            }
            return null;
        };

        /**
         * Creates a UserOnlineStatusReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UserOnlineStatusReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UserOnlineStatusReq} UserOnlineStatusReq
         */
        UserOnlineStatusReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UserOnlineStatusReq)
                return object;
            let message = new $root.immessage.UserOnlineStatusReq();
            if (object.userIds) {
                if (!Array.isArray(object.userIds))
                    throw TypeError(".immessage.UserOnlineStatusReq.userIds: array expected");
                message.userIds = [];
                for (let i = 0; i < object.userIds.length; ++i)
                    message.userIds[i] = String(object.userIds[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a UserOnlineStatusReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UserOnlineStatusReq
         * @static
         * @param {immessage.UserOnlineStatusReq} message UserOnlineStatusReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserOnlineStatusReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.userIds = [];
            if (message.userIds && message.userIds.length) {
                object.userIds = [];
                for (let j = 0; j < message.userIds.length; ++j)
                    object.userIds[j] = message.userIds[j];
            }
            return object;
        };

        /**
         * Converts this UserOnlineStatusReq to JSON.
         * @function toJSON
         * @memberof immessage.UserOnlineStatusReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserOnlineStatusReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserOnlineStatusReq
         * @function getTypeUrl
         * @memberof immessage.UserOnlineStatusReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserOnlineStatusReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UserOnlineStatusReq";
        };

        return UserOnlineStatusReq;
    })();

    immessage.UserOnlineStatusResp = (function() {

        /**
         * Properties of a UserOnlineStatusResp.
         * @memberof immessage
         * @interface IUserOnlineStatusResp
         * @property {Array.<immessage.IUserOnlineItem>|null} [items] UserOnlineStatusResp items
         */

        /**
         * Constructs a new UserOnlineStatusResp.
         * @memberof immessage
         * @classdesc Represents a UserOnlineStatusResp.
         * @implements IUserOnlineStatusResp
         * @constructor
         * @param {immessage.IUserOnlineStatusResp=} [properties] Properties to set
         */
        function UserOnlineStatusResp(properties) {
            this.items = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserOnlineStatusResp items.
         * @member {Array.<immessage.IUserOnlineItem>} items
         * @memberof immessage.UserOnlineStatusResp
         * @instance
         */
        UserOnlineStatusResp.prototype.items = $util.emptyArray;

        /**
         * Creates a new UserOnlineStatusResp instance using the specified properties.
         * @function create
         * @memberof immessage.UserOnlineStatusResp
         * @static
         * @param {immessage.IUserOnlineStatusResp=} [properties] Properties to set
         * @returns {immessage.UserOnlineStatusResp} UserOnlineStatusResp instance
         */
        UserOnlineStatusResp.create = function create(properties) {
            return new UserOnlineStatusResp(properties);
        };

        /**
         * Encodes the specified UserOnlineStatusResp message. Does not implicitly {@link immessage.UserOnlineStatusResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.UserOnlineStatusResp
         * @static
         * @param {immessage.IUserOnlineStatusResp} message UserOnlineStatusResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserOnlineStatusResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (let i = 0; i < message.items.length; ++i)
                    $root.immessage.UserOnlineItem.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UserOnlineStatusResp message, length delimited. Does not implicitly {@link immessage.UserOnlineStatusResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UserOnlineStatusResp
         * @static
         * @param {immessage.IUserOnlineStatusResp} message UserOnlineStatusResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserOnlineStatusResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserOnlineStatusResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UserOnlineStatusResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UserOnlineStatusResp} UserOnlineStatusResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserOnlineStatusResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UserOnlineStatusResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.immessage.UserOnlineItem.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserOnlineStatusResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UserOnlineStatusResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UserOnlineStatusResp} UserOnlineStatusResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserOnlineStatusResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserOnlineStatusResp message.
         * @function verify
         * @memberof immessage.UserOnlineStatusResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserOnlineStatusResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (let i = 0; i < message.items.length; ++i) {
                    let error = $root.immessage.UserOnlineItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a UserOnlineStatusResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UserOnlineStatusResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UserOnlineStatusResp} UserOnlineStatusResp
         */
        UserOnlineStatusResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UserOnlineStatusResp)
                return object;
            let message = new $root.immessage.UserOnlineStatusResp();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".immessage.UserOnlineStatusResp.items: array expected");
                message.items = [];
                for (let i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".immessage.UserOnlineStatusResp.items: object expected");
                    message.items[i] = $root.immessage.UserOnlineItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a UserOnlineStatusResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UserOnlineStatusResp
         * @static
         * @param {immessage.UserOnlineStatusResp} message UserOnlineStatusResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserOnlineStatusResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (message.items && message.items.length) {
                object.items = [];
                for (let j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.immessage.UserOnlineItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this UserOnlineStatusResp to JSON.
         * @function toJSON
         * @memberof immessage.UserOnlineStatusResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserOnlineStatusResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserOnlineStatusResp
         * @function getTypeUrl
         * @memberof immessage.UserOnlineStatusResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserOnlineStatusResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UserOnlineStatusResp";
        };

        return UserOnlineStatusResp;
    })();

    immessage.UserOnlineItem = (function() {

        /**
         * Properties of a UserOnlineItem.
         * @memberof immessage
         * @interface IUserOnlineItem
         * @property {string|null} [userId] UserOnlineItem userId
         * @property {boolean|null} [isOnline] UserOnlineItem isOnline
         */

        /**
         * Constructs a new UserOnlineItem.
         * @memberof immessage
         * @classdesc Represents a UserOnlineItem.
         * @implements IUserOnlineItem
         * @constructor
         * @param {immessage.IUserOnlineItem=} [properties] Properties to set
         */
        function UserOnlineItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserOnlineItem userId.
         * @member {string} userId
         * @memberof immessage.UserOnlineItem
         * @instance
         */
        UserOnlineItem.prototype.userId = "";

        /**
         * UserOnlineItem isOnline.
         * @member {boolean} isOnline
         * @memberof immessage.UserOnlineItem
         * @instance
         */
        UserOnlineItem.prototype.isOnline = false;

        /**
         * Creates a new UserOnlineItem instance using the specified properties.
         * @function create
         * @memberof immessage.UserOnlineItem
         * @static
         * @param {immessage.IUserOnlineItem=} [properties] Properties to set
         * @returns {immessage.UserOnlineItem} UserOnlineItem instance
         */
        UserOnlineItem.create = function create(properties) {
            return new UserOnlineItem(properties);
        };

        /**
         * Encodes the specified UserOnlineItem message. Does not implicitly {@link immessage.UserOnlineItem.verify|verify} messages.
         * @function encode
         * @memberof immessage.UserOnlineItem
         * @static
         * @param {immessage.IUserOnlineItem} message UserOnlineItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserOnlineItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.isOnline != null && Object.hasOwnProperty.call(message, "isOnline"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isOnline);
            return writer;
        };

        /**
         * Encodes the specified UserOnlineItem message, length delimited. Does not implicitly {@link immessage.UserOnlineItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UserOnlineItem
         * @static
         * @param {immessage.IUserOnlineItem} message UserOnlineItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserOnlineItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserOnlineItem message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UserOnlineItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UserOnlineItem} UserOnlineItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserOnlineItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UserOnlineItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.isOnline = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserOnlineItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UserOnlineItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UserOnlineItem} UserOnlineItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserOnlineItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserOnlineItem message.
         * @function verify
         * @memberof immessage.UserOnlineItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserOnlineItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.isOnline != null && message.hasOwnProperty("isOnline"))
                if (typeof message.isOnline !== "boolean")
                    return "isOnline: boolean expected";
            return null;
        };

        /**
         * Creates a UserOnlineItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UserOnlineItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UserOnlineItem} UserOnlineItem
         */
        UserOnlineItem.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UserOnlineItem)
                return object;
            let message = new $root.immessage.UserOnlineItem();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.isOnline != null)
                message.isOnline = Boolean(object.isOnline);
            return message;
        };

        /**
         * Creates a plain object from a UserOnlineItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UserOnlineItem
         * @static
         * @param {immessage.UserOnlineItem} message UserOnlineItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserOnlineItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                object.isOnline = false;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.isOnline != null && message.hasOwnProperty("isOnline"))
                object.isOnline = message.isOnline;
            return object;
        };

        /**
         * Converts this UserOnlineItem to JSON.
         * @function toJSON
         * @memberof immessage.UserOnlineItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserOnlineItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserOnlineItem
         * @function getTypeUrl
         * @memberof immessage.UserOnlineItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserOnlineItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UserOnlineItem";
        };

        return UserOnlineItem;
    })();

    immessage.BanUsersReq = (function() {

        /**
         * Properties of a BanUsersReq.
         * @memberof immessage
         * @interface IBanUsersReq
         * @property {Array.<immessage.IBanUser>|null} [banUsers] BanUsersReq banUsers
         * @property {boolean|null} [isAdd] BanUsersReq isAdd
         */

        /**
         * Constructs a new BanUsersReq.
         * @memberof immessage
         * @classdesc Represents a BanUsersReq.
         * @implements IBanUsersReq
         * @constructor
         * @param {immessage.IBanUsersReq=} [properties] Properties to set
         */
        function BanUsersReq(properties) {
            this.banUsers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BanUsersReq banUsers.
         * @member {Array.<immessage.IBanUser>} banUsers
         * @memberof immessage.BanUsersReq
         * @instance
         */
        BanUsersReq.prototype.banUsers = $util.emptyArray;

        /**
         * BanUsersReq isAdd.
         * @member {boolean} isAdd
         * @memberof immessage.BanUsersReq
         * @instance
         */
        BanUsersReq.prototype.isAdd = false;

        /**
         * Creates a new BanUsersReq instance using the specified properties.
         * @function create
         * @memberof immessage.BanUsersReq
         * @static
         * @param {immessage.IBanUsersReq=} [properties] Properties to set
         * @returns {immessage.BanUsersReq} BanUsersReq instance
         */
        BanUsersReq.create = function create(properties) {
            return new BanUsersReq(properties);
        };

        /**
         * Encodes the specified BanUsersReq message. Does not implicitly {@link immessage.BanUsersReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.BanUsersReq
         * @static
         * @param {immessage.IBanUsersReq} message BanUsersReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BanUsersReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.banUsers != null && message.banUsers.length)
                for (let i = 0; i < message.banUsers.length; ++i)
                    $root.immessage.BanUser.encode(message.banUsers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.isAdd != null && Object.hasOwnProperty.call(message, "isAdd"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isAdd);
            return writer;
        };

        /**
         * Encodes the specified BanUsersReq message, length delimited. Does not implicitly {@link immessage.BanUsersReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.BanUsersReq
         * @static
         * @param {immessage.IBanUsersReq} message BanUsersReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BanUsersReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BanUsersReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.BanUsersReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.BanUsersReq} BanUsersReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BanUsersReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.BanUsersReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.banUsers && message.banUsers.length))
                            message.banUsers = [];
                        message.banUsers.push($root.immessage.BanUser.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.isAdd = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BanUsersReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.BanUsersReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.BanUsersReq} BanUsersReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BanUsersReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BanUsersReq message.
         * @function verify
         * @memberof immessage.BanUsersReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BanUsersReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.banUsers != null && message.hasOwnProperty("banUsers")) {
                if (!Array.isArray(message.banUsers))
                    return "banUsers: array expected";
                for (let i = 0; i < message.banUsers.length; ++i) {
                    let error = $root.immessage.BanUser.verify(message.banUsers[i]);
                    if (error)
                        return "banUsers." + error;
                }
            }
            if (message.isAdd != null && message.hasOwnProperty("isAdd"))
                if (typeof message.isAdd !== "boolean")
                    return "isAdd: boolean expected";
            return null;
        };

        /**
         * Creates a BanUsersReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.BanUsersReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.BanUsersReq} BanUsersReq
         */
        BanUsersReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.BanUsersReq)
                return object;
            let message = new $root.immessage.BanUsersReq();
            if (object.banUsers) {
                if (!Array.isArray(object.banUsers))
                    throw TypeError(".immessage.BanUsersReq.banUsers: array expected");
                message.banUsers = [];
                for (let i = 0; i < object.banUsers.length; ++i) {
                    if (typeof object.banUsers[i] !== "object")
                        throw TypeError(".immessage.BanUsersReq.banUsers: object expected");
                    message.banUsers[i] = $root.immessage.BanUser.fromObject(object.banUsers[i]);
                }
            }
            if (object.isAdd != null)
                message.isAdd = Boolean(object.isAdd);
            return message;
        };

        /**
         * Creates a plain object from a BanUsersReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.BanUsersReq
         * @static
         * @param {immessage.BanUsersReq} message BanUsersReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BanUsersReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.banUsers = [];
            if (options.defaults)
                object.isAdd = false;
            if (message.banUsers && message.banUsers.length) {
                object.banUsers = [];
                for (let j = 0; j < message.banUsers.length; ++j)
                    object.banUsers[j] = $root.immessage.BanUser.toObject(message.banUsers[j], options);
            }
            if (message.isAdd != null && message.hasOwnProperty("isAdd"))
                object.isAdd = message.isAdd;
            return object;
        };

        /**
         * Converts this BanUsersReq to JSON.
         * @function toJSON
         * @memberof immessage.BanUsersReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BanUsersReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BanUsersReq
         * @function getTypeUrl
         * @memberof immessage.BanUsersReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BanUsersReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.BanUsersReq";
        };

        return BanUsersReq;
    })();

    immessage.BanUser = (function() {

        /**
         * Properties of a BanUser.
         * @memberof immessage
         * @interface IBanUser
         * @property {string|null} [userId] BanUser userId
         * @property {number|Long|null} [endTime] BanUser endTime
         * @property {number|Long|null} [createdTime] BanUser createdTime
         * @property {string|null} [scopeKey] BanUser scopeKey
         * @property {string|null} [scopeValue] BanUser scopeValue
         * @property {string|null} [ext] BanUser ext
         */

        /**
         * Constructs a new BanUser.
         * @memberof immessage
         * @classdesc Represents a BanUser.
         * @implements IBanUser
         * @constructor
         * @param {immessage.IBanUser=} [properties] Properties to set
         */
        function BanUser(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BanUser userId.
         * @member {string} userId
         * @memberof immessage.BanUser
         * @instance
         */
        BanUser.prototype.userId = "";

        /**
         * BanUser endTime.
         * @member {number|Long} endTime
         * @memberof immessage.BanUser
         * @instance
         */
        BanUser.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BanUser createdTime.
         * @member {number|Long} createdTime
         * @memberof immessage.BanUser
         * @instance
         */
        BanUser.prototype.createdTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BanUser scopeKey.
         * @member {string} scopeKey
         * @memberof immessage.BanUser
         * @instance
         */
        BanUser.prototype.scopeKey = "";

        /**
         * BanUser scopeValue.
         * @member {string} scopeValue
         * @memberof immessage.BanUser
         * @instance
         */
        BanUser.prototype.scopeValue = "";

        /**
         * BanUser ext.
         * @member {string} ext
         * @memberof immessage.BanUser
         * @instance
         */
        BanUser.prototype.ext = "";

        /**
         * Creates a new BanUser instance using the specified properties.
         * @function create
         * @memberof immessage.BanUser
         * @static
         * @param {immessage.IBanUser=} [properties] Properties to set
         * @returns {immessage.BanUser} BanUser instance
         */
        BanUser.create = function create(properties) {
            return new BanUser(properties);
        };

        /**
         * Encodes the specified BanUser message. Does not implicitly {@link immessage.BanUser.verify|verify} messages.
         * @function encode
         * @memberof immessage.BanUser
         * @static
         * @param {immessage.IBanUser} message BanUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BanUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.endTime);
            if (message.createdTime != null && Object.hasOwnProperty.call(message, "createdTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.createdTime);
            if (message.scopeKey != null && Object.hasOwnProperty.call(message, "scopeKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.scopeKey);
            if (message.scopeValue != null && Object.hasOwnProperty.call(message, "scopeValue"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.scopeValue);
            if (message.ext != null && Object.hasOwnProperty.call(message, "ext"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.ext);
            return writer;
        };

        /**
         * Encodes the specified BanUser message, length delimited. Does not implicitly {@link immessage.BanUser.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.BanUser
         * @static
         * @param {immessage.IBanUser} message BanUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BanUser.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BanUser message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.BanUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.BanUser} BanUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BanUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.BanUser();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.endTime = reader.int64();
                        break;
                    }
                case 3: {
                        message.createdTime = reader.int64();
                        break;
                    }
                case 4: {
                        message.scopeKey = reader.string();
                        break;
                    }
                case 5: {
                        message.scopeValue = reader.string();
                        break;
                    }
                case 6: {
                        message.ext = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BanUser message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.BanUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.BanUser} BanUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BanUser.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BanUser message.
         * @function verify
         * @memberof immessage.BanUser
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BanUser.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
                    return "endTime: integer|Long expected";
            if (message.createdTime != null && message.hasOwnProperty("createdTime"))
                if (!$util.isInteger(message.createdTime) && !(message.createdTime && $util.isInteger(message.createdTime.low) && $util.isInteger(message.createdTime.high)))
                    return "createdTime: integer|Long expected";
            if (message.scopeKey != null && message.hasOwnProperty("scopeKey"))
                if (!$util.isString(message.scopeKey))
                    return "scopeKey: string expected";
            if (message.scopeValue != null && message.hasOwnProperty("scopeValue"))
                if (!$util.isString(message.scopeValue))
                    return "scopeValue: string expected";
            if (message.ext != null && message.hasOwnProperty("ext"))
                if (!$util.isString(message.ext))
                    return "ext: string expected";
            return null;
        };

        /**
         * Creates a BanUser message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.BanUser
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.BanUser} BanUser
         */
        BanUser.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.BanUser)
                return object;
            let message = new $root.immessage.BanUser();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.endTime != null)
                if ($util.Long)
                    (message.endTime = $util.Long.fromValue(object.endTime)).unsigned = false;
                else if (typeof object.endTime === "string")
                    message.endTime = parseInt(object.endTime, 10);
                else if (typeof object.endTime === "number")
                    message.endTime = object.endTime;
                else if (typeof object.endTime === "object")
                    message.endTime = new $util.LongBits(object.endTime.low >>> 0, object.endTime.high >>> 0).toNumber();
            if (object.createdTime != null)
                if ($util.Long)
                    (message.createdTime = $util.Long.fromValue(object.createdTime)).unsigned = false;
                else if (typeof object.createdTime === "string")
                    message.createdTime = parseInt(object.createdTime, 10);
                else if (typeof object.createdTime === "number")
                    message.createdTime = object.createdTime;
                else if (typeof object.createdTime === "object")
                    message.createdTime = new $util.LongBits(object.createdTime.low >>> 0, object.createdTime.high >>> 0).toNumber();
            if (object.scopeKey != null)
                message.scopeKey = String(object.scopeKey);
            if (object.scopeValue != null)
                message.scopeValue = String(object.scopeValue);
            if (object.ext != null)
                message.ext = String(object.ext);
            return message;
        };

        /**
         * Creates a plain object from a BanUser message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.BanUser
         * @static
         * @param {immessage.BanUser} message BanUser
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BanUser.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.endTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.endTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.createdTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createdTime = options.longs === String ? "0" : 0;
                object.scopeKey = "";
                object.scopeValue = "";
                object.ext = "";
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (typeof message.endTime === "number")
                    object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
                else
                    object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber() : message.endTime;
            if (message.createdTime != null && message.hasOwnProperty("createdTime"))
                if (typeof message.createdTime === "number")
                    object.createdTime = options.longs === String ? String(message.createdTime) : message.createdTime;
                else
                    object.createdTime = options.longs === String ? $util.Long.prototype.toString.call(message.createdTime) : options.longs === Number ? new $util.LongBits(message.createdTime.low >>> 0, message.createdTime.high >>> 0).toNumber() : message.createdTime;
            if (message.scopeKey != null && message.hasOwnProperty("scopeKey"))
                object.scopeKey = message.scopeKey;
            if (message.scopeValue != null && message.hasOwnProperty("scopeValue"))
                object.scopeValue = message.scopeValue;
            if (message.ext != null && message.hasOwnProperty("ext"))
                object.ext = message.ext;
            return object;
        };

        /**
         * Converts this BanUser to JSON.
         * @function toJSON
         * @memberof immessage.BanUser
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BanUser.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BanUser
         * @function getTypeUrl
         * @memberof immessage.BanUser
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BanUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.BanUser";
        };

        return BanUser;
    })();

    immessage.QryBanUsersReq = (function() {

        /**
         * Properties of a QryBanUsersReq.
         * @memberof immessage
         * @interface IQryBanUsersReq
         * @property {number|Long|null} [limit] QryBanUsersReq limit
         * @property {string|null} [offset] QryBanUsersReq offset
         */

        /**
         * Constructs a new QryBanUsersReq.
         * @memberof immessage
         * @classdesc Represents a QryBanUsersReq.
         * @implements IQryBanUsersReq
         * @constructor
         * @param {immessage.IQryBanUsersReq=} [properties] Properties to set
         */
        function QryBanUsersReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryBanUsersReq limit.
         * @member {number|Long} limit
         * @memberof immessage.QryBanUsersReq
         * @instance
         */
        QryBanUsersReq.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QryBanUsersReq offset.
         * @member {string} offset
         * @memberof immessage.QryBanUsersReq
         * @instance
         */
        QryBanUsersReq.prototype.offset = "";

        /**
         * Creates a new QryBanUsersReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryBanUsersReq
         * @static
         * @param {immessage.IQryBanUsersReq=} [properties] Properties to set
         * @returns {immessage.QryBanUsersReq} QryBanUsersReq instance
         */
        QryBanUsersReq.create = function create(properties) {
            return new QryBanUsersReq(properties);
        };

        /**
         * Encodes the specified QryBanUsersReq message. Does not implicitly {@link immessage.QryBanUsersReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryBanUsersReq
         * @static
         * @param {immessage.IQryBanUsersReq} message QryBanUsersReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryBanUsersReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.limit);
            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.offset);
            return writer;
        };

        /**
         * Encodes the specified QryBanUsersReq message, length delimited. Does not implicitly {@link immessage.QryBanUsersReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryBanUsersReq
         * @static
         * @param {immessage.IQryBanUsersReq} message QryBanUsersReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryBanUsersReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryBanUsersReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryBanUsersReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryBanUsersReq} QryBanUsersReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryBanUsersReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryBanUsersReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.limit = reader.int64();
                        break;
                    }
                case 2: {
                        message.offset = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryBanUsersReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryBanUsersReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryBanUsersReq} QryBanUsersReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryBanUsersReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryBanUsersReq message.
         * @function verify
         * @memberof immessage.QryBanUsersReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryBanUsersReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                    return "limit: integer|Long expected";
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isString(message.offset))
                    return "offset: string expected";
            return null;
        };

        /**
         * Creates a QryBanUsersReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryBanUsersReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryBanUsersReq} QryBanUsersReq
         */
        QryBanUsersReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryBanUsersReq)
                return object;
            let message = new $root.immessage.QryBanUsersReq();
            if (object.limit != null)
                if ($util.Long)
                    (message.limit = $util.Long.fromValue(object.limit)).unsigned = false;
                else if (typeof object.limit === "string")
                    message.limit = parseInt(object.limit, 10);
                else if (typeof object.limit === "number")
                    message.limit = object.limit;
                else if (typeof object.limit === "object")
                    message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber();
            if (object.offset != null)
                message.offset = String(object.offset);
            return message;
        };

        /**
         * Creates a plain object from a QryBanUsersReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryBanUsersReq
         * @static
         * @param {immessage.QryBanUsersReq} message QryBanUsersReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryBanUsersReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.limit = options.longs === String ? "0" : 0;
                object.offset = "";
            }
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (typeof message.limit === "number")
                    object.limit = options.longs === String ? String(message.limit) : message.limit;
                else
                    object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber() : message.limit;
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            return object;
        };

        /**
         * Converts this QryBanUsersReq to JSON.
         * @function toJSON
         * @memberof immessage.QryBanUsersReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryBanUsersReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryBanUsersReq
         * @function getTypeUrl
         * @memberof immessage.QryBanUsersReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryBanUsersReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryBanUsersReq";
        };

        return QryBanUsersReq;
    })();

    immessage.QryBanUsersResp = (function() {

        /**
         * Properties of a QryBanUsersResp.
         * @memberof immessage
         * @interface IQryBanUsersResp
         * @property {Array.<immessage.IBanUser>|null} [items] QryBanUsersResp items
         * @property {string|null} [offset] QryBanUsersResp offset
         */

        /**
         * Constructs a new QryBanUsersResp.
         * @memberof immessage
         * @classdesc Represents a QryBanUsersResp.
         * @implements IQryBanUsersResp
         * @constructor
         * @param {immessage.IQryBanUsersResp=} [properties] Properties to set
         */
        function QryBanUsersResp(properties) {
            this.items = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryBanUsersResp items.
         * @member {Array.<immessage.IBanUser>} items
         * @memberof immessage.QryBanUsersResp
         * @instance
         */
        QryBanUsersResp.prototype.items = $util.emptyArray;

        /**
         * QryBanUsersResp offset.
         * @member {string} offset
         * @memberof immessage.QryBanUsersResp
         * @instance
         */
        QryBanUsersResp.prototype.offset = "";

        /**
         * Creates a new QryBanUsersResp instance using the specified properties.
         * @function create
         * @memberof immessage.QryBanUsersResp
         * @static
         * @param {immessage.IQryBanUsersResp=} [properties] Properties to set
         * @returns {immessage.QryBanUsersResp} QryBanUsersResp instance
         */
        QryBanUsersResp.create = function create(properties) {
            return new QryBanUsersResp(properties);
        };

        /**
         * Encodes the specified QryBanUsersResp message. Does not implicitly {@link immessage.QryBanUsersResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryBanUsersResp
         * @static
         * @param {immessage.IQryBanUsersResp} message QryBanUsersResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryBanUsersResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (let i = 0; i < message.items.length; ++i)
                    $root.immessage.BanUser.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.offset);
            return writer;
        };

        /**
         * Encodes the specified QryBanUsersResp message, length delimited. Does not implicitly {@link immessage.QryBanUsersResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryBanUsersResp
         * @static
         * @param {immessage.IQryBanUsersResp} message QryBanUsersResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryBanUsersResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryBanUsersResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryBanUsersResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryBanUsersResp} QryBanUsersResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryBanUsersResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryBanUsersResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.immessage.BanUser.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.offset = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryBanUsersResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryBanUsersResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryBanUsersResp} QryBanUsersResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryBanUsersResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryBanUsersResp message.
         * @function verify
         * @memberof immessage.QryBanUsersResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryBanUsersResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (let i = 0; i < message.items.length; ++i) {
                    let error = $root.immessage.BanUser.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isString(message.offset))
                    return "offset: string expected";
            return null;
        };

        /**
         * Creates a QryBanUsersResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryBanUsersResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryBanUsersResp} QryBanUsersResp
         */
        QryBanUsersResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryBanUsersResp)
                return object;
            let message = new $root.immessage.QryBanUsersResp();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".immessage.QryBanUsersResp.items: array expected");
                message.items = [];
                for (let i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".immessage.QryBanUsersResp.items: object expected");
                    message.items[i] = $root.immessage.BanUser.fromObject(object.items[i]);
                }
            }
            if (object.offset != null)
                message.offset = String(object.offset);
            return message;
        };

        /**
         * Creates a plain object from a QryBanUsersResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryBanUsersResp
         * @static
         * @param {immessage.QryBanUsersResp} message QryBanUsersResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryBanUsersResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                object.offset = "";
            if (message.items && message.items.length) {
                object.items = [];
                for (let j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.immessage.BanUser.toObject(message.items[j], options);
            }
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            return object;
        };

        /**
         * Converts this QryBanUsersResp to JSON.
         * @function toJSON
         * @memberof immessage.QryBanUsersResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryBanUsersResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryBanUsersResp
         * @function getTypeUrl
         * @memberof immessage.QryBanUsersResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryBanUsersResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryBanUsersResp";
        };

        return QryBanUsersResp;
    })();

    immessage.BlockUsersReq = (function() {

        /**
         * Properties of a BlockUsersReq.
         * @memberof immessage
         * @interface IBlockUsersReq
         * @property {Array.<string>|null} [userIds] BlockUsersReq userIds
         * @property {boolean|null} [isAdd] BlockUsersReq isAdd
         */

        /**
         * Constructs a new BlockUsersReq.
         * @memberof immessage
         * @classdesc Represents a BlockUsersReq.
         * @implements IBlockUsersReq
         * @constructor
         * @param {immessage.IBlockUsersReq=} [properties] Properties to set
         */
        function BlockUsersReq(properties) {
            this.userIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockUsersReq userIds.
         * @member {Array.<string>} userIds
         * @memberof immessage.BlockUsersReq
         * @instance
         */
        BlockUsersReq.prototype.userIds = $util.emptyArray;

        /**
         * BlockUsersReq isAdd.
         * @member {boolean} isAdd
         * @memberof immessage.BlockUsersReq
         * @instance
         */
        BlockUsersReq.prototype.isAdd = false;

        /**
         * Creates a new BlockUsersReq instance using the specified properties.
         * @function create
         * @memberof immessage.BlockUsersReq
         * @static
         * @param {immessage.IBlockUsersReq=} [properties] Properties to set
         * @returns {immessage.BlockUsersReq} BlockUsersReq instance
         */
        BlockUsersReq.create = function create(properties) {
            return new BlockUsersReq(properties);
        };

        /**
         * Encodes the specified BlockUsersReq message. Does not implicitly {@link immessage.BlockUsersReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.BlockUsersReq
         * @static
         * @param {immessage.IBlockUsersReq} message BlockUsersReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockUsersReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userIds != null && message.userIds.length)
                for (let i = 0; i < message.userIds.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.userIds[i]);
            if (message.isAdd != null && Object.hasOwnProperty.call(message, "isAdd"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isAdd);
            return writer;
        };

        /**
         * Encodes the specified BlockUsersReq message, length delimited. Does not implicitly {@link immessage.BlockUsersReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.BlockUsersReq
         * @static
         * @param {immessage.IBlockUsersReq} message BlockUsersReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockUsersReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockUsersReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.BlockUsersReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.BlockUsersReq} BlockUsersReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockUsersReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.BlockUsersReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.userIds && message.userIds.length))
                            message.userIds = [];
                        message.userIds.push(reader.string());
                        break;
                    }
                case 2: {
                        message.isAdd = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockUsersReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.BlockUsersReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.BlockUsersReq} BlockUsersReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockUsersReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockUsersReq message.
         * @function verify
         * @memberof immessage.BlockUsersReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockUsersReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userIds != null && message.hasOwnProperty("userIds")) {
                if (!Array.isArray(message.userIds))
                    return "userIds: array expected";
                for (let i = 0; i < message.userIds.length; ++i)
                    if (!$util.isString(message.userIds[i]))
                        return "userIds: string[] expected";
            }
            if (message.isAdd != null && message.hasOwnProperty("isAdd"))
                if (typeof message.isAdd !== "boolean")
                    return "isAdd: boolean expected";
            return null;
        };

        /**
         * Creates a BlockUsersReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.BlockUsersReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.BlockUsersReq} BlockUsersReq
         */
        BlockUsersReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.BlockUsersReq)
                return object;
            let message = new $root.immessage.BlockUsersReq();
            if (object.userIds) {
                if (!Array.isArray(object.userIds))
                    throw TypeError(".immessage.BlockUsersReq.userIds: array expected");
                message.userIds = [];
                for (let i = 0; i < object.userIds.length; ++i)
                    message.userIds[i] = String(object.userIds[i]);
            }
            if (object.isAdd != null)
                message.isAdd = Boolean(object.isAdd);
            return message;
        };

        /**
         * Creates a plain object from a BlockUsersReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.BlockUsersReq
         * @static
         * @param {immessage.BlockUsersReq} message BlockUsersReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockUsersReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.userIds = [];
            if (options.defaults)
                object.isAdd = false;
            if (message.userIds && message.userIds.length) {
                object.userIds = [];
                for (let j = 0; j < message.userIds.length; ++j)
                    object.userIds[j] = message.userIds[j];
            }
            if (message.isAdd != null && message.hasOwnProperty("isAdd"))
                object.isAdd = message.isAdd;
            return object;
        };

        /**
         * Converts this BlockUsersReq to JSON.
         * @function toJSON
         * @memberof immessage.BlockUsersReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockUsersReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BlockUsersReq
         * @function getTypeUrl
         * @memberof immessage.BlockUsersReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BlockUsersReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.BlockUsersReq";
        };

        return BlockUsersReq;
    })();

    immessage.QryBlockUsersReq = (function() {

        /**
         * Properties of a QryBlockUsersReq.
         * @memberof immessage
         * @interface IQryBlockUsersReq
         * @property {string|null} [userId] QryBlockUsersReq userId
         * @property {number|Long|null} [limit] QryBlockUsersReq limit
         * @property {string|null} [offset] QryBlockUsersReq offset
         */

        /**
         * Constructs a new QryBlockUsersReq.
         * @memberof immessage
         * @classdesc Represents a QryBlockUsersReq.
         * @implements IQryBlockUsersReq
         * @constructor
         * @param {immessage.IQryBlockUsersReq=} [properties] Properties to set
         */
        function QryBlockUsersReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryBlockUsersReq userId.
         * @member {string} userId
         * @memberof immessage.QryBlockUsersReq
         * @instance
         */
        QryBlockUsersReq.prototype.userId = "";

        /**
         * QryBlockUsersReq limit.
         * @member {number|Long} limit
         * @memberof immessage.QryBlockUsersReq
         * @instance
         */
        QryBlockUsersReq.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QryBlockUsersReq offset.
         * @member {string} offset
         * @memberof immessage.QryBlockUsersReq
         * @instance
         */
        QryBlockUsersReq.prototype.offset = "";

        /**
         * Creates a new QryBlockUsersReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryBlockUsersReq
         * @static
         * @param {immessage.IQryBlockUsersReq=} [properties] Properties to set
         * @returns {immessage.QryBlockUsersReq} QryBlockUsersReq instance
         */
        QryBlockUsersReq.create = function create(properties) {
            return new QryBlockUsersReq(properties);
        };

        /**
         * Encodes the specified QryBlockUsersReq message. Does not implicitly {@link immessage.QryBlockUsersReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryBlockUsersReq
         * @static
         * @param {immessage.IQryBlockUsersReq} message QryBlockUsersReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryBlockUsersReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.limit);
            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.offset);
            return writer;
        };

        /**
         * Encodes the specified QryBlockUsersReq message, length delimited. Does not implicitly {@link immessage.QryBlockUsersReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryBlockUsersReq
         * @static
         * @param {immessage.IQryBlockUsersReq} message QryBlockUsersReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryBlockUsersReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryBlockUsersReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryBlockUsersReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryBlockUsersReq} QryBlockUsersReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryBlockUsersReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryBlockUsersReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.limit = reader.int64();
                        break;
                    }
                case 3: {
                        message.offset = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryBlockUsersReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryBlockUsersReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryBlockUsersReq} QryBlockUsersReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryBlockUsersReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryBlockUsersReq message.
         * @function verify
         * @memberof immessage.QryBlockUsersReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryBlockUsersReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                    return "limit: integer|Long expected";
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isString(message.offset))
                    return "offset: string expected";
            return null;
        };

        /**
         * Creates a QryBlockUsersReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryBlockUsersReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryBlockUsersReq} QryBlockUsersReq
         */
        QryBlockUsersReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryBlockUsersReq)
                return object;
            let message = new $root.immessage.QryBlockUsersReq();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.limit != null)
                if ($util.Long)
                    (message.limit = $util.Long.fromValue(object.limit)).unsigned = false;
                else if (typeof object.limit === "string")
                    message.limit = parseInt(object.limit, 10);
                else if (typeof object.limit === "number")
                    message.limit = object.limit;
                else if (typeof object.limit === "object")
                    message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber();
            if (object.offset != null)
                message.offset = String(object.offset);
            return message;
        };

        /**
         * Creates a plain object from a QryBlockUsersReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryBlockUsersReq
         * @static
         * @param {immessage.QryBlockUsersReq} message QryBlockUsersReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryBlockUsersReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.limit = options.longs === String ? "0" : 0;
                object.offset = "";
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (typeof message.limit === "number")
                    object.limit = options.longs === String ? String(message.limit) : message.limit;
                else
                    object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber() : message.limit;
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            return object;
        };

        /**
         * Converts this QryBlockUsersReq to JSON.
         * @function toJSON
         * @memberof immessage.QryBlockUsersReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryBlockUsersReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryBlockUsersReq
         * @function getTypeUrl
         * @memberof immessage.QryBlockUsersReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryBlockUsersReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryBlockUsersReq";
        };

        return QryBlockUsersReq;
    })();

    immessage.BlockUser = (function() {

        /**
         * Properties of a BlockUser.
         * @memberof immessage
         * @interface IBlockUser
         * @property {string|null} [blockUserId] BlockUser blockUserId
         * @property {number|Long|null} [createdTime] BlockUser createdTime
         */

        /**
         * Constructs a new BlockUser.
         * @memberof immessage
         * @classdesc Represents a BlockUser.
         * @implements IBlockUser
         * @constructor
         * @param {immessage.IBlockUser=} [properties] Properties to set
         */
        function BlockUser(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockUser blockUserId.
         * @member {string} blockUserId
         * @memberof immessage.BlockUser
         * @instance
         */
        BlockUser.prototype.blockUserId = "";

        /**
         * BlockUser createdTime.
         * @member {number|Long} createdTime
         * @memberof immessage.BlockUser
         * @instance
         */
        BlockUser.prototype.createdTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new BlockUser instance using the specified properties.
         * @function create
         * @memberof immessage.BlockUser
         * @static
         * @param {immessage.IBlockUser=} [properties] Properties to set
         * @returns {immessage.BlockUser} BlockUser instance
         */
        BlockUser.create = function create(properties) {
            return new BlockUser(properties);
        };

        /**
         * Encodes the specified BlockUser message. Does not implicitly {@link immessage.BlockUser.verify|verify} messages.
         * @function encode
         * @memberof immessage.BlockUser
         * @static
         * @param {immessage.IBlockUser} message BlockUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockUserId != null && Object.hasOwnProperty.call(message, "blockUserId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.blockUserId);
            if (message.createdTime != null && Object.hasOwnProperty.call(message, "createdTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.createdTime);
            return writer;
        };

        /**
         * Encodes the specified BlockUser message, length delimited. Does not implicitly {@link immessage.BlockUser.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.BlockUser
         * @static
         * @param {immessage.IBlockUser} message BlockUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockUser.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockUser message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.BlockUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.BlockUser} BlockUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.BlockUser();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.blockUserId = reader.string();
                        break;
                    }
                case 2: {
                        message.createdTime = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockUser message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.BlockUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.BlockUser} BlockUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockUser.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockUser message.
         * @function verify
         * @memberof immessage.BlockUser
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockUser.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockUserId != null && message.hasOwnProperty("blockUserId"))
                if (!$util.isString(message.blockUserId))
                    return "blockUserId: string expected";
            if (message.createdTime != null && message.hasOwnProperty("createdTime"))
                if (!$util.isInteger(message.createdTime) && !(message.createdTime && $util.isInteger(message.createdTime.low) && $util.isInteger(message.createdTime.high)))
                    return "createdTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a BlockUser message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.BlockUser
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.BlockUser} BlockUser
         */
        BlockUser.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.BlockUser)
                return object;
            let message = new $root.immessage.BlockUser();
            if (object.blockUserId != null)
                message.blockUserId = String(object.blockUserId);
            if (object.createdTime != null)
                if ($util.Long)
                    (message.createdTime = $util.Long.fromValue(object.createdTime)).unsigned = false;
                else if (typeof object.createdTime === "string")
                    message.createdTime = parseInt(object.createdTime, 10);
                else if (typeof object.createdTime === "number")
                    message.createdTime = object.createdTime;
                else if (typeof object.createdTime === "object")
                    message.createdTime = new $util.LongBits(object.createdTime.low >>> 0, object.createdTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a BlockUser message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.BlockUser
         * @static
         * @param {immessage.BlockUser} message BlockUser
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockUser.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.blockUserId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.createdTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createdTime = options.longs === String ? "0" : 0;
            }
            if (message.blockUserId != null && message.hasOwnProperty("blockUserId"))
                object.blockUserId = message.blockUserId;
            if (message.createdTime != null && message.hasOwnProperty("createdTime"))
                if (typeof message.createdTime === "number")
                    object.createdTime = options.longs === String ? String(message.createdTime) : message.createdTime;
                else
                    object.createdTime = options.longs === String ? $util.Long.prototype.toString.call(message.createdTime) : options.longs === Number ? new $util.LongBits(message.createdTime.low >>> 0, message.createdTime.high >>> 0).toNumber() : message.createdTime;
            return object;
        };

        /**
         * Converts this BlockUser to JSON.
         * @function toJSON
         * @memberof immessage.BlockUser
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockUser.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BlockUser
         * @function getTypeUrl
         * @memberof immessage.BlockUser
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BlockUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.BlockUser";
        };

        return BlockUser;
    })();

    immessage.QryBlockUsersResp = (function() {

        /**
         * Properties of a QryBlockUsersResp.
         * @memberof immessage
         * @interface IQryBlockUsersResp
         * @property {Array.<immessage.IBlockUser>|null} [items] QryBlockUsersResp items
         * @property {string|null} [offset] QryBlockUsersResp offset
         */

        /**
         * Constructs a new QryBlockUsersResp.
         * @memberof immessage
         * @classdesc Represents a QryBlockUsersResp.
         * @implements IQryBlockUsersResp
         * @constructor
         * @param {immessage.IQryBlockUsersResp=} [properties] Properties to set
         */
        function QryBlockUsersResp(properties) {
            this.items = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryBlockUsersResp items.
         * @member {Array.<immessage.IBlockUser>} items
         * @memberof immessage.QryBlockUsersResp
         * @instance
         */
        QryBlockUsersResp.prototype.items = $util.emptyArray;

        /**
         * QryBlockUsersResp offset.
         * @member {string} offset
         * @memberof immessage.QryBlockUsersResp
         * @instance
         */
        QryBlockUsersResp.prototype.offset = "";

        /**
         * Creates a new QryBlockUsersResp instance using the specified properties.
         * @function create
         * @memberof immessage.QryBlockUsersResp
         * @static
         * @param {immessage.IQryBlockUsersResp=} [properties] Properties to set
         * @returns {immessage.QryBlockUsersResp} QryBlockUsersResp instance
         */
        QryBlockUsersResp.create = function create(properties) {
            return new QryBlockUsersResp(properties);
        };

        /**
         * Encodes the specified QryBlockUsersResp message. Does not implicitly {@link immessage.QryBlockUsersResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryBlockUsersResp
         * @static
         * @param {immessage.IQryBlockUsersResp} message QryBlockUsersResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryBlockUsersResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (let i = 0; i < message.items.length; ++i)
                    $root.immessage.BlockUser.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.offset);
            return writer;
        };

        /**
         * Encodes the specified QryBlockUsersResp message, length delimited. Does not implicitly {@link immessage.QryBlockUsersResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryBlockUsersResp
         * @static
         * @param {immessage.IQryBlockUsersResp} message QryBlockUsersResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryBlockUsersResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryBlockUsersResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryBlockUsersResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryBlockUsersResp} QryBlockUsersResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryBlockUsersResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryBlockUsersResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.immessage.BlockUser.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.offset = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryBlockUsersResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryBlockUsersResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryBlockUsersResp} QryBlockUsersResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryBlockUsersResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryBlockUsersResp message.
         * @function verify
         * @memberof immessage.QryBlockUsersResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryBlockUsersResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (let i = 0; i < message.items.length; ++i) {
                    let error = $root.immessage.BlockUser.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isString(message.offset))
                    return "offset: string expected";
            return null;
        };

        /**
         * Creates a QryBlockUsersResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryBlockUsersResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryBlockUsersResp} QryBlockUsersResp
         */
        QryBlockUsersResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryBlockUsersResp)
                return object;
            let message = new $root.immessage.QryBlockUsersResp();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".immessage.QryBlockUsersResp.items: array expected");
                message.items = [];
                for (let i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".immessage.QryBlockUsersResp.items: object expected");
                    message.items[i] = $root.immessage.BlockUser.fromObject(object.items[i]);
                }
            }
            if (object.offset != null)
                message.offset = String(object.offset);
            return message;
        };

        /**
         * Creates a plain object from a QryBlockUsersResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryBlockUsersResp
         * @static
         * @param {immessage.QryBlockUsersResp} message QryBlockUsersResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryBlockUsersResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                object.offset = "";
            if (message.items && message.items.length) {
                object.items = [];
                for (let j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.immessage.BlockUser.toObject(message.items[j], options);
            }
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            return object;
        };

        /**
         * Converts this QryBlockUsersResp to JSON.
         * @function toJSON
         * @memberof immessage.QryBlockUsersResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryBlockUsersResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryBlockUsersResp
         * @function getTypeUrl
         * @memberof immessage.QryBlockUsersResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryBlockUsersResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryBlockUsersResp";
        };

        return QryBlockUsersResp;
    })();

    immessage.CheckBlockUserResp = (function() {

        /**
         * Properties of a CheckBlockUserResp.
         * @memberof immessage
         * @interface ICheckBlockUserResp
         * @property {boolean|null} [isBlock] CheckBlockUserResp isBlock
         */

        /**
         * Constructs a new CheckBlockUserResp.
         * @memberof immessage
         * @classdesc Represents a CheckBlockUserResp.
         * @implements ICheckBlockUserResp
         * @constructor
         * @param {immessage.ICheckBlockUserResp=} [properties] Properties to set
         */
        function CheckBlockUserResp(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CheckBlockUserResp isBlock.
         * @member {boolean} isBlock
         * @memberof immessage.CheckBlockUserResp
         * @instance
         */
        CheckBlockUserResp.prototype.isBlock = false;

        /**
         * Creates a new CheckBlockUserResp instance using the specified properties.
         * @function create
         * @memberof immessage.CheckBlockUserResp
         * @static
         * @param {immessage.ICheckBlockUserResp=} [properties] Properties to set
         * @returns {immessage.CheckBlockUserResp} CheckBlockUserResp instance
         */
        CheckBlockUserResp.create = function create(properties) {
            return new CheckBlockUserResp(properties);
        };

        /**
         * Encodes the specified CheckBlockUserResp message. Does not implicitly {@link immessage.CheckBlockUserResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.CheckBlockUserResp
         * @static
         * @param {immessage.ICheckBlockUserResp} message CheckBlockUserResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckBlockUserResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isBlock != null && Object.hasOwnProperty.call(message, "isBlock"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isBlock);
            return writer;
        };

        /**
         * Encodes the specified CheckBlockUserResp message, length delimited. Does not implicitly {@link immessage.CheckBlockUserResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.CheckBlockUserResp
         * @static
         * @param {immessage.ICheckBlockUserResp} message CheckBlockUserResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckBlockUserResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CheckBlockUserResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.CheckBlockUserResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.CheckBlockUserResp} CheckBlockUserResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckBlockUserResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.CheckBlockUserResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.isBlock = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CheckBlockUserResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.CheckBlockUserResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.CheckBlockUserResp} CheckBlockUserResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckBlockUserResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CheckBlockUserResp message.
         * @function verify
         * @memberof immessage.CheckBlockUserResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CheckBlockUserResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isBlock != null && message.hasOwnProperty("isBlock"))
                if (typeof message.isBlock !== "boolean")
                    return "isBlock: boolean expected";
            return null;
        };

        /**
         * Creates a CheckBlockUserResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.CheckBlockUserResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.CheckBlockUserResp} CheckBlockUserResp
         */
        CheckBlockUserResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.CheckBlockUserResp)
                return object;
            let message = new $root.immessage.CheckBlockUserResp();
            if (object.isBlock != null)
                message.isBlock = Boolean(object.isBlock);
            return message;
        };

        /**
         * Creates a plain object from a CheckBlockUserResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.CheckBlockUserResp
         * @static
         * @param {immessage.CheckBlockUserResp} message CheckBlockUserResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CheckBlockUserResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.isBlock = false;
            if (message.isBlock != null && message.hasOwnProperty("isBlock"))
                object.isBlock = message.isBlock;
            return object;
        };

        /**
         * Converts this CheckBlockUserResp to JSON.
         * @function toJSON
         * @memberof immessage.CheckBlockUserResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CheckBlockUserResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CheckBlockUserResp
         * @function getTypeUrl
         * @memberof immessage.CheckBlockUserResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CheckBlockUserResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.CheckBlockUserResp";
        };

        return CheckBlockUserResp;
    })();

    /**
     * OnlineType enum.
     * @name immessage.OnlineType
     * @enum {number}
     * @property {number} Offline=0 Offline value
     * @property {number} Online=1 Online value
     */
    immessage.OnlineType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Offline"] = 0;
        values[valuesById[1] = "Online"] = 1;
        return values;
    })();

    immessage.OnlineStatus = (function() {

        /**
         * Properties of an OnlineStatus.
         * @memberof immessage
         * @interface IOnlineStatus
         * @property {immessage.OnlineType|null} [type] OnlineStatus type
         * @property {string|null} [targetSession] OnlineStatus targetSession
         * @property {number|null} [targetIndex] OnlineStatus targetIndex
         * @property {Array.<string>|null} [platforms] OnlineStatus platforms
         */

        /**
         * Constructs a new OnlineStatus.
         * @memberof immessage
         * @classdesc Represents an OnlineStatus.
         * @implements IOnlineStatus
         * @constructor
         * @param {immessage.IOnlineStatus=} [properties] Properties to set
         */
        function OnlineStatus(properties) {
            this.platforms = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OnlineStatus type.
         * @member {immessage.OnlineType} type
         * @memberof immessage.OnlineStatus
         * @instance
         */
        OnlineStatus.prototype.type = 0;

        /**
         * OnlineStatus targetSession.
         * @member {string} targetSession
         * @memberof immessage.OnlineStatus
         * @instance
         */
        OnlineStatus.prototype.targetSession = "";

        /**
         * OnlineStatus targetIndex.
         * @member {number} targetIndex
         * @memberof immessage.OnlineStatus
         * @instance
         */
        OnlineStatus.prototype.targetIndex = 0;

        /**
         * OnlineStatus platforms.
         * @member {Array.<string>} platforms
         * @memberof immessage.OnlineStatus
         * @instance
         */
        OnlineStatus.prototype.platforms = $util.emptyArray;

        /**
         * Creates a new OnlineStatus instance using the specified properties.
         * @function create
         * @memberof immessage.OnlineStatus
         * @static
         * @param {immessage.IOnlineStatus=} [properties] Properties to set
         * @returns {immessage.OnlineStatus} OnlineStatus instance
         */
        OnlineStatus.create = function create(properties) {
            return new OnlineStatus(properties);
        };

        /**
         * Encodes the specified OnlineStatus message. Does not implicitly {@link immessage.OnlineStatus.verify|verify} messages.
         * @function encode
         * @memberof immessage.OnlineStatus
         * @static
         * @param {immessage.IOnlineStatus} message OnlineStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OnlineStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.targetSession != null && Object.hasOwnProperty.call(message, "targetSession"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetSession);
            if (message.targetIndex != null && Object.hasOwnProperty.call(message, "targetIndex"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.targetIndex);
            if (message.platforms != null && message.platforms.length)
                for (let i = 0; i < message.platforms.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.platforms[i]);
            return writer;
        };

        /**
         * Encodes the specified OnlineStatus message, length delimited. Does not implicitly {@link immessage.OnlineStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.OnlineStatus
         * @static
         * @param {immessage.IOnlineStatus} message OnlineStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OnlineStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OnlineStatus message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.OnlineStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.OnlineStatus} OnlineStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OnlineStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.OnlineStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.targetSession = reader.string();
                        break;
                    }
                case 3: {
                        message.targetIndex = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.platforms && message.platforms.length))
                            message.platforms = [];
                        message.platforms.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OnlineStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.OnlineStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.OnlineStatus} OnlineStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OnlineStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OnlineStatus message.
         * @function verify
         * @memberof immessage.OnlineStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OnlineStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.targetSession != null && message.hasOwnProperty("targetSession"))
                if (!$util.isString(message.targetSession))
                    return "targetSession: string expected";
            if (message.targetIndex != null && message.hasOwnProperty("targetIndex"))
                if (!$util.isInteger(message.targetIndex))
                    return "targetIndex: integer expected";
            if (message.platforms != null && message.hasOwnProperty("platforms")) {
                if (!Array.isArray(message.platforms))
                    return "platforms: array expected";
                for (let i = 0; i < message.platforms.length; ++i)
                    if (!$util.isString(message.platforms[i]))
                        return "platforms: string[] expected";
            }
            return null;
        };

        /**
         * Creates an OnlineStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.OnlineStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.OnlineStatus} OnlineStatus
         */
        OnlineStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.OnlineStatus)
                return object;
            let message = new $root.immessage.OnlineStatus();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "Offline":
            case 0:
                message.type = 0;
                break;
            case "Online":
            case 1:
                message.type = 1;
                break;
            }
            if (object.targetSession != null)
                message.targetSession = String(object.targetSession);
            if (object.targetIndex != null)
                message.targetIndex = object.targetIndex | 0;
            if (object.platforms) {
                if (!Array.isArray(object.platforms))
                    throw TypeError(".immessage.OnlineStatus.platforms: array expected");
                message.platforms = [];
                for (let i = 0; i < object.platforms.length; ++i)
                    message.platforms[i] = String(object.platforms[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an OnlineStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.OnlineStatus
         * @static
         * @param {immessage.OnlineStatus} message OnlineStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OnlineStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.platforms = [];
            if (options.defaults) {
                object.type = options.enums === String ? "Offline" : 0;
                object.targetSession = "";
                object.targetIndex = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.immessage.OnlineType[message.type] === undefined ? message.type : $root.immessage.OnlineType[message.type] : message.type;
            if (message.targetSession != null && message.hasOwnProperty("targetSession"))
                object.targetSession = message.targetSession;
            if (message.targetIndex != null && message.hasOwnProperty("targetIndex"))
                object.targetIndex = message.targetIndex;
            if (message.platforms && message.platforms.length) {
                object.platforms = [];
                for (let j = 0; j < message.platforms.length; ++j)
                    object.platforms[j] = message.platforms[j];
            }
            return object;
        };

        /**
         * Converts this OnlineStatus to JSON.
         * @function toJSON
         * @memberof immessage.OnlineStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OnlineStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OnlineStatus
         * @function getTypeUrl
         * @memberof immessage.OnlineStatus
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OnlineStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.OnlineStatus";
        };

        return OnlineStatus;
    })();

    immessage.KickUserReq = (function() {

        /**
         * Properties of a KickUserReq.
         * @memberof immessage
         * @interface IKickUserReq
         * @property {string|null} [userId] KickUserReq userId
         * @property {string|null} [ext] KickUserReq ext
         * @property {Array.<string>|null} [platforms] KickUserReq platforms
         * @property {Array.<string>|null} [deviceIds] KickUserReq deviceIds
         * @property {Array.<string>|null} [ips] KickUserReq ips
         */

        /**
         * Constructs a new KickUserReq.
         * @memberof immessage
         * @classdesc Represents a KickUserReq.
         * @implements IKickUserReq
         * @constructor
         * @param {immessage.IKickUserReq=} [properties] Properties to set
         */
        function KickUserReq(properties) {
            this.platforms = [];
            this.deviceIds = [];
            this.ips = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KickUserReq userId.
         * @member {string} userId
         * @memberof immessage.KickUserReq
         * @instance
         */
        KickUserReq.prototype.userId = "";

        /**
         * KickUserReq ext.
         * @member {string} ext
         * @memberof immessage.KickUserReq
         * @instance
         */
        KickUserReq.prototype.ext = "";

        /**
         * KickUserReq platforms.
         * @member {Array.<string>} platforms
         * @memberof immessage.KickUserReq
         * @instance
         */
        KickUserReq.prototype.platforms = $util.emptyArray;

        /**
         * KickUserReq deviceIds.
         * @member {Array.<string>} deviceIds
         * @memberof immessage.KickUserReq
         * @instance
         */
        KickUserReq.prototype.deviceIds = $util.emptyArray;

        /**
         * KickUserReq ips.
         * @member {Array.<string>} ips
         * @memberof immessage.KickUserReq
         * @instance
         */
        KickUserReq.prototype.ips = $util.emptyArray;

        /**
         * Creates a new KickUserReq instance using the specified properties.
         * @function create
         * @memberof immessage.KickUserReq
         * @static
         * @param {immessage.IKickUserReq=} [properties] Properties to set
         * @returns {immessage.KickUserReq} KickUserReq instance
         */
        KickUserReq.create = function create(properties) {
            return new KickUserReq(properties);
        };

        /**
         * Encodes the specified KickUserReq message. Does not implicitly {@link immessage.KickUserReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.KickUserReq
         * @static
         * @param {immessage.IKickUserReq} message KickUserReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KickUserReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.ext != null && Object.hasOwnProperty.call(message, "ext"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ext);
            if (message.platforms != null && message.platforms.length)
                for (let i = 0; i < message.platforms.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.platforms[i]);
            if (message.deviceIds != null && message.deviceIds.length)
                for (let i = 0; i < message.deviceIds.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.deviceIds[i]);
            if (message.ips != null && message.ips.length)
                for (let i = 0; i < message.ips.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.ips[i]);
            return writer;
        };

        /**
         * Encodes the specified KickUserReq message, length delimited. Does not implicitly {@link immessage.KickUserReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.KickUserReq
         * @static
         * @param {immessage.IKickUserReq} message KickUserReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KickUserReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KickUserReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.KickUserReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.KickUserReq} KickUserReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KickUserReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.KickUserReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.ext = reader.string();
                        break;
                    }
                case 3: {
                        if (!(message.platforms && message.platforms.length))
                            message.platforms = [];
                        message.platforms.push(reader.string());
                        break;
                    }
                case 4: {
                        if (!(message.deviceIds && message.deviceIds.length))
                            message.deviceIds = [];
                        message.deviceIds.push(reader.string());
                        break;
                    }
                case 5: {
                        if (!(message.ips && message.ips.length))
                            message.ips = [];
                        message.ips.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KickUserReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.KickUserReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.KickUserReq} KickUserReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KickUserReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KickUserReq message.
         * @function verify
         * @memberof immessage.KickUserReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KickUserReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.ext != null && message.hasOwnProperty("ext"))
                if (!$util.isString(message.ext))
                    return "ext: string expected";
            if (message.platforms != null && message.hasOwnProperty("platforms")) {
                if (!Array.isArray(message.platforms))
                    return "platforms: array expected";
                for (let i = 0; i < message.platforms.length; ++i)
                    if (!$util.isString(message.platforms[i]))
                        return "platforms: string[] expected";
            }
            if (message.deviceIds != null && message.hasOwnProperty("deviceIds")) {
                if (!Array.isArray(message.deviceIds))
                    return "deviceIds: array expected";
                for (let i = 0; i < message.deviceIds.length; ++i)
                    if (!$util.isString(message.deviceIds[i]))
                        return "deviceIds: string[] expected";
            }
            if (message.ips != null && message.hasOwnProperty("ips")) {
                if (!Array.isArray(message.ips))
                    return "ips: array expected";
                for (let i = 0; i < message.ips.length; ++i)
                    if (!$util.isString(message.ips[i]))
                        return "ips: string[] expected";
            }
            return null;
        };

        /**
         * Creates a KickUserReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.KickUserReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.KickUserReq} KickUserReq
         */
        KickUserReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.KickUserReq)
                return object;
            let message = new $root.immessage.KickUserReq();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.ext != null)
                message.ext = String(object.ext);
            if (object.platforms) {
                if (!Array.isArray(object.platforms))
                    throw TypeError(".immessage.KickUserReq.platforms: array expected");
                message.platforms = [];
                for (let i = 0; i < object.platforms.length; ++i)
                    message.platforms[i] = String(object.platforms[i]);
            }
            if (object.deviceIds) {
                if (!Array.isArray(object.deviceIds))
                    throw TypeError(".immessage.KickUserReq.deviceIds: array expected");
                message.deviceIds = [];
                for (let i = 0; i < object.deviceIds.length; ++i)
                    message.deviceIds[i] = String(object.deviceIds[i]);
            }
            if (object.ips) {
                if (!Array.isArray(object.ips))
                    throw TypeError(".immessage.KickUserReq.ips: array expected");
                message.ips = [];
                for (let i = 0; i < object.ips.length; ++i)
                    message.ips[i] = String(object.ips[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a KickUserReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.KickUserReq
         * @static
         * @param {immessage.KickUserReq} message KickUserReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KickUserReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.platforms = [];
                object.deviceIds = [];
                object.ips = [];
            }
            if (options.defaults) {
                object.userId = "";
                object.ext = "";
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.ext != null && message.hasOwnProperty("ext"))
                object.ext = message.ext;
            if (message.platforms && message.platforms.length) {
                object.platforms = [];
                for (let j = 0; j < message.platforms.length; ++j)
                    object.platforms[j] = message.platforms[j];
            }
            if (message.deviceIds && message.deviceIds.length) {
                object.deviceIds = [];
                for (let j = 0; j < message.deviceIds.length; ++j)
                    object.deviceIds[j] = message.deviceIds[j];
            }
            if (message.ips && message.ips.length) {
                object.ips = [];
                for (let j = 0; j < message.ips.length; ++j)
                    object.ips[j] = message.ips[j];
            }
            return object;
        };

        /**
         * Converts this KickUserReq to JSON.
         * @function toJSON
         * @memberof immessage.KickUserReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KickUserReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for KickUserReq
         * @function getTypeUrl
         * @memberof immessage.KickUserReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        KickUserReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.KickUserReq";
        };

        return KickUserReq;
    })();

    immessage.UserUndisturb = (function() {

        /**
         * Properties of a UserUndisturb.
         * @memberof immessage
         * @interface IUserUndisturb
         * @property {boolean|null} ["switch"] UserUndisturb switch
         * @property {string|null} [timezone] UserUndisturb timezone
         * @property {Array.<immessage.IUserUndisturbItem>|null} [rules] UserUndisturb rules
         */

        /**
         * Constructs a new UserUndisturb.
         * @memberof immessage
         * @classdesc Represents a UserUndisturb.
         * @implements IUserUndisturb
         * @constructor
         * @param {immessage.IUserUndisturb=} [properties] Properties to set
         */
        function UserUndisturb(properties) {
            this.rules = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserUndisturb switch.
         * @member {boolean} switch
         * @memberof immessage.UserUndisturb
         * @instance
         */
        UserUndisturb.prototype["switch"] = false;

        /**
         * UserUndisturb timezone.
         * @member {string} timezone
         * @memberof immessage.UserUndisturb
         * @instance
         */
        UserUndisturb.prototype.timezone = "";

        /**
         * UserUndisturb rules.
         * @member {Array.<immessage.IUserUndisturbItem>} rules
         * @memberof immessage.UserUndisturb
         * @instance
         */
        UserUndisturb.prototype.rules = $util.emptyArray;

        /**
         * Creates a new UserUndisturb instance using the specified properties.
         * @function create
         * @memberof immessage.UserUndisturb
         * @static
         * @param {immessage.IUserUndisturb=} [properties] Properties to set
         * @returns {immessage.UserUndisturb} UserUndisturb instance
         */
        UserUndisturb.create = function create(properties) {
            return new UserUndisturb(properties);
        };

        /**
         * Encodes the specified UserUndisturb message. Does not implicitly {@link immessage.UserUndisturb.verify|verify} messages.
         * @function encode
         * @memberof immessage.UserUndisturb
         * @static
         * @param {immessage.IUserUndisturb} message UserUndisturb message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUndisturb.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message["switch"] != null && Object.hasOwnProperty.call(message, "switch"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message["switch"]);
            if (message.timezone != null && Object.hasOwnProperty.call(message, "timezone"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.timezone);
            if (message.rules != null && message.rules.length)
                for (let i = 0; i < message.rules.length; ++i)
                    $root.immessage.UserUndisturbItem.encode(message.rules[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UserUndisturb message, length delimited. Does not implicitly {@link immessage.UserUndisturb.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UserUndisturb
         * @static
         * @param {immessage.IUserUndisturb} message UserUndisturb message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUndisturb.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserUndisturb message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UserUndisturb
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UserUndisturb} UserUndisturb
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUndisturb.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UserUndisturb();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message["switch"] = reader.bool();
                        break;
                    }
                case 2: {
                        message.timezone = reader.string();
                        break;
                    }
                case 3: {
                        if (!(message.rules && message.rules.length))
                            message.rules = [];
                        message.rules.push($root.immessage.UserUndisturbItem.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserUndisturb message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UserUndisturb
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UserUndisturb} UserUndisturb
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUndisturb.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserUndisturb message.
         * @function verify
         * @memberof immessage.UserUndisturb
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserUndisturb.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["switch"] != null && message.hasOwnProperty("switch"))
                if (typeof message["switch"] !== "boolean")
                    return "switch: boolean expected";
            if (message.timezone != null && message.hasOwnProperty("timezone"))
                if (!$util.isString(message.timezone))
                    return "timezone: string expected";
            if (message.rules != null && message.hasOwnProperty("rules")) {
                if (!Array.isArray(message.rules))
                    return "rules: array expected";
                for (let i = 0; i < message.rules.length; ++i) {
                    let error = $root.immessage.UserUndisturbItem.verify(message.rules[i]);
                    if (error)
                        return "rules." + error;
                }
            }
            return null;
        };

        /**
         * Creates a UserUndisturb message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UserUndisturb
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UserUndisturb} UserUndisturb
         */
        UserUndisturb.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UserUndisturb)
                return object;
            let message = new $root.immessage.UserUndisturb();
            if (object["switch"] != null)
                message["switch"] = Boolean(object["switch"]);
            if (object.timezone != null)
                message.timezone = String(object.timezone);
            if (object.rules) {
                if (!Array.isArray(object.rules))
                    throw TypeError(".immessage.UserUndisturb.rules: array expected");
                message.rules = [];
                for (let i = 0; i < object.rules.length; ++i) {
                    if (typeof object.rules[i] !== "object")
                        throw TypeError(".immessage.UserUndisturb.rules: object expected");
                    message.rules[i] = $root.immessage.UserUndisturbItem.fromObject(object.rules[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a UserUndisturb message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UserUndisturb
         * @static
         * @param {immessage.UserUndisturb} message UserUndisturb
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserUndisturb.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.rules = [];
            if (options.defaults) {
                object["switch"] = false;
                object.timezone = "";
            }
            if (message["switch"] != null && message.hasOwnProperty("switch"))
                object["switch"] = message["switch"];
            if (message.timezone != null && message.hasOwnProperty("timezone"))
                object.timezone = message.timezone;
            if (message.rules && message.rules.length) {
                object.rules = [];
                for (let j = 0; j < message.rules.length; ++j)
                    object.rules[j] = $root.immessage.UserUndisturbItem.toObject(message.rules[j], options);
            }
            return object;
        };

        /**
         * Converts this UserUndisturb to JSON.
         * @function toJSON
         * @memberof immessage.UserUndisturb
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserUndisturb.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserUndisturb
         * @function getTypeUrl
         * @memberof immessage.UserUndisturb
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserUndisturb.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UserUndisturb";
        };

        return UserUndisturb;
    })();

    immessage.UserUndisturbItem = (function() {

        /**
         * Properties of a UserUndisturbItem.
         * @memberof immessage
         * @interface IUserUndisturbItem
         * @property {string|null} [start] UserUndisturbItem start
         * @property {string|null} [end] UserUndisturbItem end
         */

        /**
         * Constructs a new UserUndisturbItem.
         * @memberof immessage
         * @classdesc Represents a UserUndisturbItem.
         * @implements IUserUndisturbItem
         * @constructor
         * @param {immessage.IUserUndisturbItem=} [properties] Properties to set
         */
        function UserUndisturbItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserUndisturbItem start.
         * @member {string} start
         * @memberof immessage.UserUndisturbItem
         * @instance
         */
        UserUndisturbItem.prototype.start = "";

        /**
         * UserUndisturbItem end.
         * @member {string} end
         * @memberof immessage.UserUndisturbItem
         * @instance
         */
        UserUndisturbItem.prototype.end = "";

        /**
         * Creates a new UserUndisturbItem instance using the specified properties.
         * @function create
         * @memberof immessage.UserUndisturbItem
         * @static
         * @param {immessage.IUserUndisturbItem=} [properties] Properties to set
         * @returns {immessage.UserUndisturbItem} UserUndisturbItem instance
         */
        UserUndisturbItem.create = function create(properties) {
            return new UserUndisturbItem(properties);
        };

        /**
         * Encodes the specified UserUndisturbItem message. Does not implicitly {@link immessage.UserUndisturbItem.verify|verify} messages.
         * @function encode
         * @memberof immessage.UserUndisturbItem
         * @static
         * @param {immessage.IUserUndisturbItem} message UserUndisturbItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUndisturbItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.start);
            if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.end);
            return writer;
        };

        /**
         * Encodes the specified UserUndisturbItem message, length delimited. Does not implicitly {@link immessage.UserUndisturbItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UserUndisturbItem
         * @static
         * @param {immessage.IUserUndisturbItem} message UserUndisturbItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUndisturbItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserUndisturbItem message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UserUndisturbItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UserUndisturbItem} UserUndisturbItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUndisturbItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UserUndisturbItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.start = reader.string();
                        break;
                    }
                case 2: {
                        message.end = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserUndisturbItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UserUndisturbItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UserUndisturbItem} UserUndisturbItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUndisturbItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserUndisturbItem message.
         * @function verify
         * @memberof immessage.UserUndisturbItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserUndisturbItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.start != null && message.hasOwnProperty("start"))
                if (!$util.isString(message.start))
                    return "start: string expected";
            if (message.end != null && message.hasOwnProperty("end"))
                if (!$util.isString(message.end))
                    return "end: string expected";
            return null;
        };

        /**
         * Creates a UserUndisturbItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UserUndisturbItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UserUndisturbItem} UserUndisturbItem
         */
        UserUndisturbItem.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UserUndisturbItem)
                return object;
            let message = new $root.immessage.UserUndisturbItem();
            if (object.start != null)
                message.start = String(object.start);
            if (object.end != null)
                message.end = String(object.end);
            return message;
        };

        /**
         * Creates a plain object from a UserUndisturbItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UserUndisturbItem
         * @static
         * @param {immessage.UserUndisturbItem} message UserUndisturbItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserUndisturbItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.start = "";
                object.end = "";
            }
            if (message.start != null && message.hasOwnProperty("start"))
                object.start = message.start;
            if (message.end != null && message.hasOwnProperty("end"))
                object.end = message.end;
            return object;
        };

        /**
         * Converts this UserUndisturbItem to JSON.
         * @function toJSON
         * @memberof immessage.UserUndisturbItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserUndisturbItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserUndisturbItem
         * @function getTypeUrl
         * @memberof immessage.UserUndisturbItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserUndisturbItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UserUndisturbItem";
        };

        return UserUndisturbItem;
    })();

    immessage.UserPushStatus = (function() {

        /**
         * Properties of a UserPushStatus.
         * @memberof immessage
         * @interface IUserPushStatus
         * @property {boolean|null} [canPush] UserPushStatus canPush
         */

        /**
         * Constructs a new UserPushStatus.
         * @memberof immessage
         * @classdesc Represents a UserPushStatus.
         * @implements IUserPushStatus
         * @constructor
         * @param {immessage.IUserPushStatus=} [properties] Properties to set
         */
        function UserPushStatus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserPushStatus canPush.
         * @member {boolean} canPush
         * @memberof immessage.UserPushStatus
         * @instance
         */
        UserPushStatus.prototype.canPush = false;

        /**
         * Creates a new UserPushStatus instance using the specified properties.
         * @function create
         * @memberof immessage.UserPushStatus
         * @static
         * @param {immessage.IUserPushStatus=} [properties] Properties to set
         * @returns {immessage.UserPushStatus} UserPushStatus instance
         */
        UserPushStatus.create = function create(properties) {
            return new UserPushStatus(properties);
        };

        /**
         * Encodes the specified UserPushStatus message. Does not implicitly {@link immessage.UserPushStatus.verify|verify} messages.
         * @function encode
         * @memberof immessage.UserPushStatus
         * @static
         * @param {immessage.IUserPushStatus} message UserPushStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserPushStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.canPush != null && Object.hasOwnProperty.call(message, "canPush"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.canPush);
            return writer;
        };

        /**
         * Encodes the specified UserPushStatus message, length delimited. Does not implicitly {@link immessage.UserPushStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UserPushStatus
         * @static
         * @param {immessage.IUserPushStatus} message UserPushStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserPushStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserPushStatus message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UserPushStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UserPushStatus} UserPushStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserPushStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UserPushStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.canPush = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserPushStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UserPushStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UserPushStatus} UserPushStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserPushStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserPushStatus message.
         * @function verify
         * @memberof immessage.UserPushStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserPushStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.canPush != null && message.hasOwnProperty("canPush"))
                if (typeof message.canPush !== "boolean")
                    return "canPush: boolean expected";
            return null;
        };

        /**
         * Creates a UserPushStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UserPushStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UserPushStatus} UserPushStatus
         */
        UserPushStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UserPushStatus)
                return object;
            let message = new $root.immessage.UserPushStatus();
            if (object.canPush != null)
                message.canPush = Boolean(object.canPush);
            return message;
        };

        /**
         * Creates a plain object from a UserPushStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UserPushStatus
         * @static
         * @param {immessage.UserPushStatus} message UserPushStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserPushStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.canPush = false;
            if (message.canPush != null && message.hasOwnProperty("canPush"))
                object.canPush = message.canPush;
            return object;
        };

        /**
         * Converts this UserPushStatus to JSON.
         * @function toJSON
         * @memberof immessage.UserPushStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserPushStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserPushStatus
         * @function getTypeUrl
         * @memberof immessage.UserPushStatus
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserPushStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UserPushStatus";
        };

        return UserPushStatus;
    })();

    immessage.BatchMuteUsersReq = (function() {

        /**
         * Properties of a BatchMuteUsersReq.
         * @memberof immessage
         * @interface IBatchMuteUsersReq
         * @property {Array.<string>|null} [userIds] BatchMuteUsersReq userIds
         * @property {boolean|null} [isDelete] BatchMuteUsersReq isDelete
         */

        /**
         * Constructs a new BatchMuteUsersReq.
         * @memberof immessage
         * @classdesc Represents a BatchMuteUsersReq.
         * @implements IBatchMuteUsersReq
         * @constructor
         * @param {immessage.IBatchMuteUsersReq=} [properties] Properties to set
         */
        function BatchMuteUsersReq(properties) {
            this.userIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BatchMuteUsersReq userIds.
         * @member {Array.<string>} userIds
         * @memberof immessage.BatchMuteUsersReq
         * @instance
         */
        BatchMuteUsersReq.prototype.userIds = $util.emptyArray;

        /**
         * BatchMuteUsersReq isDelete.
         * @member {boolean} isDelete
         * @memberof immessage.BatchMuteUsersReq
         * @instance
         */
        BatchMuteUsersReq.prototype.isDelete = false;

        /**
         * Creates a new BatchMuteUsersReq instance using the specified properties.
         * @function create
         * @memberof immessage.BatchMuteUsersReq
         * @static
         * @param {immessage.IBatchMuteUsersReq=} [properties] Properties to set
         * @returns {immessage.BatchMuteUsersReq} BatchMuteUsersReq instance
         */
        BatchMuteUsersReq.create = function create(properties) {
            return new BatchMuteUsersReq(properties);
        };

        /**
         * Encodes the specified BatchMuteUsersReq message. Does not implicitly {@link immessage.BatchMuteUsersReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.BatchMuteUsersReq
         * @static
         * @param {immessage.IBatchMuteUsersReq} message BatchMuteUsersReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BatchMuteUsersReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userIds != null && message.userIds.length)
                for (let i = 0; i < message.userIds.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.userIds[i]);
            if (message.isDelete != null && Object.hasOwnProperty.call(message, "isDelete"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isDelete);
            return writer;
        };

        /**
         * Encodes the specified BatchMuteUsersReq message, length delimited. Does not implicitly {@link immessage.BatchMuteUsersReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.BatchMuteUsersReq
         * @static
         * @param {immessage.IBatchMuteUsersReq} message BatchMuteUsersReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BatchMuteUsersReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BatchMuteUsersReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.BatchMuteUsersReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.BatchMuteUsersReq} BatchMuteUsersReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BatchMuteUsersReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.BatchMuteUsersReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.userIds && message.userIds.length))
                            message.userIds = [];
                        message.userIds.push(reader.string());
                        break;
                    }
                case 2: {
                        message.isDelete = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BatchMuteUsersReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.BatchMuteUsersReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.BatchMuteUsersReq} BatchMuteUsersReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BatchMuteUsersReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BatchMuteUsersReq message.
         * @function verify
         * @memberof immessage.BatchMuteUsersReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BatchMuteUsersReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userIds != null && message.hasOwnProperty("userIds")) {
                if (!Array.isArray(message.userIds))
                    return "userIds: array expected";
                for (let i = 0; i < message.userIds.length; ++i)
                    if (!$util.isString(message.userIds[i]))
                        return "userIds: string[] expected";
            }
            if (message.isDelete != null && message.hasOwnProperty("isDelete"))
                if (typeof message.isDelete !== "boolean")
                    return "isDelete: boolean expected";
            return null;
        };

        /**
         * Creates a BatchMuteUsersReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.BatchMuteUsersReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.BatchMuteUsersReq} BatchMuteUsersReq
         */
        BatchMuteUsersReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.BatchMuteUsersReq)
                return object;
            let message = new $root.immessage.BatchMuteUsersReq();
            if (object.userIds) {
                if (!Array.isArray(object.userIds))
                    throw TypeError(".immessage.BatchMuteUsersReq.userIds: array expected");
                message.userIds = [];
                for (let i = 0; i < object.userIds.length; ++i)
                    message.userIds[i] = String(object.userIds[i]);
            }
            if (object.isDelete != null)
                message.isDelete = Boolean(object.isDelete);
            return message;
        };

        /**
         * Creates a plain object from a BatchMuteUsersReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.BatchMuteUsersReq
         * @static
         * @param {immessage.BatchMuteUsersReq} message BatchMuteUsersReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BatchMuteUsersReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.userIds = [];
            if (options.defaults)
                object.isDelete = false;
            if (message.userIds && message.userIds.length) {
                object.userIds = [];
                for (let j = 0; j < message.userIds.length; ++j)
                    object.userIds[j] = message.userIds[j];
            }
            if (message.isDelete != null && message.hasOwnProperty("isDelete"))
                object.isDelete = message.isDelete;
            return object;
        };

        /**
         * Converts this BatchMuteUsersReq to JSON.
         * @function toJSON
         * @memberof immessage.BatchMuteUsersReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BatchMuteUsersReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BatchMuteUsersReq
         * @function getTypeUrl
         * @memberof immessage.BatchMuteUsersReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BatchMuteUsersReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.BatchMuteUsersReq";
        };

        return BatchMuteUsersReq;
    })();

    immessage.FriendIdsReq = (function() {

        /**
         * Properties of a FriendIdsReq.
         * @memberof immessage
         * @interface IFriendIdsReq
         * @property {Array.<string>|null} [friendIds] FriendIdsReq friendIds
         */

        /**
         * Constructs a new FriendIdsReq.
         * @memberof immessage
         * @classdesc Represents a FriendIdsReq.
         * @implements IFriendIdsReq
         * @constructor
         * @param {immessage.IFriendIdsReq=} [properties] Properties to set
         */
        function FriendIdsReq(properties) {
            this.friendIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendIdsReq friendIds.
         * @member {Array.<string>} friendIds
         * @memberof immessage.FriendIdsReq
         * @instance
         */
        FriendIdsReq.prototype.friendIds = $util.emptyArray;

        /**
         * Creates a new FriendIdsReq instance using the specified properties.
         * @function create
         * @memberof immessage.FriendIdsReq
         * @static
         * @param {immessage.IFriendIdsReq=} [properties] Properties to set
         * @returns {immessage.FriendIdsReq} FriendIdsReq instance
         */
        FriendIdsReq.create = function create(properties) {
            return new FriendIdsReq(properties);
        };

        /**
         * Encodes the specified FriendIdsReq message. Does not implicitly {@link immessage.FriendIdsReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.FriendIdsReq
         * @static
         * @param {immessage.IFriendIdsReq} message FriendIdsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendIdsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.friendIds != null && message.friendIds.length)
                for (let i = 0; i < message.friendIds.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.friendIds[i]);
            return writer;
        };

        /**
         * Encodes the specified FriendIdsReq message, length delimited. Does not implicitly {@link immessage.FriendIdsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.FriendIdsReq
         * @static
         * @param {immessage.IFriendIdsReq} message FriendIdsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendIdsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FriendIdsReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.FriendIdsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.FriendIdsReq} FriendIdsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendIdsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.FriendIdsReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.friendIds && message.friendIds.length))
                            message.friendIds = [];
                        message.friendIds.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendIdsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.FriendIdsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.FriendIdsReq} FriendIdsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendIdsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FriendIdsReq message.
         * @function verify
         * @memberof immessage.FriendIdsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FriendIdsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.friendIds != null && message.hasOwnProperty("friendIds")) {
                if (!Array.isArray(message.friendIds))
                    return "friendIds: array expected";
                for (let i = 0; i < message.friendIds.length; ++i)
                    if (!$util.isString(message.friendIds[i]))
                        return "friendIds: string[] expected";
            }
            return null;
        };

        /**
         * Creates a FriendIdsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.FriendIdsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.FriendIdsReq} FriendIdsReq
         */
        FriendIdsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.FriendIdsReq)
                return object;
            let message = new $root.immessage.FriendIdsReq();
            if (object.friendIds) {
                if (!Array.isArray(object.friendIds))
                    throw TypeError(".immessage.FriendIdsReq.friendIds: array expected");
                message.friendIds = [];
                for (let i = 0; i < object.friendIds.length; ++i)
                    message.friendIds[i] = String(object.friendIds[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a FriendIdsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.FriendIdsReq
         * @static
         * @param {immessage.FriendIdsReq} message FriendIdsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FriendIdsReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.friendIds = [];
            if (message.friendIds && message.friendIds.length) {
                object.friendIds = [];
                for (let j = 0; j < message.friendIds.length; ++j)
                    object.friendIds[j] = message.friendIds[j];
            }
            return object;
        };

        /**
         * Converts this FriendIdsReq to JSON.
         * @function toJSON
         * @memberof immessage.FriendIdsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FriendIdsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FriendIdsReq
         * @function getTypeUrl
         * @memberof immessage.FriendIdsReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FriendIdsReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.FriendIdsReq";
        };

        return FriendIdsReq;
    })();

    immessage.FriendMembersReq = (function() {

        /**
         * Properties of a FriendMembersReq.
         * @memberof immessage
         * @interface IFriendMembersReq
         * @property {Array.<immessage.IFriendMember>|null} [friendMembers] FriendMembersReq friendMembers
         */

        /**
         * Constructs a new FriendMembersReq.
         * @memberof immessage
         * @classdesc Represents a FriendMembersReq.
         * @implements IFriendMembersReq
         * @constructor
         * @param {immessage.IFriendMembersReq=} [properties] Properties to set
         */
        function FriendMembersReq(properties) {
            this.friendMembers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendMembersReq friendMembers.
         * @member {Array.<immessage.IFriendMember>} friendMembers
         * @memberof immessage.FriendMembersReq
         * @instance
         */
        FriendMembersReq.prototype.friendMembers = $util.emptyArray;

        /**
         * Creates a new FriendMembersReq instance using the specified properties.
         * @function create
         * @memberof immessage.FriendMembersReq
         * @static
         * @param {immessage.IFriendMembersReq=} [properties] Properties to set
         * @returns {immessage.FriendMembersReq} FriendMembersReq instance
         */
        FriendMembersReq.create = function create(properties) {
            return new FriendMembersReq(properties);
        };

        /**
         * Encodes the specified FriendMembersReq message. Does not implicitly {@link immessage.FriendMembersReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.FriendMembersReq
         * @static
         * @param {immessage.IFriendMembersReq} message FriendMembersReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendMembersReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.friendMembers != null && message.friendMembers.length)
                for (let i = 0; i < message.friendMembers.length; ++i)
                    $root.immessage.FriendMember.encode(message.friendMembers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FriendMembersReq message, length delimited. Does not implicitly {@link immessage.FriendMembersReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.FriendMembersReq
         * @static
         * @param {immessage.IFriendMembersReq} message FriendMembersReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendMembersReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FriendMembersReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.FriendMembersReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.FriendMembersReq} FriendMembersReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendMembersReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.FriendMembersReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.friendMembers && message.friendMembers.length))
                            message.friendMembers = [];
                        message.friendMembers.push($root.immessage.FriendMember.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendMembersReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.FriendMembersReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.FriendMembersReq} FriendMembersReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendMembersReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FriendMembersReq message.
         * @function verify
         * @memberof immessage.FriendMembersReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FriendMembersReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.friendMembers != null && message.hasOwnProperty("friendMembers")) {
                if (!Array.isArray(message.friendMembers))
                    return "friendMembers: array expected";
                for (let i = 0; i < message.friendMembers.length; ++i) {
                    let error = $root.immessage.FriendMember.verify(message.friendMembers[i]);
                    if (error)
                        return "friendMembers." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FriendMembersReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.FriendMembersReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.FriendMembersReq} FriendMembersReq
         */
        FriendMembersReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.FriendMembersReq)
                return object;
            let message = new $root.immessage.FriendMembersReq();
            if (object.friendMembers) {
                if (!Array.isArray(object.friendMembers))
                    throw TypeError(".immessage.FriendMembersReq.friendMembers: array expected");
                message.friendMembers = [];
                for (let i = 0; i < object.friendMembers.length; ++i) {
                    if (typeof object.friendMembers[i] !== "object")
                        throw TypeError(".immessage.FriendMembersReq.friendMembers: object expected");
                    message.friendMembers[i] = $root.immessage.FriendMember.fromObject(object.friendMembers[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a FriendMembersReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.FriendMembersReq
         * @static
         * @param {immessage.FriendMembersReq} message FriendMembersReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FriendMembersReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.friendMembers = [];
            if (message.friendMembers && message.friendMembers.length) {
                object.friendMembers = [];
                for (let j = 0; j < message.friendMembers.length; ++j)
                    object.friendMembers[j] = $root.immessage.FriendMember.toObject(message.friendMembers[j], options);
            }
            return object;
        };

        /**
         * Converts this FriendMembersReq to JSON.
         * @function toJSON
         * @memberof immessage.FriendMembersReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FriendMembersReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FriendMembersReq
         * @function getTypeUrl
         * @memberof immessage.FriendMembersReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FriendMembersReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.FriendMembersReq";
        };

        return FriendMembersReq;
    })();

    immessage.QryFriendsReq = (function() {

        /**
         * Properties of a QryFriendsReq.
         * @memberof immessage
         * @interface IQryFriendsReq
         * @property {number|Long|null} [limit] QryFriendsReq limit
         * @property {string|null} [offset] QryFriendsReq offset
         */

        /**
         * Constructs a new QryFriendsReq.
         * @memberof immessage
         * @classdesc Represents a QryFriendsReq.
         * @implements IQryFriendsReq
         * @constructor
         * @param {immessage.IQryFriendsReq=} [properties] Properties to set
         */
        function QryFriendsReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryFriendsReq limit.
         * @member {number|Long} limit
         * @memberof immessage.QryFriendsReq
         * @instance
         */
        QryFriendsReq.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QryFriendsReq offset.
         * @member {string} offset
         * @memberof immessage.QryFriendsReq
         * @instance
         */
        QryFriendsReq.prototype.offset = "";

        /**
         * Creates a new QryFriendsReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryFriendsReq
         * @static
         * @param {immessage.IQryFriendsReq=} [properties] Properties to set
         * @returns {immessage.QryFriendsReq} QryFriendsReq instance
         */
        QryFriendsReq.create = function create(properties) {
            return new QryFriendsReq(properties);
        };

        /**
         * Encodes the specified QryFriendsReq message. Does not implicitly {@link immessage.QryFriendsReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryFriendsReq
         * @static
         * @param {immessage.IQryFriendsReq} message QryFriendsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryFriendsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.limit);
            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.offset);
            return writer;
        };

        /**
         * Encodes the specified QryFriendsReq message, length delimited. Does not implicitly {@link immessage.QryFriendsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryFriendsReq
         * @static
         * @param {immessage.IQryFriendsReq} message QryFriendsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryFriendsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryFriendsReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryFriendsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryFriendsReq} QryFriendsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryFriendsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryFriendsReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.limit = reader.int64();
                        break;
                    }
                case 2: {
                        message.offset = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryFriendsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryFriendsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryFriendsReq} QryFriendsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryFriendsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryFriendsReq message.
         * @function verify
         * @memberof immessage.QryFriendsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryFriendsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                    return "limit: integer|Long expected";
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isString(message.offset))
                    return "offset: string expected";
            return null;
        };

        /**
         * Creates a QryFriendsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryFriendsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryFriendsReq} QryFriendsReq
         */
        QryFriendsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryFriendsReq)
                return object;
            let message = new $root.immessage.QryFriendsReq();
            if (object.limit != null)
                if ($util.Long)
                    (message.limit = $util.Long.fromValue(object.limit)).unsigned = false;
                else if (typeof object.limit === "string")
                    message.limit = parseInt(object.limit, 10);
                else if (typeof object.limit === "number")
                    message.limit = object.limit;
                else if (typeof object.limit === "object")
                    message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber();
            if (object.offset != null)
                message.offset = String(object.offset);
            return message;
        };

        /**
         * Creates a plain object from a QryFriendsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryFriendsReq
         * @static
         * @param {immessage.QryFriendsReq} message QryFriendsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryFriendsReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.limit = options.longs === String ? "0" : 0;
                object.offset = "";
            }
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (typeof message.limit === "number")
                    object.limit = options.longs === String ? String(message.limit) : message.limit;
                else
                    object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber() : message.limit;
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            return object;
        };

        /**
         * Converts this QryFriendsReq to JSON.
         * @function toJSON
         * @memberof immessage.QryFriendsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryFriendsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryFriendsReq
         * @function getTypeUrl
         * @memberof immessage.QryFriendsReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryFriendsReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryFriendsReq";
        };

        return QryFriendsReq;
    })();

    immessage.QryFriendsWithPageReq = (function() {

        /**
         * Properties of a QryFriendsWithPageReq.
         * @memberof immessage
         * @interface IQryFriendsWithPageReq
         * @property {number|Long|null} [page] QryFriendsWithPageReq page
         * @property {number|Long|null} [size] QryFriendsWithPageReq size
         * @property {string|null} [orderTag] QryFriendsWithPageReq orderTag
         */

        /**
         * Constructs a new QryFriendsWithPageReq.
         * @memberof immessage
         * @classdesc Represents a QryFriendsWithPageReq.
         * @implements IQryFriendsWithPageReq
         * @constructor
         * @param {immessage.IQryFriendsWithPageReq=} [properties] Properties to set
         */
        function QryFriendsWithPageReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryFriendsWithPageReq page.
         * @member {number|Long} page
         * @memberof immessage.QryFriendsWithPageReq
         * @instance
         */
        QryFriendsWithPageReq.prototype.page = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QryFriendsWithPageReq size.
         * @member {number|Long} size
         * @memberof immessage.QryFriendsWithPageReq
         * @instance
         */
        QryFriendsWithPageReq.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QryFriendsWithPageReq orderTag.
         * @member {string} orderTag
         * @memberof immessage.QryFriendsWithPageReq
         * @instance
         */
        QryFriendsWithPageReq.prototype.orderTag = "";

        /**
         * Creates a new QryFriendsWithPageReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryFriendsWithPageReq
         * @static
         * @param {immessage.IQryFriendsWithPageReq=} [properties] Properties to set
         * @returns {immessage.QryFriendsWithPageReq} QryFriendsWithPageReq instance
         */
        QryFriendsWithPageReq.create = function create(properties) {
            return new QryFriendsWithPageReq(properties);
        };

        /**
         * Encodes the specified QryFriendsWithPageReq message. Does not implicitly {@link immessage.QryFriendsWithPageReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryFriendsWithPageReq
         * @static
         * @param {immessage.IQryFriendsWithPageReq} message QryFriendsWithPageReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryFriendsWithPageReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.page != null && Object.hasOwnProperty.call(message, "page"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.page);
            if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.size);
            if (message.orderTag != null && Object.hasOwnProperty.call(message, "orderTag"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.orderTag);
            return writer;
        };

        /**
         * Encodes the specified QryFriendsWithPageReq message, length delimited. Does not implicitly {@link immessage.QryFriendsWithPageReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryFriendsWithPageReq
         * @static
         * @param {immessage.IQryFriendsWithPageReq} message QryFriendsWithPageReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryFriendsWithPageReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryFriendsWithPageReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryFriendsWithPageReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryFriendsWithPageReq} QryFriendsWithPageReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryFriendsWithPageReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryFriendsWithPageReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.page = reader.int64();
                        break;
                    }
                case 2: {
                        message.size = reader.int64();
                        break;
                    }
                case 3: {
                        message.orderTag = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryFriendsWithPageReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryFriendsWithPageReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryFriendsWithPageReq} QryFriendsWithPageReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryFriendsWithPageReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryFriendsWithPageReq message.
         * @function verify
         * @memberof immessage.QryFriendsWithPageReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryFriendsWithPageReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.page != null && message.hasOwnProperty("page"))
                if (!$util.isInteger(message.page) && !(message.page && $util.isInteger(message.page.low) && $util.isInteger(message.page.high)))
                    return "page: integer|Long expected";
            if (message.size != null && message.hasOwnProperty("size"))
                if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                    return "size: integer|Long expected";
            if (message.orderTag != null && message.hasOwnProperty("orderTag"))
                if (!$util.isString(message.orderTag))
                    return "orderTag: string expected";
            return null;
        };

        /**
         * Creates a QryFriendsWithPageReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryFriendsWithPageReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryFriendsWithPageReq} QryFriendsWithPageReq
         */
        QryFriendsWithPageReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryFriendsWithPageReq)
                return object;
            let message = new $root.immessage.QryFriendsWithPageReq();
            if (object.page != null)
                if ($util.Long)
                    (message.page = $util.Long.fromValue(object.page)).unsigned = false;
                else if (typeof object.page === "string")
                    message.page = parseInt(object.page, 10);
                else if (typeof object.page === "number")
                    message.page = object.page;
                else if (typeof object.page === "object")
                    message.page = new $util.LongBits(object.page.low >>> 0, object.page.high >>> 0).toNumber();
            if (object.size != null)
                if ($util.Long)
                    (message.size = $util.Long.fromValue(object.size)).unsigned = false;
                else if (typeof object.size === "string")
                    message.size = parseInt(object.size, 10);
                else if (typeof object.size === "number")
                    message.size = object.size;
                else if (typeof object.size === "object")
                    message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber();
            if (object.orderTag != null)
                message.orderTag = String(object.orderTag);
            return message;
        };

        /**
         * Creates a plain object from a QryFriendsWithPageReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryFriendsWithPageReq
         * @static
         * @param {immessage.QryFriendsWithPageReq} message QryFriendsWithPageReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryFriendsWithPageReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.page = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.page = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.size = options.longs === String ? "0" : 0;
                object.orderTag = "";
            }
            if (message.page != null && message.hasOwnProperty("page"))
                if (typeof message.page === "number")
                    object.page = options.longs === String ? String(message.page) : message.page;
                else
                    object.page = options.longs === String ? $util.Long.prototype.toString.call(message.page) : options.longs === Number ? new $util.LongBits(message.page.low >>> 0, message.page.high >>> 0).toNumber() : message.page;
            if (message.size != null && message.hasOwnProperty("size"))
                if (typeof message.size === "number")
                    object.size = options.longs === String ? String(message.size) : message.size;
                else
                    object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber() : message.size;
            if (message.orderTag != null && message.hasOwnProperty("orderTag"))
                object.orderTag = message.orderTag;
            return object;
        };

        /**
         * Converts this QryFriendsWithPageReq to JSON.
         * @function toJSON
         * @memberof immessage.QryFriendsWithPageReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryFriendsWithPageReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryFriendsWithPageReq
         * @function getTypeUrl
         * @memberof immessage.QryFriendsWithPageReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryFriendsWithPageReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryFriendsWithPageReq";
        };

        return QryFriendsWithPageReq;
    })();

    immessage.QryFriendsResp = (function() {

        /**
         * Properties of a QryFriendsResp.
         * @memberof immessage
         * @interface IQryFriendsResp
         * @property {Array.<immessage.IFriendMember>|null} [items] QryFriendsResp items
         * @property {string|null} [offset] QryFriendsResp offset
         */

        /**
         * Constructs a new QryFriendsResp.
         * @memberof immessage
         * @classdesc Represents a QryFriendsResp.
         * @implements IQryFriendsResp
         * @constructor
         * @param {immessage.IQryFriendsResp=} [properties] Properties to set
         */
        function QryFriendsResp(properties) {
            this.items = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryFriendsResp items.
         * @member {Array.<immessage.IFriendMember>} items
         * @memberof immessage.QryFriendsResp
         * @instance
         */
        QryFriendsResp.prototype.items = $util.emptyArray;

        /**
         * QryFriendsResp offset.
         * @member {string} offset
         * @memberof immessage.QryFriendsResp
         * @instance
         */
        QryFriendsResp.prototype.offset = "";

        /**
         * Creates a new QryFriendsResp instance using the specified properties.
         * @function create
         * @memberof immessage.QryFriendsResp
         * @static
         * @param {immessage.IQryFriendsResp=} [properties] Properties to set
         * @returns {immessage.QryFriendsResp} QryFriendsResp instance
         */
        QryFriendsResp.create = function create(properties) {
            return new QryFriendsResp(properties);
        };

        /**
         * Encodes the specified QryFriendsResp message. Does not implicitly {@link immessage.QryFriendsResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryFriendsResp
         * @static
         * @param {immessage.IQryFriendsResp} message QryFriendsResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryFriendsResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (let i = 0; i < message.items.length; ++i)
                    $root.immessage.FriendMember.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.offset);
            return writer;
        };

        /**
         * Encodes the specified QryFriendsResp message, length delimited. Does not implicitly {@link immessage.QryFriendsResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryFriendsResp
         * @static
         * @param {immessage.IQryFriendsResp} message QryFriendsResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryFriendsResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryFriendsResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryFriendsResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryFriendsResp} QryFriendsResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryFriendsResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryFriendsResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.immessage.FriendMember.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.offset = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryFriendsResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryFriendsResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryFriendsResp} QryFriendsResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryFriendsResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryFriendsResp message.
         * @function verify
         * @memberof immessage.QryFriendsResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryFriendsResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (let i = 0; i < message.items.length; ++i) {
                    let error = $root.immessage.FriendMember.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isString(message.offset))
                    return "offset: string expected";
            return null;
        };

        /**
         * Creates a QryFriendsResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryFriendsResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryFriendsResp} QryFriendsResp
         */
        QryFriendsResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryFriendsResp)
                return object;
            let message = new $root.immessage.QryFriendsResp();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".immessage.QryFriendsResp.items: array expected");
                message.items = [];
                for (let i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".immessage.QryFriendsResp.items: object expected");
                    message.items[i] = $root.immessage.FriendMember.fromObject(object.items[i]);
                }
            }
            if (object.offset != null)
                message.offset = String(object.offset);
            return message;
        };

        /**
         * Creates a plain object from a QryFriendsResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryFriendsResp
         * @static
         * @param {immessage.QryFriendsResp} message QryFriendsResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryFriendsResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                object.offset = "";
            if (message.items && message.items.length) {
                object.items = [];
                for (let j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.immessage.FriendMember.toObject(message.items[j], options);
            }
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            return object;
        };

        /**
         * Converts this QryFriendsResp to JSON.
         * @function toJSON
         * @memberof immessage.QryFriendsResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryFriendsResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryFriendsResp
         * @function getTypeUrl
         * @memberof immessage.QryFriendsResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryFriendsResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryFriendsResp";
        };

        return QryFriendsResp;
    })();

    immessage.FriendMember = (function() {

        /**
         * Properties of a FriendMember.
         * @memberof immessage
         * @interface IFriendMember
         * @property {string|null} [friendId] FriendMember friendId
         * @property {string|null} [orderTag] FriendMember orderTag
         */

        /**
         * Constructs a new FriendMember.
         * @memberof immessage
         * @classdesc Represents a FriendMember.
         * @implements IFriendMember
         * @constructor
         * @param {immessage.IFriendMember=} [properties] Properties to set
         */
        function FriendMember(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendMember friendId.
         * @member {string} friendId
         * @memberof immessage.FriendMember
         * @instance
         */
        FriendMember.prototype.friendId = "";

        /**
         * FriendMember orderTag.
         * @member {string} orderTag
         * @memberof immessage.FriendMember
         * @instance
         */
        FriendMember.prototype.orderTag = "";

        /**
         * Creates a new FriendMember instance using the specified properties.
         * @function create
         * @memberof immessage.FriendMember
         * @static
         * @param {immessage.IFriendMember=} [properties] Properties to set
         * @returns {immessage.FriendMember} FriendMember instance
         */
        FriendMember.create = function create(properties) {
            return new FriendMember(properties);
        };

        /**
         * Encodes the specified FriendMember message. Does not implicitly {@link immessage.FriendMember.verify|verify} messages.
         * @function encode
         * @memberof immessage.FriendMember
         * @static
         * @param {immessage.IFriendMember} message FriendMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendMember.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.friendId != null && Object.hasOwnProperty.call(message, "friendId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.friendId);
            if (message.orderTag != null && Object.hasOwnProperty.call(message, "orderTag"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.orderTag);
            return writer;
        };

        /**
         * Encodes the specified FriendMember message, length delimited. Does not implicitly {@link immessage.FriendMember.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.FriendMember
         * @static
         * @param {immessage.IFriendMember} message FriendMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendMember.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FriendMember message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.FriendMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.FriendMember} FriendMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendMember.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.FriendMember();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.friendId = reader.string();
                        break;
                    }
                case 2: {
                        message.orderTag = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendMember message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.FriendMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.FriendMember} FriendMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendMember.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FriendMember message.
         * @function verify
         * @memberof immessage.FriendMember
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FriendMember.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.friendId != null && message.hasOwnProperty("friendId"))
                if (!$util.isString(message.friendId))
                    return "friendId: string expected";
            if (message.orderTag != null && message.hasOwnProperty("orderTag"))
                if (!$util.isString(message.orderTag))
                    return "orderTag: string expected";
            return null;
        };

        /**
         * Creates a FriendMember message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.FriendMember
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.FriendMember} FriendMember
         */
        FriendMember.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.FriendMember)
                return object;
            let message = new $root.immessage.FriendMember();
            if (object.friendId != null)
                message.friendId = String(object.friendId);
            if (object.orderTag != null)
                message.orderTag = String(object.orderTag);
            return message;
        };

        /**
         * Creates a plain object from a FriendMember message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.FriendMember
         * @static
         * @param {immessage.FriendMember} message FriendMember
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FriendMember.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.friendId = "";
                object.orderTag = "";
            }
            if (message.friendId != null && message.hasOwnProperty("friendId"))
                object.friendId = message.friendId;
            if (message.orderTag != null && message.hasOwnProperty("orderTag"))
                object.orderTag = message.orderTag;
            return object;
        };

        /**
         * Converts this FriendMember to JSON.
         * @function toJSON
         * @memberof immessage.FriendMember
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FriendMember.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FriendMember
         * @function getTypeUrl
         * @memberof immessage.FriendMember
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FriendMember.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.FriendMember";
        };

        return FriendMember;
    })();

    immessage.CheckFriendsReq = (function() {

        /**
         * Properties of a CheckFriendsReq.
         * @memberof immessage
         * @interface ICheckFriendsReq
         * @property {Array.<string>|null} [friendIds] CheckFriendsReq friendIds
         */

        /**
         * Constructs a new CheckFriendsReq.
         * @memberof immessage
         * @classdesc Represents a CheckFriendsReq.
         * @implements ICheckFriendsReq
         * @constructor
         * @param {immessage.ICheckFriendsReq=} [properties] Properties to set
         */
        function CheckFriendsReq(properties) {
            this.friendIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CheckFriendsReq friendIds.
         * @member {Array.<string>} friendIds
         * @memberof immessage.CheckFriendsReq
         * @instance
         */
        CheckFriendsReq.prototype.friendIds = $util.emptyArray;

        /**
         * Creates a new CheckFriendsReq instance using the specified properties.
         * @function create
         * @memberof immessage.CheckFriendsReq
         * @static
         * @param {immessage.ICheckFriendsReq=} [properties] Properties to set
         * @returns {immessage.CheckFriendsReq} CheckFriendsReq instance
         */
        CheckFriendsReq.create = function create(properties) {
            return new CheckFriendsReq(properties);
        };

        /**
         * Encodes the specified CheckFriendsReq message. Does not implicitly {@link immessage.CheckFriendsReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.CheckFriendsReq
         * @static
         * @param {immessage.ICheckFriendsReq} message CheckFriendsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckFriendsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.friendIds != null && message.friendIds.length)
                for (let i = 0; i < message.friendIds.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.friendIds[i]);
            return writer;
        };

        /**
         * Encodes the specified CheckFriendsReq message, length delimited. Does not implicitly {@link immessage.CheckFriendsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.CheckFriendsReq
         * @static
         * @param {immessage.ICheckFriendsReq} message CheckFriendsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckFriendsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CheckFriendsReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.CheckFriendsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.CheckFriendsReq} CheckFriendsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckFriendsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.CheckFriendsReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.friendIds && message.friendIds.length))
                            message.friendIds = [];
                        message.friendIds.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CheckFriendsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.CheckFriendsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.CheckFriendsReq} CheckFriendsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckFriendsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CheckFriendsReq message.
         * @function verify
         * @memberof immessage.CheckFriendsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CheckFriendsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.friendIds != null && message.hasOwnProperty("friendIds")) {
                if (!Array.isArray(message.friendIds))
                    return "friendIds: array expected";
                for (let i = 0; i < message.friendIds.length; ++i)
                    if (!$util.isString(message.friendIds[i]))
                        return "friendIds: string[] expected";
            }
            return null;
        };

        /**
         * Creates a CheckFriendsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.CheckFriendsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.CheckFriendsReq} CheckFriendsReq
         */
        CheckFriendsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.CheckFriendsReq)
                return object;
            let message = new $root.immessage.CheckFriendsReq();
            if (object.friendIds) {
                if (!Array.isArray(object.friendIds))
                    throw TypeError(".immessage.CheckFriendsReq.friendIds: array expected");
                message.friendIds = [];
                for (let i = 0; i < object.friendIds.length; ++i)
                    message.friendIds[i] = String(object.friendIds[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a CheckFriendsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.CheckFriendsReq
         * @static
         * @param {immessage.CheckFriendsReq} message CheckFriendsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CheckFriendsReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.friendIds = [];
            if (message.friendIds && message.friendIds.length) {
                object.friendIds = [];
                for (let j = 0; j < message.friendIds.length; ++j)
                    object.friendIds[j] = message.friendIds[j];
            }
            return object;
        };

        /**
         * Converts this CheckFriendsReq to JSON.
         * @function toJSON
         * @memberof immessage.CheckFriendsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CheckFriendsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CheckFriendsReq
         * @function getTypeUrl
         * @memberof immessage.CheckFriendsReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CheckFriendsReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.CheckFriendsReq";
        };

        return CheckFriendsReq;
    })();

    immessage.CheckFriendsResp = (function() {

        /**
         * Properties of a CheckFriendsResp.
         * @memberof immessage
         * @interface ICheckFriendsResp
         * @property {Object.<string,boolean>|null} [checkResults] CheckFriendsResp checkResults
         */

        /**
         * Constructs a new CheckFriendsResp.
         * @memberof immessage
         * @classdesc Represents a CheckFriendsResp.
         * @implements ICheckFriendsResp
         * @constructor
         * @param {immessage.ICheckFriendsResp=} [properties] Properties to set
         */
        function CheckFriendsResp(properties) {
            this.checkResults = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CheckFriendsResp checkResults.
         * @member {Object.<string,boolean>} checkResults
         * @memberof immessage.CheckFriendsResp
         * @instance
         */
        CheckFriendsResp.prototype.checkResults = $util.emptyObject;

        /**
         * Creates a new CheckFriendsResp instance using the specified properties.
         * @function create
         * @memberof immessage.CheckFriendsResp
         * @static
         * @param {immessage.ICheckFriendsResp=} [properties] Properties to set
         * @returns {immessage.CheckFriendsResp} CheckFriendsResp instance
         */
        CheckFriendsResp.create = function create(properties) {
            return new CheckFriendsResp(properties);
        };

        /**
         * Encodes the specified CheckFriendsResp message. Does not implicitly {@link immessage.CheckFriendsResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.CheckFriendsResp
         * @static
         * @param {immessage.ICheckFriendsResp} message CheckFriendsResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckFriendsResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.checkResults != null && Object.hasOwnProperty.call(message, "checkResults"))
                for (let keys = Object.keys(message.checkResults), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).bool(message.checkResults[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CheckFriendsResp message, length delimited. Does not implicitly {@link immessage.CheckFriendsResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.CheckFriendsResp
         * @static
         * @param {immessage.ICheckFriendsResp} message CheckFriendsResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckFriendsResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CheckFriendsResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.CheckFriendsResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.CheckFriendsResp} CheckFriendsResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckFriendsResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.CheckFriendsResp(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (message.checkResults === $util.emptyObject)
                            message.checkResults = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = false;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.bool();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.checkResults[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CheckFriendsResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.CheckFriendsResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.CheckFriendsResp} CheckFriendsResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckFriendsResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CheckFriendsResp message.
         * @function verify
         * @memberof immessage.CheckFriendsResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CheckFriendsResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.checkResults != null && message.hasOwnProperty("checkResults")) {
                if (!$util.isObject(message.checkResults))
                    return "checkResults: object expected";
                let key = Object.keys(message.checkResults);
                for (let i = 0; i < key.length; ++i)
                    if (typeof message.checkResults[key[i]] !== "boolean")
                        return "checkResults: boolean{k:string} expected";
            }
            return null;
        };

        /**
         * Creates a CheckFriendsResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.CheckFriendsResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.CheckFriendsResp} CheckFriendsResp
         */
        CheckFriendsResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.CheckFriendsResp)
                return object;
            let message = new $root.immessage.CheckFriendsResp();
            if (object.checkResults) {
                if (typeof object.checkResults !== "object")
                    throw TypeError(".immessage.CheckFriendsResp.checkResults: object expected");
                message.checkResults = {};
                for (let keys = Object.keys(object.checkResults), i = 0; i < keys.length; ++i)
                    message.checkResults[keys[i]] = Boolean(object.checkResults[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from a CheckFriendsResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.CheckFriendsResp
         * @static
         * @param {immessage.CheckFriendsResp} message CheckFriendsResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CheckFriendsResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.checkResults = {};
            let keys2;
            if (message.checkResults && (keys2 = Object.keys(message.checkResults)).length) {
                object.checkResults = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.checkResults[keys2[j]] = message.checkResults[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this CheckFriendsResp to JSON.
         * @function toJSON
         * @memberof immessage.CheckFriendsResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CheckFriendsResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CheckFriendsResp
         * @function getTypeUrl
         * @memberof immessage.CheckFriendsResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CheckFriendsResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.CheckFriendsResp";
        };

        return CheckFriendsResp;
    })();

    immessage.GroupInfo = (function() {

        /**
         * Properties of a GroupInfo.
         * @memberof immessage
         * @interface IGroupInfo
         * @property {string|null} [groupId] GroupInfo groupId
         * @property {string|null} [groupName] GroupInfo groupName
         * @property {string|null} [groupPortrait] GroupInfo groupPortrait
         * @property {number|null} [isMute] GroupInfo isMute
         * @property {Array.<immessage.IKvItem>|null} [extFields] GroupInfo extFields
         * @property {number|Long|null} [updatedTime] GroupInfo updatedTime
         * @property {Array.<immessage.IKvItem>|null} [settings] GroupInfo settings
         * @property {number|null} [memberCount] GroupInfo memberCount
         */

        /**
         * Constructs a new GroupInfo.
         * @memberof immessage
         * @classdesc Represents a GroupInfo.
         * @implements IGroupInfo
         * @constructor
         * @param {immessage.IGroupInfo=} [properties] Properties to set
         */
        function GroupInfo(properties) {
            this.extFields = [];
            this.settings = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupInfo groupId.
         * @member {string} groupId
         * @memberof immessage.GroupInfo
         * @instance
         */
        GroupInfo.prototype.groupId = "";

        /**
         * GroupInfo groupName.
         * @member {string} groupName
         * @memberof immessage.GroupInfo
         * @instance
         */
        GroupInfo.prototype.groupName = "";

        /**
         * GroupInfo groupPortrait.
         * @member {string} groupPortrait
         * @memberof immessage.GroupInfo
         * @instance
         */
        GroupInfo.prototype.groupPortrait = "";

        /**
         * GroupInfo isMute.
         * @member {number} isMute
         * @memberof immessage.GroupInfo
         * @instance
         */
        GroupInfo.prototype.isMute = 0;

        /**
         * GroupInfo extFields.
         * @member {Array.<immessage.IKvItem>} extFields
         * @memberof immessage.GroupInfo
         * @instance
         */
        GroupInfo.prototype.extFields = $util.emptyArray;

        /**
         * GroupInfo updatedTime.
         * @member {number|Long} updatedTime
         * @memberof immessage.GroupInfo
         * @instance
         */
        GroupInfo.prototype.updatedTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GroupInfo settings.
         * @member {Array.<immessage.IKvItem>} settings
         * @memberof immessage.GroupInfo
         * @instance
         */
        GroupInfo.prototype.settings = $util.emptyArray;

        /**
         * GroupInfo memberCount.
         * @member {number} memberCount
         * @memberof immessage.GroupInfo
         * @instance
         */
        GroupInfo.prototype.memberCount = 0;

        /**
         * Creates a new GroupInfo instance using the specified properties.
         * @function create
         * @memberof immessage.GroupInfo
         * @static
         * @param {immessage.IGroupInfo=} [properties] Properties to set
         * @returns {immessage.GroupInfo} GroupInfo instance
         */
        GroupInfo.create = function create(properties) {
            return new GroupInfo(properties);
        };

        /**
         * Encodes the specified GroupInfo message. Does not implicitly {@link immessage.GroupInfo.verify|verify} messages.
         * @function encode
         * @memberof immessage.GroupInfo
         * @static
         * @param {immessage.IGroupInfo} message GroupInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
            if (message.groupName != null && Object.hasOwnProperty.call(message, "groupName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.groupName);
            if (message.groupPortrait != null && Object.hasOwnProperty.call(message, "groupPortrait"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.groupPortrait);
            if (message.isMute != null && Object.hasOwnProperty.call(message, "isMute"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.isMute);
            if (message.extFields != null && message.extFields.length)
                for (let i = 0; i < message.extFields.length; ++i)
                    $root.immessage.KvItem.encode(message.extFields[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.updatedTime != null && Object.hasOwnProperty.call(message, "updatedTime"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.updatedTime);
            if (message.settings != null && message.settings.length)
                for (let i = 0; i < message.settings.length; ++i)
                    $root.immessage.KvItem.encode(message.settings[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.memberCount != null && Object.hasOwnProperty.call(message, "memberCount"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.memberCount);
            return writer;
        };

        /**
         * Encodes the specified GroupInfo message, length delimited. Does not implicitly {@link immessage.GroupInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.GroupInfo
         * @static
         * @param {immessage.IGroupInfo} message GroupInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupInfo message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.GroupInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.GroupInfo} GroupInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.GroupInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.groupId = reader.string();
                        break;
                    }
                case 2: {
                        message.groupName = reader.string();
                        break;
                    }
                case 3: {
                        message.groupPortrait = reader.string();
                        break;
                    }
                case 4: {
                        message.isMute = reader.int32();
                        break;
                    }
                case 5: {
                        if (!(message.extFields && message.extFields.length))
                            message.extFields = [];
                        message.extFields.push($root.immessage.KvItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        message.updatedTime = reader.int64();
                        break;
                    }
                case 7: {
                        if (!(message.settings && message.settings.length))
                            message.settings = [];
                        message.settings.push($root.immessage.KvItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 8: {
                        message.memberCount = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.GroupInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.GroupInfo} GroupInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupInfo message.
         * @function verify
         * @memberof immessage.GroupInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isString(message.groupId))
                    return "groupId: string expected";
            if (message.groupName != null && message.hasOwnProperty("groupName"))
                if (!$util.isString(message.groupName))
                    return "groupName: string expected";
            if (message.groupPortrait != null && message.hasOwnProperty("groupPortrait"))
                if (!$util.isString(message.groupPortrait))
                    return "groupPortrait: string expected";
            if (message.isMute != null && message.hasOwnProperty("isMute"))
                if (!$util.isInteger(message.isMute))
                    return "isMute: integer expected";
            if (message.extFields != null && message.hasOwnProperty("extFields")) {
                if (!Array.isArray(message.extFields))
                    return "extFields: array expected";
                for (let i = 0; i < message.extFields.length; ++i) {
                    let error = $root.immessage.KvItem.verify(message.extFields[i]);
                    if (error)
                        return "extFields." + error;
                }
            }
            if (message.updatedTime != null && message.hasOwnProperty("updatedTime"))
                if (!$util.isInteger(message.updatedTime) && !(message.updatedTime && $util.isInteger(message.updatedTime.low) && $util.isInteger(message.updatedTime.high)))
                    return "updatedTime: integer|Long expected";
            if (message.settings != null && message.hasOwnProperty("settings")) {
                if (!Array.isArray(message.settings))
                    return "settings: array expected";
                for (let i = 0; i < message.settings.length; ++i) {
                    let error = $root.immessage.KvItem.verify(message.settings[i]);
                    if (error)
                        return "settings." + error;
                }
            }
            if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                if (!$util.isInteger(message.memberCount))
                    return "memberCount: integer expected";
            return null;
        };

        /**
         * Creates a GroupInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.GroupInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.GroupInfo} GroupInfo
         */
        GroupInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.GroupInfo)
                return object;
            let message = new $root.immessage.GroupInfo();
            if (object.groupId != null)
                message.groupId = String(object.groupId);
            if (object.groupName != null)
                message.groupName = String(object.groupName);
            if (object.groupPortrait != null)
                message.groupPortrait = String(object.groupPortrait);
            if (object.isMute != null)
                message.isMute = object.isMute | 0;
            if (object.extFields) {
                if (!Array.isArray(object.extFields))
                    throw TypeError(".immessage.GroupInfo.extFields: array expected");
                message.extFields = [];
                for (let i = 0; i < object.extFields.length; ++i) {
                    if (typeof object.extFields[i] !== "object")
                        throw TypeError(".immessage.GroupInfo.extFields: object expected");
                    message.extFields[i] = $root.immessage.KvItem.fromObject(object.extFields[i]);
                }
            }
            if (object.updatedTime != null)
                if ($util.Long)
                    (message.updatedTime = $util.Long.fromValue(object.updatedTime)).unsigned = false;
                else if (typeof object.updatedTime === "string")
                    message.updatedTime = parseInt(object.updatedTime, 10);
                else if (typeof object.updatedTime === "number")
                    message.updatedTime = object.updatedTime;
                else if (typeof object.updatedTime === "object")
                    message.updatedTime = new $util.LongBits(object.updatedTime.low >>> 0, object.updatedTime.high >>> 0).toNumber();
            if (object.settings) {
                if (!Array.isArray(object.settings))
                    throw TypeError(".immessage.GroupInfo.settings: array expected");
                message.settings = [];
                for (let i = 0; i < object.settings.length; ++i) {
                    if (typeof object.settings[i] !== "object")
                        throw TypeError(".immessage.GroupInfo.settings: object expected");
                    message.settings[i] = $root.immessage.KvItem.fromObject(object.settings[i]);
                }
            }
            if (object.memberCount != null)
                message.memberCount = object.memberCount | 0;
            return message;
        };

        /**
         * Creates a plain object from a GroupInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.GroupInfo
         * @static
         * @param {immessage.GroupInfo} message GroupInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.extFields = [];
                object.settings = [];
            }
            if (options.defaults) {
                object.groupId = "";
                object.groupName = "";
                object.groupPortrait = "";
                object.isMute = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.updatedTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.updatedTime = options.longs === String ? "0" : 0;
                object.memberCount = 0;
            }
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = message.groupId;
            if (message.groupName != null && message.hasOwnProperty("groupName"))
                object.groupName = message.groupName;
            if (message.groupPortrait != null && message.hasOwnProperty("groupPortrait"))
                object.groupPortrait = message.groupPortrait;
            if (message.isMute != null && message.hasOwnProperty("isMute"))
                object.isMute = message.isMute;
            if (message.extFields && message.extFields.length) {
                object.extFields = [];
                for (let j = 0; j < message.extFields.length; ++j)
                    object.extFields[j] = $root.immessage.KvItem.toObject(message.extFields[j], options);
            }
            if (message.updatedTime != null && message.hasOwnProperty("updatedTime"))
                if (typeof message.updatedTime === "number")
                    object.updatedTime = options.longs === String ? String(message.updatedTime) : message.updatedTime;
                else
                    object.updatedTime = options.longs === String ? $util.Long.prototype.toString.call(message.updatedTime) : options.longs === Number ? new $util.LongBits(message.updatedTime.low >>> 0, message.updatedTime.high >>> 0).toNumber() : message.updatedTime;
            if (message.settings && message.settings.length) {
                object.settings = [];
                for (let j = 0; j < message.settings.length; ++j)
                    object.settings[j] = $root.immessage.KvItem.toObject(message.settings[j], options);
            }
            if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                object.memberCount = message.memberCount;
            return object;
        };

        /**
         * Converts this GroupInfo to JSON.
         * @function toJSON
         * @memberof immessage.GroupInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GroupInfo
         * @function getTypeUrl
         * @memberof immessage.GroupInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GroupInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.GroupInfo";
        };

        return GroupInfo;
    })();

    immessage.GrpMemberInfo = (function() {

        /**
         * Properties of a GrpMemberInfo.
         * @memberof immessage
         * @interface IGrpMemberInfo
         * @property {string|null} [grpDisplayName] GrpMemberInfo grpDisplayName
         * @property {Array.<immessage.IKvItem>|null} [extFields] GrpMemberInfo extFields
         * @property {number|Long|null} [updatedTime] GrpMemberInfo updatedTime
         */

        /**
         * Constructs a new GrpMemberInfo.
         * @memberof immessage
         * @classdesc Represents a GrpMemberInfo.
         * @implements IGrpMemberInfo
         * @constructor
         * @param {immessage.IGrpMemberInfo=} [properties] Properties to set
         */
        function GrpMemberInfo(properties) {
            this.extFields = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GrpMemberInfo grpDisplayName.
         * @member {string} grpDisplayName
         * @memberof immessage.GrpMemberInfo
         * @instance
         */
        GrpMemberInfo.prototype.grpDisplayName = "";

        /**
         * GrpMemberInfo extFields.
         * @member {Array.<immessage.IKvItem>} extFields
         * @memberof immessage.GrpMemberInfo
         * @instance
         */
        GrpMemberInfo.prototype.extFields = $util.emptyArray;

        /**
         * GrpMemberInfo updatedTime.
         * @member {number|Long} updatedTime
         * @memberof immessage.GrpMemberInfo
         * @instance
         */
        GrpMemberInfo.prototype.updatedTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GrpMemberInfo instance using the specified properties.
         * @function create
         * @memberof immessage.GrpMemberInfo
         * @static
         * @param {immessage.IGrpMemberInfo=} [properties] Properties to set
         * @returns {immessage.GrpMemberInfo} GrpMemberInfo instance
         */
        GrpMemberInfo.create = function create(properties) {
            return new GrpMemberInfo(properties);
        };

        /**
         * Encodes the specified GrpMemberInfo message. Does not implicitly {@link immessage.GrpMemberInfo.verify|verify} messages.
         * @function encode
         * @memberof immessage.GrpMemberInfo
         * @static
         * @param {immessage.IGrpMemberInfo} message GrpMemberInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GrpMemberInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.grpDisplayName != null && Object.hasOwnProperty.call(message, "grpDisplayName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.grpDisplayName);
            if (message.extFields != null && message.extFields.length)
                for (let i = 0; i < message.extFields.length; ++i)
                    $root.immessage.KvItem.encode(message.extFields[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.updatedTime != null && Object.hasOwnProperty.call(message, "updatedTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.updatedTime);
            return writer;
        };

        /**
         * Encodes the specified GrpMemberInfo message, length delimited. Does not implicitly {@link immessage.GrpMemberInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.GrpMemberInfo
         * @static
         * @param {immessage.IGrpMemberInfo} message GrpMemberInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GrpMemberInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GrpMemberInfo message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.GrpMemberInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.GrpMemberInfo} GrpMemberInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GrpMemberInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.GrpMemberInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.grpDisplayName = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.extFields && message.extFields.length))
                            message.extFields = [];
                        message.extFields.push($root.immessage.KvItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.updatedTime = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GrpMemberInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.GrpMemberInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.GrpMemberInfo} GrpMemberInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GrpMemberInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GrpMemberInfo message.
         * @function verify
         * @memberof immessage.GrpMemberInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GrpMemberInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.grpDisplayName != null && message.hasOwnProperty("grpDisplayName"))
                if (!$util.isString(message.grpDisplayName))
                    return "grpDisplayName: string expected";
            if (message.extFields != null && message.hasOwnProperty("extFields")) {
                if (!Array.isArray(message.extFields))
                    return "extFields: array expected";
                for (let i = 0; i < message.extFields.length; ++i) {
                    let error = $root.immessage.KvItem.verify(message.extFields[i]);
                    if (error)
                        return "extFields." + error;
                }
            }
            if (message.updatedTime != null && message.hasOwnProperty("updatedTime"))
                if (!$util.isInteger(message.updatedTime) && !(message.updatedTime && $util.isInteger(message.updatedTime.low) && $util.isInteger(message.updatedTime.high)))
                    return "updatedTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a GrpMemberInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.GrpMemberInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.GrpMemberInfo} GrpMemberInfo
         */
        GrpMemberInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.GrpMemberInfo)
                return object;
            let message = new $root.immessage.GrpMemberInfo();
            if (object.grpDisplayName != null)
                message.grpDisplayName = String(object.grpDisplayName);
            if (object.extFields) {
                if (!Array.isArray(object.extFields))
                    throw TypeError(".immessage.GrpMemberInfo.extFields: array expected");
                message.extFields = [];
                for (let i = 0; i < object.extFields.length; ++i) {
                    if (typeof object.extFields[i] !== "object")
                        throw TypeError(".immessage.GrpMemberInfo.extFields: object expected");
                    message.extFields[i] = $root.immessage.KvItem.fromObject(object.extFields[i]);
                }
            }
            if (object.updatedTime != null)
                if ($util.Long)
                    (message.updatedTime = $util.Long.fromValue(object.updatedTime)).unsigned = false;
                else if (typeof object.updatedTime === "string")
                    message.updatedTime = parseInt(object.updatedTime, 10);
                else if (typeof object.updatedTime === "number")
                    message.updatedTime = object.updatedTime;
                else if (typeof object.updatedTime === "object")
                    message.updatedTime = new $util.LongBits(object.updatedTime.low >>> 0, object.updatedTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a GrpMemberInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.GrpMemberInfo
         * @static
         * @param {immessage.GrpMemberInfo} message GrpMemberInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GrpMemberInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.extFields = [];
            if (options.defaults) {
                object.grpDisplayName = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.updatedTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.updatedTime = options.longs === String ? "0" : 0;
            }
            if (message.grpDisplayName != null && message.hasOwnProperty("grpDisplayName"))
                object.grpDisplayName = message.grpDisplayName;
            if (message.extFields && message.extFields.length) {
                object.extFields = [];
                for (let j = 0; j < message.extFields.length; ++j)
                    object.extFields[j] = $root.immessage.KvItem.toObject(message.extFields[j], options);
            }
            if (message.updatedTime != null && message.hasOwnProperty("updatedTime"))
                if (typeof message.updatedTime === "number")
                    object.updatedTime = options.longs === String ? String(message.updatedTime) : message.updatedTime;
                else
                    object.updatedTime = options.longs === String ? $util.Long.prototype.toString.call(message.updatedTime) : options.longs === Number ? new $util.LongBits(message.updatedTime.low >>> 0, message.updatedTime.high >>> 0).toNumber() : message.updatedTime;
            return object;
        };

        /**
         * Converts this GrpMemberInfo to JSON.
         * @function toJSON
         * @memberof immessage.GrpMemberInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GrpMemberInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GrpMemberInfo
         * @function getTypeUrl
         * @memberof immessage.GrpMemberInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GrpMemberInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.GrpMemberInfo";
        };

        return GrpMemberInfo;
    })();

    immessage.GroupMembersReq = (function() {

        /**
         * Properties of a GroupMembersReq.
         * @memberof immessage
         * @interface IGroupMembersReq
         * @property {string|null} [groupId] GroupMembersReq groupId
         * @property {string|null} [groupName] GroupMembersReq groupName
         * @property {string|null} [groupPortrait] GroupMembersReq groupPortrait
         * @property {Array.<string>|null} [memberIds] GroupMembersReq memberIds
         * @property {Array.<immessage.IKvItem>|null} [extFields] GroupMembersReq extFields
         * @property {Array.<immessage.IKvItem>|null} [settings] GroupMembersReq settings
         */

        /**
         * Constructs a new GroupMembersReq.
         * @memberof immessage
         * @classdesc Represents a GroupMembersReq.
         * @implements IGroupMembersReq
         * @constructor
         * @param {immessage.IGroupMembersReq=} [properties] Properties to set
         */
        function GroupMembersReq(properties) {
            this.memberIds = [];
            this.extFields = [];
            this.settings = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupMembersReq groupId.
         * @member {string} groupId
         * @memberof immessage.GroupMembersReq
         * @instance
         */
        GroupMembersReq.prototype.groupId = "";

        /**
         * GroupMembersReq groupName.
         * @member {string} groupName
         * @memberof immessage.GroupMembersReq
         * @instance
         */
        GroupMembersReq.prototype.groupName = "";

        /**
         * GroupMembersReq groupPortrait.
         * @member {string} groupPortrait
         * @memberof immessage.GroupMembersReq
         * @instance
         */
        GroupMembersReq.prototype.groupPortrait = "";

        /**
         * GroupMembersReq memberIds.
         * @member {Array.<string>} memberIds
         * @memberof immessage.GroupMembersReq
         * @instance
         */
        GroupMembersReq.prototype.memberIds = $util.emptyArray;

        /**
         * GroupMembersReq extFields.
         * @member {Array.<immessage.IKvItem>} extFields
         * @memberof immessage.GroupMembersReq
         * @instance
         */
        GroupMembersReq.prototype.extFields = $util.emptyArray;

        /**
         * GroupMembersReq settings.
         * @member {Array.<immessage.IKvItem>} settings
         * @memberof immessage.GroupMembersReq
         * @instance
         */
        GroupMembersReq.prototype.settings = $util.emptyArray;

        /**
         * Creates a new GroupMembersReq instance using the specified properties.
         * @function create
         * @memberof immessage.GroupMembersReq
         * @static
         * @param {immessage.IGroupMembersReq=} [properties] Properties to set
         * @returns {immessage.GroupMembersReq} GroupMembersReq instance
         */
        GroupMembersReq.create = function create(properties) {
            return new GroupMembersReq(properties);
        };

        /**
         * Encodes the specified GroupMembersReq message. Does not implicitly {@link immessage.GroupMembersReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.GroupMembersReq
         * @static
         * @param {immessage.IGroupMembersReq} message GroupMembersReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupMembersReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
            if (message.groupName != null && Object.hasOwnProperty.call(message, "groupName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.groupName);
            if (message.groupPortrait != null && Object.hasOwnProperty.call(message, "groupPortrait"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.groupPortrait);
            if (message.memberIds != null && message.memberIds.length)
                for (let i = 0; i < message.memberIds.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.memberIds[i]);
            if (message.extFields != null && message.extFields.length)
                for (let i = 0; i < message.extFields.length; ++i)
                    $root.immessage.KvItem.encode(message.extFields[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.settings != null && message.settings.length)
                for (let i = 0; i < message.settings.length; ++i)
                    $root.immessage.KvItem.encode(message.settings[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GroupMembersReq message, length delimited. Does not implicitly {@link immessage.GroupMembersReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.GroupMembersReq
         * @static
         * @param {immessage.IGroupMembersReq} message GroupMembersReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupMembersReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupMembersReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.GroupMembersReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.GroupMembersReq} GroupMembersReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMembersReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.GroupMembersReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.groupId = reader.string();
                        break;
                    }
                case 2: {
                        message.groupName = reader.string();
                        break;
                    }
                case 3: {
                        message.groupPortrait = reader.string();
                        break;
                    }
                case 4: {
                        if (!(message.memberIds && message.memberIds.length))
                            message.memberIds = [];
                        message.memberIds.push(reader.string());
                        break;
                    }
                case 5: {
                        if (!(message.extFields && message.extFields.length))
                            message.extFields = [];
                        message.extFields.push($root.immessage.KvItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        if (!(message.settings && message.settings.length))
                            message.settings = [];
                        message.settings.push($root.immessage.KvItem.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupMembersReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.GroupMembersReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.GroupMembersReq} GroupMembersReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMembersReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupMembersReq message.
         * @function verify
         * @memberof immessage.GroupMembersReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupMembersReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isString(message.groupId))
                    return "groupId: string expected";
            if (message.groupName != null && message.hasOwnProperty("groupName"))
                if (!$util.isString(message.groupName))
                    return "groupName: string expected";
            if (message.groupPortrait != null && message.hasOwnProperty("groupPortrait"))
                if (!$util.isString(message.groupPortrait))
                    return "groupPortrait: string expected";
            if (message.memberIds != null && message.hasOwnProperty("memberIds")) {
                if (!Array.isArray(message.memberIds))
                    return "memberIds: array expected";
                for (let i = 0; i < message.memberIds.length; ++i)
                    if (!$util.isString(message.memberIds[i]))
                        return "memberIds: string[] expected";
            }
            if (message.extFields != null && message.hasOwnProperty("extFields")) {
                if (!Array.isArray(message.extFields))
                    return "extFields: array expected";
                for (let i = 0; i < message.extFields.length; ++i) {
                    let error = $root.immessage.KvItem.verify(message.extFields[i]);
                    if (error)
                        return "extFields." + error;
                }
            }
            if (message.settings != null && message.hasOwnProperty("settings")) {
                if (!Array.isArray(message.settings))
                    return "settings: array expected";
                for (let i = 0; i < message.settings.length; ++i) {
                    let error = $root.immessage.KvItem.verify(message.settings[i]);
                    if (error)
                        return "settings." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GroupMembersReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.GroupMembersReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.GroupMembersReq} GroupMembersReq
         */
        GroupMembersReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.GroupMembersReq)
                return object;
            let message = new $root.immessage.GroupMembersReq();
            if (object.groupId != null)
                message.groupId = String(object.groupId);
            if (object.groupName != null)
                message.groupName = String(object.groupName);
            if (object.groupPortrait != null)
                message.groupPortrait = String(object.groupPortrait);
            if (object.memberIds) {
                if (!Array.isArray(object.memberIds))
                    throw TypeError(".immessage.GroupMembersReq.memberIds: array expected");
                message.memberIds = [];
                for (let i = 0; i < object.memberIds.length; ++i)
                    message.memberIds[i] = String(object.memberIds[i]);
            }
            if (object.extFields) {
                if (!Array.isArray(object.extFields))
                    throw TypeError(".immessage.GroupMembersReq.extFields: array expected");
                message.extFields = [];
                for (let i = 0; i < object.extFields.length; ++i) {
                    if (typeof object.extFields[i] !== "object")
                        throw TypeError(".immessage.GroupMembersReq.extFields: object expected");
                    message.extFields[i] = $root.immessage.KvItem.fromObject(object.extFields[i]);
                }
            }
            if (object.settings) {
                if (!Array.isArray(object.settings))
                    throw TypeError(".immessage.GroupMembersReq.settings: array expected");
                message.settings = [];
                for (let i = 0; i < object.settings.length; ++i) {
                    if (typeof object.settings[i] !== "object")
                        throw TypeError(".immessage.GroupMembersReq.settings: object expected");
                    message.settings[i] = $root.immessage.KvItem.fromObject(object.settings[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupMembersReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.GroupMembersReq
         * @static
         * @param {immessage.GroupMembersReq} message GroupMembersReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupMembersReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.memberIds = [];
                object.extFields = [];
                object.settings = [];
            }
            if (options.defaults) {
                object.groupId = "";
                object.groupName = "";
                object.groupPortrait = "";
            }
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = message.groupId;
            if (message.groupName != null && message.hasOwnProperty("groupName"))
                object.groupName = message.groupName;
            if (message.groupPortrait != null && message.hasOwnProperty("groupPortrait"))
                object.groupPortrait = message.groupPortrait;
            if (message.memberIds && message.memberIds.length) {
                object.memberIds = [];
                for (let j = 0; j < message.memberIds.length; ++j)
                    object.memberIds[j] = message.memberIds[j];
            }
            if (message.extFields && message.extFields.length) {
                object.extFields = [];
                for (let j = 0; j < message.extFields.length; ++j)
                    object.extFields[j] = $root.immessage.KvItem.toObject(message.extFields[j], options);
            }
            if (message.settings && message.settings.length) {
                object.settings = [];
                for (let j = 0; j < message.settings.length; ++j)
                    object.settings[j] = $root.immessage.KvItem.toObject(message.settings[j], options);
            }
            return object;
        };

        /**
         * Converts this GroupMembersReq to JSON.
         * @function toJSON
         * @memberof immessage.GroupMembersReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupMembersReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GroupMembersReq
         * @function getTypeUrl
         * @memberof immessage.GroupMembersReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GroupMembersReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.GroupMembersReq";
        };

        return GroupMembersReq;
    })();

    immessage.GroupMuteReq = (function() {

        /**
         * Properties of a GroupMuteReq.
         * @memberof immessage
         * @interface IGroupMuteReq
         * @property {string|null} [groupId] GroupMuteReq groupId
         * @property {number|null} [isMute] GroupMuteReq isMute
         */

        /**
         * Constructs a new GroupMuteReq.
         * @memberof immessage
         * @classdesc Represents a GroupMuteReq.
         * @implements IGroupMuteReq
         * @constructor
         * @param {immessage.IGroupMuteReq=} [properties] Properties to set
         */
        function GroupMuteReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupMuteReq groupId.
         * @member {string} groupId
         * @memberof immessage.GroupMuteReq
         * @instance
         */
        GroupMuteReq.prototype.groupId = "";

        /**
         * GroupMuteReq isMute.
         * @member {number} isMute
         * @memberof immessage.GroupMuteReq
         * @instance
         */
        GroupMuteReq.prototype.isMute = 0;

        /**
         * Creates a new GroupMuteReq instance using the specified properties.
         * @function create
         * @memberof immessage.GroupMuteReq
         * @static
         * @param {immessage.IGroupMuteReq=} [properties] Properties to set
         * @returns {immessage.GroupMuteReq} GroupMuteReq instance
         */
        GroupMuteReq.create = function create(properties) {
            return new GroupMuteReq(properties);
        };

        /**
         * Encodes the specified GroupMuteReq message. Does not implicitly {@link immessage.GroupMuteReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.GroupMuteReq
         * @static
         * @param {immessage.IGroupMuteReq} message GroupMuteReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupMuteReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
            if (message.isMute != null && Object.hasOwnProperty.call(message, "isMute"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isMute);
            return writer;
        };

        /**
         * Encodes the specified GroupMuteReq message, length delimited. Does not implicitly {@link immessage.GroupMuteReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.GroupMuteReq
         * @static
         * @param {immessage.IGroupMuteReq} message GroupMuteReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupMuteReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupMuteReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.GroupMuteReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.GroupMuteReq} GroupMuteReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMuteReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.GroupMuteReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.groupId = reader.string();
                        break;
                    }
                case 2: {
                        message.isMute = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupMuteReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.GroupMuteReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.GroupMuteReq} GroupMuteReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMuteReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupMuteReq message.
         * @function verify
         * @memberof immessage.GroupMuteReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupMuteReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isString(message.groupId))
                    return "groupId: string expected";
            if (message.isMute != null && message.hasOwnProperty("isMute"))
                if (!$util.isInteger(message.isMute))
                    return "isMute: integer expected";
            return null;
        };

        /**
         * Creates a GroupMuteReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.GroupMuteReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.GroupMuteReq} GroupMuteReq
         */
        GroupMuteReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.GroupMuteReq)
                return object;
            let message = new $root.immessage.GroupMuteReq();
            if (object.groupId != null)
                message.groupId = String(object.groupId);
            if (object.isMute != null)
                message.isMute = object.isMute | 0;
            return message;
        };

        /**
         * Creates a plain object from a GroupMuteReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.GroupMuteReq
         * @static
         * @param {immessage.GroupMuteReq} message GroupMuteReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupMuteReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.groupId = "";
                object.isMute = 0;
            }
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = message.groupId;
            if (message.isMute != null && message.hasOwnProperty("isMute"))
                object.isMute = message.isMute;
            return object;
        };

        /**
         * Converts this GroupMuteReq to JSON.
         * @function toJSON
         * @memberof immessage.GroupMuteReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupMuteReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GroupMuteReq
         * @function getTypeUrl
         * @memberof immessage.GroupMuteReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GroupMuteReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.GroupMuteReq";
        };

        return GroupMuteReq;
    })();

    immessage.GroupInfoReq = (function() {

        /**
         * Properties of a GroupInfoReq.
         * @memberof immessage
         * @interface IGroupInfoReq
         * @property {string|null} [groupId] GroupInfoReq groupId
         * @property {Array.<string>|null} [careFields] GroupInfoReq careFields
         */

        /**
         * Constructs a new GroupInfoReq.
         * @memberof immessage
         * @classdesc Represents a GroupInfoReq.
         * @implements IGroupInfoReq
         * @constructor
         * @param {immessage.IGroupInfoReq=} [properties] Properties to set
         */
        function GroupInfoReq(properties) {
            this.careFields = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupInfoReq groupId.
         * @member {string} groupId
         * @memberof immessage.GroupInfoReq
         * @instance
         */
        GroupInfoReq.prototype.groupId = "";

        /**
         * GroupInfoReq careFields.
         * @member {Array.<string>} careFields
         * @memberof immessage.GroupInfoReq
         * @instance
         */
        GroupInfoReq.prototype.careFields = $util.emptyArray;

        /**
         * Creates a new GroupInfoReq instance using the specified properties.
         * @function create
         * @memberof immessage.GroupInfoReq
         * @static
         * @param {immessage.IGroupInfoReq=} [properties] Properties to set
         * @returns {immessage.GroupInfoReq} GroupInfoReq instance
         */
        GroupInfoReq.create = function create(properties) {
            return new GroupInfoReq(properties);
        };

        /**
         * Encodes the specified GroupInfoReq message. Does not implicitly {@link immessage.GroupInfoReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.GroupInfoReq
         * @static
         * @param {immessage.IGroupInfoReq} message GroupInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupInfoReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
            if (message.careFields != null && message.careFields.length)
                for (let i = 0; i < message.careFields.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.careFields[i]);
            return writer;
        };

        /**
         * Encodes the specified GroupInfoReq message, length delimited. Does not implicitly {@link immessage.GroupInfoReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.GroupInfoReq
         * @static
         * @param {immessage.IGroupInfoReq} message GroupInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupInfoReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.GroupInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.GroupInfoReq} GroupInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupInfoReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.GroupInfoReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.groupId = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.careFields && message.careFields.length))
                            message.careFields = [];
                        message.careFields.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupInfoReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.GroupInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.GroupInfoReq} GroupInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupInfoReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupInfoReq message.
         * @function verify
         * @memberof immessage.GroupInfoReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupInfoReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isString(message.groupId))
                    return "groupId: string expected";
            if (message.careFields != null && message.hasOwnProperty("careFields")) {
                if (!Array.isArray(message.careFields))
                    return "careFields: array expected";
                for (let i = 0; i < message.careFields.length; ++i)
                    if (!$util.isString(message.careFields[i]))
                        return "careFields: string[] expected";
            }
            return null;
        };

        /**
         * Creates a GroupInfoReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.GroupInfoReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.GroupInfoReq} GroupInfoReq
         */
        GroupInfoReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.GroupInfoReq)
                return object;
            let message = new $root.immessage.GroupInfoReq();
            if (object.groupId != null)
                message.groupId = String(object.groupId);
            if (object.careFields) {
                if (!Array.isArray(object.careFields))
                    throw TypeError(".immessage.GroupInfoReq.careFields: array expected");
                message.careFields = [];
                for (let i = 0; i < object.careFields.length; ++i)
                    message.careFields[i] = String(object.careFields[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupInfoReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.GroupInfoReq
         * @static
         * @param {immessage.GroupInfoReq} message GroupInfoReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupInfoReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.careFields = [];
            if (options.defaults)
                object.groupId = "";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = message.groupId;
            if (message.careFields && message.careFields.length) {
                object.careFields = [];
                for (let j = 0; j < message.careFields.length; ++j)
                    object.careFields[j] = message.careFields[j];
            }
            return object;
        };

        /**
         * Converts this GroupInfoReq to JSON.
         * @function toJSON
         * @memberof immessage.GroupInfoReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupInfoReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GroupInfoReq
         * @function getTypeUrl
         * @memberof immessage.GroupInfoReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GroupInfoReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.GroupInfoReq";
        };

        return GroupInfoReq;
    })();

    immessage.GroupIdsReq = (function() {

        /**
         * Properties of a GroupIdsReq.
         * @memberof immessage
         * @interface IGroupIdsReq
         * @property {Array.<string>|null} [groupIds] GroupIdsReq groupIds
         */

        /**
         * Constructs a new GroupIdsReq.
         * @memberof immessage
         * @classdesc Represents a GroupIdsReq.
         * @implements IGroupIdsReq
         * @constructor
         * @param {immessage.IGroupIdsReq=} [properties] Properties to set
         */
        function GroupIdsReq(properties) {
            this.groupIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupIdsReq groupIds.
         * @member {Array.<string>} groupIds
         * @memberof immessage.GroupIdsReq
         * @instance
         */
        GroupIdsReq.prototype.groupIds = $util.emptyArray;

        /**
         * Creates a new GroupIdsReq instance using the specified properties.
         * @function create
         * @memberof immessage.GroupIdsReq
         * @static
         * @param {immessage.IGroupIdsReq=} [properties] Properties to set
         * @returns {immessage.GroupIdsReq} GroupIdsReq instance
         */
        GroupIdsReq.create = function create(properties) {
            return new GroupIdsReq(properties);
        };

        /**
         * Encodes the specified GroupIdsReq message. Does not implicitly {@link immessage.GroupIdsReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.GroupIdsReq
         * @static
         * @param {immessage.IGroupIdsReq} message GroupIdsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupIdsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupIds != null && message.groupIds.length)
                for (let i = 0; i < message.groupIds.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupIds[i]);
            return writer;
        };

        /**
         * Encodes the specified GroupIdsReq message, length delimited. Does not implicitly {@link immessage.GroupIdsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.GroupIdsReq
         * @static
         * @param {immessage.IGroupIdsReq} message GroupIdsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupIdsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupIdsReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.GroupIdsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.GroupIdsReq} GroupIdsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupIdsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.GroupIdsReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.groupIds && message.groupIds.length))
                            message.groupIds = [];
                        message.groupIds.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupIdsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.GroupIdsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.GroupIdsReq} GroupIdsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupIdsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupIdsReq message.
         * @function verify
         * @memberof immessage.GroupIdsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupIdsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupIds != null && message.hasOwnProperty("groupIds")) {
                if (!Array.isArray(message.groupIds))
                    return "groupIds: array expected";
                for (let i = 0; i < message.groupIds.length; ++i)
                    if (!$util.isString(message.groupIds[i]))
                        return "groupIds: string[] expected";
            }
            return null;
        };

        /**
         * Creates a GroupIdsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.GroupIdsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.GroupIdsReq} GroupIdsReq
         */
        GroupIdsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.GroupIdsReq)
                return object;
            let message = new $root.immessage.GroupIdsReq();
            if (object.groupIds) {
                if (!Array.isArray(object.groupIds))
                    throw TypeError(".immessage.GroupIdsReq.groupIds: array expected");
                message.groupIds = [];
                for (let i = 0; i < object.groupIds.length; ++i)
                    message.groupIds[i] = String(object.groupIds[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupIdsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.GroupIdsReq
         * @static
         * @param {immessage.GroupIdsReq} message GroupIdsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupIdsReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.groupIds = [];
            if (message.groupIds && message.groupIds.length) {
                object.groupIds = [];
                for (let j = 0; j < message.groupIds.length; ++j)
                    object.groupIds[j] = message.groupIds[j];
            }
            return object;
        };

        /**
         * Converts this GroupIdsReq to JSON.
         * @function toJSON
         * @memberof immessage.GroupIdsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupIdsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GroupIdsReq
         * @function getTypeUrl
         * @memberof immessage.GroupIdsReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GroupIdsReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.GroupIdsReq";
        };

        return GroupIdsReq;
    })();

    immessage.GroupInfosResp = (function() {

        /**
         * Properties of a GroupInfosResp.
         * @memberof immessage
         * @interface IGroupInfosResp
         * @property {Object.<string,immessage.IGroupInfo>|null} [groupInfoMap] GroupInfosResp groupInfoMap
         */

        /**
         * Constructs a new GroupInfosResp.
         * @memberof immessage
         * @classdesc Represents a GroupInfosResp.
         * @implements IGroupInfosResp
         * @constructor
         * @param {immessage.IGroupInfosResp=} [properties] Properties to set
         */
        function GroupInfosResp(properties) {
            this.groupInfoMap = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupInfosResp groupInfoMap.
         * @member {Object.<string,immessage.IGroupInfo>} groupInfoMap
         * @memberof immessage.GroupInfosResp
         * @instance
         */
        GroupInfosResp.prototype.groupInfoMap = $util.emptyObject;

        /**
         * Creates a new GroupInfosResp instance using the specified properties.
         * @function create
         * @memberof immessage.GroupInfosResp
         * @static
         * @param {immessage.IGroupInfosResp=} [properties] Properties to set
         * @returns {immessage.GroupInfosResp} GroupInfosResp instance
         */
        GroupInfosResp.create = function create(properties) {
            return new GroupInfosResp(properties);
        };

        /**
         * Encodes the specified GroupInfosResp message. Does not implicitly {@link immessage.GroupInfosResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.GroupInfosResp
         * @static
         * @param {immessage.IGroupInfosResp} message GroupInfosResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupInfosResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupInfoMap != null && Object.hasOwnProperty.call(message, "groupInfoMap"))
                for (let keys = Object.keys(message.groupInfoMap), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.immessage.GroupInfo.encode(message.groupInfoMap[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified GroupInfosResp message, length delimited. Does not implicitly {@link immessage.GroupInfosResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.GroupInfosResp
         * @static
         * @param {immessage.IGroupInfosResp} message GroupInfosResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupInfosResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupInfosResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.GroupInfosResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.GroupInfosResp} GroupInfosResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupInfosResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.GroupInfosResp(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (message.groupInfoMap === $util.emptyObject)
                            message.groupInfoMap = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.immessage.GroupInfo.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.groupInfoMap[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupInfosResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.GroupInfosResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.GroupInfosResp} GroupInfosResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupInfosResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupInfosResp message.
         * @function verify
         * @memberof immessage.GroupInfosResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupInfosResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupInfoMap != null && message.hasOwnProperty("groupInfoMap")) {
                if (!$util.isObject(message.groupInfoMap))
                    return "groupInfoMap: object expected";
                let key = Object.keys(message.groupInfoMap);
                for (let i = 0; i < key.length; ++i) {
                    let error = $root.immessage.GroupInfo.verify(message.groupInfoMap[key[i]]);
                    if (error)
                        return "groupInfoMap." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GroupInfosResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.GroupInfosResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.GroupInfosResp} GroupInfosResp
         */
        GroupInfosResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.GroupInfosResp)
                return object;
            let message = new $root.immessage.GroupInfosResp();
            if (object.groupInfoMap) {
                if (typeof object.groupInfoMap !== "object")
                    throw TypeError(".immessage.GroupInfosResp.groupInfoMap: object expected");
                message.groupInfoMap = {};
                for (let keys = Object.keys(object.groupInfoMap), i = 0; i < keys.length; ++i) {
                    if (typeof object.groupInfoMap[keys[i]] !== "object")
                        throw TypeError(".immessage.GroupInfosResp.groupInfoMap: object expected");
                    message.groupInfoMap[keys[i]] = $root.immessage.GroupInfo.fromObject(object.groupInfoMap[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupInfosResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.GroupInfosResp
         * @static
         * @param {immessage.GroupInfosResp} message GroupInfosResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupInfosResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.groupInfoMap = {};
            let keys2;
            if (message.groupInfoMap && (keys2 = Object.keys(message.groupInfoMap)).length) {
                object.groupInfoMap = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.groupInfoMap[keys2[j]] = $root.immessage.GroupInfo.toObject(message.groupInfoMap[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this GroupInfosResp to JSON.
         * @function toJSON
         * @memberof immessage.GroupInfosResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupInfosResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GroupInfosResp
         * @function getTypeUrl
         * @memberof immessage.GroupInfosResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GroupInfosResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.GroupInfosResp";
        };

        return GroupInfosResp;
    })();

    immessage.GroupMemberMuteReq = (function() {

        /**
         * Properties of a GroupMemberMuteReq.
         * @memberof immessage
         * @interface IGroupMemberMuteReq
         * @property {string|null} [groupId] GroupMemberMuteReq groupId
         * @property {Array.<string>|null} [memberIds] GroupMemberMuteReq memberIds
         * @property {number|null} [isMute] GroupMemberMuteReq isMute
         * @property {number|Long|null} [muteEndAt] GroupMemberMuteReq muteEndAt
         */

        /**
         * Constructs a new GroupMemberMuteReq.
         * @memberof immessage
         * @classdesc Represents a GroupMemberMuteReq.
         * @implements IGroupMemberMuteReq
         * @constructor
         * @param {immessage.IGroupMemberMuteReq=} [properties] Properties to set
         */
        function GroupMemberMuteReq(properties) {
            this.memberIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupMemberMuteReq groupId.
         * @member {string} groupId
         * @memberof immessage.GroupMemberMuteReq
         * @instance
         */
        GroupMemberMuteReq.prototype.groupId = "";

        /**
         * GroupMemberMuteReq memberIds.
         * @member {Array.<string>} memberIds
         * @memberof immessage.GroupMemberMuteReq
         * @instance
         */
        GroupMemberMuteReq.prototype.memberIds = $util.emptyArray;

        /**
         * GroupMemberMuteReq isMute.
         * @member {number} isMute
         * @memberof immessage.GroupMemberMuteReq
         * @instance
         */
        GroupMemberMuteReq.prototype.isMute = 0;

        /**
         * GroupMemberMuteReq muteEndAt.
         * @member {number|Long} muteEndAt
         * @memberof immessage.GroupMemberMuteReq
         * @instance
         */
        GroupMemberMuteReq.prototype.muteEndAt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GroupMemberMuteReq instance using the specified properties.
         * @function create
         * @memberof immessage.GroupMemberMuteReq
         * @static
         * @param {immessage.IGroupMemberMuteReq=} [properties] Properties to set
         * @returns {immessage.GroupMemberMuteReq} GroupMemberMuteReq instance
         */
        GroupMemberMuteReq.create = function create(properties) {
            return new GroupMemberMuteReq(properties);
        };

        /**
         * Encodes the specified GroupMemberMuteReq message. Does not implicitly {@link immessage.GroupMemberMuteReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.GroupMemberMuteReq
         * @static
         * @param {immessage.IGroupMemberMuteReq} message GroupMemberMuteReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupMemberMuteReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
            if (message.memberIds != null && message.memberIds.length)
                for (let i = 0; i < message.memberIds.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.memberIds[i]);
            if (message.isMute != null && Object.hasOwnProperty.call(message, "isMute"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.isMute);
            if (message.muteEndAt != null && Object.hasOwnProperty.call(message, "muteEndAt"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.muteEndAt);
            return writer;
        };

        /**
         * Encodes the specified GroupMemberMuteReq message, length delimited. Does not implicitly {@link immessage.GroupMemberMuteReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.GroupMemberMuteReq
         * @static
         * @param {immessage.IGroupMemberMuteReq} message GroupMemberMuteReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupMemberMuteReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupMemberMuteReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.GroupMemberMuteReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.GroupMemberMuteReq} GroupMemberMuteReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMemberMuteReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.GroupMemberMuteReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.groupId = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.memberIds && message.memberIds.length))
                            message.memberIds = [];
                        message.memberIds.push(reader.string());
                        break;
                    }
                case 3: {
                        message.isMute = reader.int32();
                        break;
                    }
                case 4: {
                        message.muteEndAt = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupMemberMuteReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.GroupMemberMuteReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.GroupMemberMuteReq} GroupMemberMuteReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMemberMuteReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupMemberMuteReq message.
         * @function verify
         * @memberof immessage.GroupMemberMuteReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupMemberMuteReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isString(message.groupId))
                    return "groupId: string expected";
            if (message.memberIds != null && message.hasOwnProperty("memberIds")) {
                if (!Array.isArray(message.memberIds))
                    return "memberIds: array expected";
                for (let i = 0; i < message.memberIds.length; ++i)
                    if (!$util.isString(message.memberIds[i]))
                        return "memberIds: string[] expected";
            }
            if (message.isMute != null && message.hasOwnProperty("isMute"))
                if (!$util.isInteger(message.isMute))
                    return "isMute: integer expected";
            if (message.muteEndAt != null && message.hasOwnProperty("muteEndAt"))
                if (!$util.isInteger(message.muteEndAt) && !(message.muteEndAt && $util.isInteger(message.muteEndAt.low) && $util.isInteger(message.muteEndAt.high)))
                    return "muteEndAt: integer|Long expected";
            return null;
        };

        /**
         * Creates a GroupMemberMuteReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.GroupMemberMuteReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.GroupMemberMuteReq} GroupMemberMuteReq
         */
        GroupMemberMuteReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.GroupMemberMuteReq)
                return object;
            let message = new $root.immessage.GroupMemberMuteReq();
            if (object.groupId != null)
                message.groupId = String(object.groupId);
            if (object.memberIds) {
                if (!Array.isArray(object.memberIds))
                    throw TypeError(".immessage.GroupMemberMuteReq.memberIds: array expected");
                message.memberIds = [];
                for (let i = 0; i < object.memberIds.length; ++i)
                    message.memberIds[i] = String(object.memberIds[i]);
            }
            if (object.isMute != null)
                message.isMute = object.isMute | 0;
            if (object.muteEndAt != null)
                if ($util.Long)
                    (message.muteEndAt = $util.Long.fromValue(object.muteEndAt)).unsigned = false;
                else if (typeof object.muteEndAt === "string")
                    message.muteEndAt = parseInt(object.muteEndAt, 10);
                else if (typeof object.muteEndAt === "number")
                    message.muteEndAt = object.muteEndAt;
                else if (typeof object.muteEndAt === "object")
                    message.muteEndAt = new $util.LongBits(object.muteEndAt.low >>> 0, object.muteEndAt.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a GroupMemberMuteReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.GroupMemberMuteReq
         * @static
         * @param {immessage.GroupMemberMuteReq} message GroupMemberMuteReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupMemberMuteReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.memberIds = [];
            if (options.defaults) {
                object.groupId = "";
                object.isMute = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.muteEndAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.muteEndAt = options.longs === String ? "0" : 0;
            }
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = message.groupId;
            if (message.memberIds && message.memberIds.length) {
                object.memberIds = [];
                for (let j = 0; j < message.memberIds.length; ++j)
                    object.memberIds[j] = message.memberIds[j];
            }
            if (message.isMute != null && message.hasOwnProperty("isMute"))
                object.isMute = message.isMute;
            if (message.muteEndAt != null && message.hasOwnProperty("muteEndAt"))
                if (typeof message.muteEndAt === "number")
                    object.muteEndAt = options.longs === String ? String(message.muteEndAt) : message.muteEndAt;
                else
                    object.muteEndAt = options.longs === String ? $util.Long.prototype.toString.call(message.muteEndAt) : options.longs === Number ? new $util.LongBits(message.muteEndAt.low >>> 0, message.muteEndAt.high >>> 0).toNumber() : message.muteEndAt;
            return object;
        };

        /**
         * Converts this GroupMemberMuteReq to JSON.
         * @function toJSON
         * @memberof immessage.GroupMemberMuteReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupMemberMuteReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GroupMemberMuteReq
         * @function getTypeUrl
         * @memberof immessage.GroupMemberMuteReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GroupMemberMuteReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.GroupMemberMuteReq";
        };

        return GroupMemberMuteReq;
    })();

    immessage.GroupMemberAllowReq = (function() {

        /**
         * Properties of a GroupMemberAllowReq.
         * @memberof immessage
         * @interface IGroupMemberAllowReq
         * @property {string|null} [groupId] GroupMemberAllowReq groupId
         * @property {Array.<string>|null} [memberIds] GroupMemberAllowReq memberIds
         * @property {number|null} [isAllow] GroupMemberAllowReq isAllow
         */

        /**
         * Constructs a new GroupMemberAllowReq.
         * @memberof immessage
         * @classdesc Represents a GroupMemberAllowReq.
         * @implements IGroupMemberAllowReq
         * @constructor
         * @param {immessage.IGroupMemberAllowReq=} [properties] Properties to set
         */
        function GroupMemberAllowReq(properties) {
            this.memberIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupMemberAllowReq groupId.
         * @member {string} groupId
         * @memberof immessage.GroupMemberAllowReq
         * @instance
         */
        GroupMemberAllowReq.prototype.groupId = "";

        /**
         * GroupMemberAllowReq memberIds.
         * @member {Array.<string>} memberIds
         * @memberof immessage.GroupMemberAllowReq
         * @instance
         */
        GroupMemberAllowReq.prototype.memberIds = $util.emptyArray;

        /**
         * GroupMemberAllowReq isAllow.
         * @member {number} isAllow
         * @memberof immessage.GroupMemberAllowReq
         * @instance
         */
        GroupMemberAllowReq.prototype.isAllow = 0;

        /**
         * Creates a new GroupMemberAllowReq instance using the specified properties.
         * @function create
         * @memberof immessage.GroupMemberAllowReq
         * @static
         * @param {immessage.IGroupMemberAllowReq=} [properties] Properties to set
         * @returns {immessage.GroupMemberAllowReq} GroupMemberAllowReq instance
         */
        GroupMemberAllowReq.create = function create(properties) {
            return new GroupMemberAllowReq(properties);
        };

        /**
         * Encodes the specified GroupMemberAllowReq message. Does not implicitly {@link immessage.GroupMemberAllowReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.GroupMemberAllowReq
         * @static
         * @param {immessage.IGroupMemberAllowReq} message GroupMemberAllowReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupMemberAllowReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
            if (message.memberIds != null && message.memberIds.length)
                for (let i = 0; i < message.memberIds.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.memberIds[i]);
            if (message.isAllow != null && Object.hasOwnProperty.call(message, "isAllow"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.isAllow);
            return writer;
        };

        /**
         * Encodes the specified GroupMemberAllowReq message, length delimited. Does not implicitly {@link immessage.GroupMemberAllowReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.GroupMemberAllowReq
         * @static
         * @param {immessage.IGroupMemberAllowReq} message GroupMemberAllowReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupMemberAllowReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupMemberAllowReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.GroupMemberAllowReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.GroupMemberAllowReq} GroupMemberAllowReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMemberAllowReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.GroupMemberAllowReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.groupId = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.memberIds && message.memberIds.length))
                            message.memberIds = [];
                        message.memberIds.push(reader.string());
                        break;
                    }
                case 3: {
                        message.isAllow = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupMemberAllowReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.GroupMemberAllowReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.GroupMemberAllowReq} GroupMemberAllowReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMemberAllowReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupMemberAllowReq message.
         * @function verify
         * @memberof immessage.GroupMemberAllowReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupMemberAllowReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isString(message.groupId))
                    return "groupId: string expected";
            if (message.memberIds != null && message.hasOwnProperty("memberIds")) {
                if (!Array.isArray(message.memberIds))
                    return "memberIds: array expected";
                for (let i = 0; i < message.memberIds.length; ++i)
                    if (!$util.isString(message.memberIds[i]))
                        return "memberIds: string[] expected";
            }
            if (message.isAllow != null && message.hasOwnProperty("isAllow"))
                if (!$util.isInteger(message.isAllow))
                    return "isAllow: integer expected";
            return null;
        };

        /**
         * Creates a GroupMemberAllowReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.GroupMemberAllowReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.GroupMemberAllowReq} GroupMemberAllowReq
         */
        GroupMemberAllowReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.GroupMemberAllowReq)
                return object;
            let message = new $root.immessage.GroupMemberAllowReq();
            if (object.groupId != null)
                message.groupId = String(object.groupId);
            if (object.memberIds) {
                if (!Array.isArray(object.memberIds))
                    throw TypeError(".immessage.GroupMemberAllowReq.memberIds: array expected");
                message.memberIds = [];
                for (let i = 0; i < object.memberIds.length; ++i)
                    message.memberIds[i] = String(object.memberIds[i]);
            }
            if (object.isAllow != null)
                message.isAllow = object.isAllow | 0;
            return message;
        };

        /**
         * Creates a plain object from a GroupMemberAllowReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.GroupMemberAllowReq
         * @static
         * @param {immessage.GroupMemberAllowReq} message GroupMemberAllowReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupMemberAllowReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.memberIds = [];
            if (options.defaults) {
                object.groupId = "";
                object.isAllow = 0;
            }
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = message.groupId;
            if (message.memberIds && message.memberIds.length) {
                object.memberIds = [];
                for (let j = 0; j < message.memberIds.length; ++j)
                    object.memberIds[j] = message.memberIds[j];
            }
            if (message.isAllow != null && message.hasOwnProperty("isAllow"))
                object.isAllow = message.isAllow;
            return object;
        };

        /**
         * Converts this GroupMemberAllowReq to JSON.
         * @function toJSON
         * @memberof immessage.GroupMemberAllowReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupMemberAllowReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GroupMemberAllowReq
         * @function getTypeUrl
         * @memberof immessage.GroupMemberAllowReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GroupMemberAllowReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.GroupMemberAllowReq";
        };

        return GroupMemberAllowReq;
    })();

    immessage.GroupMembersResp = (function() {

        /**
         * Properties of a GroupMembersResp.
         * @memberof immessage
         * @interface IGroupMembersResp
         * @property {Array.<immessage.IGroupMember>|null} [items] GroupMembersResp items
         * @property {string|null} [offset] GroupMembersResp offset
         */

        /**
         * Constructs a new GroupMembersResp.
         * @memberof immessage
         * @classdesc Represents a GroupMembersResp.
         * @implements IGroupMembersResp
         * @constructor
         * @param {immessage.IGroupMembersResp=} [properties] Properties to set
         */
        function GroupMembersResp(properties) {
            this.items = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupMembersResp items.
         * @member {Array.<immessage.IGroupMember>} items
         * @memberof immessage.GroupMembersResp
         * @instance
         */
        GroupMembersResp.prototype.items = $util.emptyArray;

        /**
         * GroupMembersResp offset.
         * @member {string} offset
         * @memberof immessage.GroupMembersResp
         * @instance
         */
        GroupMembersResp.prototype.offset = "";

        /**
         * Creates a new GroupMembersResp instance using the specified properties.
         * @function create
         * @memberof immessage.GroupMembersResp
         * @static
         * @param {immessage.IGroupMembersResp=} [properties] Properties to set
         * @returns {immessage.GroupMembersResp} GroupMembersResp instance
         */
        GroupMembersResp.create = function create(properties) {
            return new GroupMembersResp(properties);
        };

        /**
         * Encodes the specified GroupMembersResp message. Does not implicitly {@link immessage.GroupMembersResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.GroupMembersResp
         * @static
         * @param {immessage.IGroupMembersResp} message GroupMembersResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupMembersResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (let i = 0; i < message.items.length; ++i)
                    $root.immessage.GroupMember.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.offset);
            return writer;
        };

        /**
         * Encodes the specified GroupMembersResp message, length delimited. Does not implicitly {@link immessage.GroupMembersResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.GroupMembersResp
         * @static
         * @param {immessage.IGroupMembersResp} message GroupMembersResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupMembersResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupMembersResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.GroupMembersResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.GroupMembersResp} GroupMembersResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMembersResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.GroupMembersResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.immessage.GroupMember.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.offset = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupMembersResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.GroupMembersResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.GroupMembersResp} GroupMembersResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMembersResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupMembersResp message.
         * @function verify
         * @memberof immessage.GroupMembersResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupMembersResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (let i = 0; i < message.items.length; ++i) {
                    let error = $root.immessage.GroupMember.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isString(message.offset))
                    return "offset: string expected";
            return null;
        };

        /**
         * Creates a GroupMembersResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.GroupMembersResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.GroupMembersResp} GroupMembersResp
         */
        GroupMembersResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.GroupMembersResp)
                return object;
            let message = new $root.immessage.GroupMembersResp();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".immessage.GroupMembersResp.items: array expected");
                message.items = [];
                for (let i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".immessage.GroupMembersResp.items: object expected");
                    message.items[i] = $root.immessage.GroupMember.fromObject(object.items[i]);
                }
            }
            if (object.offset != null)
                message.offset = String(object.offset);
            return message;
        };

        /**
         * Creates a plain object from a GroupMembersResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.GroupMembersResp
         * @static
         * @param {immessage.GroupMembersResp} message GroupMembersResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupMembersResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                object.offset = "";
            if (message.items && message.items.length) {
                object.items = [];
                for (let j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.immessage.GroupMember.toObject(message.items[j], options);
            }
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            return object;
        };

        /**
         * Converts this GroupMembersResp to JSON.
         * @function toJSON
         * @memberof immessage.GroupMembersResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupMembersResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GroupMembersResp
         * @function getTypeUrl
         * @memberof immessage.GroupMembersResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GroupMembersResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.GroupMembersResp";
        };

        return GroupMembersResp;
    })();

    immessage.GroupMember = (function() {

        /**
         * Properties of a GroupMember.
         * @memberof immessage
         * @interface IGroupMember
         * @property {string|null} [memberId] GroupMember memberId
         * @property {number|null} [isMute] GroupMember isMute
         * @property {number|null} [isAllow] GroupMember isAllow
         * @property {Array.<immessage.IKvItem>|null} [extFields] GroupMember extFields
         * @property {Array.<immessage.IKvItem>|null} [settings] GroupMember settings
         * @property {immessage.UserType|null} [memberType] GroupMember memberType
         */

        /**
         * Constructs a new GroupMember.
         * @memberof immessage
         * @classdesc Represents a GroupMember.
         * @implements IGroupMember
         * @constructor
         * @param {immessage.IGroupMember=} [properties] Properties to set
         */
        function GroupMember(properties) {
            this.extFields = [];
            this.settings = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupMember memberId.
         * @member {string} memberId
         * @memberof immessage.GroupMember
         * @instance
         */
        GroupMember.prototype.memberId = "";

        /**
         * GroupMember isMute.
         * @member {number} isMute
         * @memberof immessage.GroupMember
         * @instance
         */
        GroupMember.prototype.isMute = 0;

        /**
         * GroupMember isAllow.
         * @member {number} isAllow
         * @memberof immessage.GroupMember
         * @instance
         */
        GroupMember.prototype.isAllow = 0;

        /**
         * GroupMember extFields.
         * @member {Array.<immessage.IKvItem>} extFields
         * @memberof immessage.GroupMember
         * @instance
         */
        GroupMember.prototype.extFields = $util.emptyArray;

        /**
         * GroupMember settings.
         * @member {Array.<immessage.IKvItem>} settings
         * @memberof immessage.GroupMember
         * @instance
         */
        GroupMember.prototype.settings = $util.emptyArray;

        /**
         * GroupMember memberType.
         * @member {immessage.UserType} memberType
         * @memberof immessage.GroupMember
         * @instance
         */
        GroupMember.prototype.memberType = 0;

        /**
         * Creates a new GroupMember instance using the specified properties.
         * @function create
         * @memberof immessage.GroupMember
         * @static
         * @param {immessage.IGroupMember=} [properties] Properties to set
         * @returns {immessage.GroupMember} GroupMember instance
         */
        GroupMember.create = function create(properties) {
            return new GroupMember(properties);
        };

        /**
         * Encodes the specified GroupMember message. Does not implicitly {@link immessage.GroupMember.verify|verify} messages.
         * @function encode
         * @memberof immessage.GroupMember
         * @static
         * @param {immessage.IGroupMember} message GroupMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupMember.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.memberId != null && Object.hasOwnProperty.call(message, "memberId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.memberId);
            if (message.isMute != null && Object.hasOwnProperty.call(message, "isMute"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isMute);
            if (message.isAllow != null && Object.hasOwnProperty.call(message, "isAllow"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.isAllow);
            if (message.extFields != null && message.extFields.length)
                for (let i = 0; i < message.extFields.length; ++i)
                    $root.immessage.KvItem.encode(message.extFields[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.settings != null && message.settings.length)
                for (let i = 0; i < message.settings.length; ++i)
                    $root.immessage.KvItem.encode(message.settings[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.memberType != null && Object.hasOwnProperty.call(message, "memberType"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.memberType);
            return writer;
        };

        /**
         * Encodes the specified GroupMember message, length delimited. Does not implicitly {@link immessage.GroupMember.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.GroupMember
         * @static
         * @param {immessage.IGroupMember} message GroupMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupMember.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupMember message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.GroupMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.GroupMember} GroupMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMember.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.GroupMember();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.memberId = reader.string();
                        break;
                    }
                case 2: {
                        message.isMute = reader.int32();
                        break;
                    }
                case 3: {
                        message.isAllow = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.extFields && message.extFields.length))
                            message.extFields = [];
                        message.extFields.push($root.immessage.KvItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        if (!(message.settings && message.settings.length))
                            message.settings = [];
                        message.settings.push($root.immessage.KvItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        message.memberType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupMember message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.GroupMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.GroupMember} GroupMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMember.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupMember message.
         * @function verify
         * @memberof immessage.GroupMember
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupMember.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.memberId != null && message.hasOwnProperty("memberId"))
                if (!$util.isString(message.memberId))
                    return "memberId: string expected";
            if (message.isMute != null && message.hasOwnProperty("isMute"))
                if (!$util.isInteger(message.isMute))
                    return "isMute: integer expected";
            if (message.isAllow != null && message.hasOwnProperty("isAllow"))
                if (!$util.isInteger(message.isAllow))
                    return "isAllow: integer expected";
            if (message.extFields != null && message.hasOwnProperty("extFields")) {
                if (!Array.isArray(message.extFields))
                    return "extFields: array expected";
                for (let i = 0; i < message.extFields.length; ++i) {
                    let error = $root.immessage.KvItem.verify(message.extFields[i]);
                    if (error)
                        return "extFields." + error;
                }
            }
            if (message.settings != null && message.hasOwnProperty("settings")) {
                if (!Array.isArray(message.settings))
                    return "settings: array expected";
                for (let i = 0; i < message.settings.length; ++i) {
                    let error = $root.immessage.KvItem.verify(message.settings[i]);
                    if (error)
                        return "settings." + error;
                }
            }
            if (message.memberType != null && message.hasOwnProperty("memberType"))
                switch (message.memberType) {
                default:
                    return "memberType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a GroupMember message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.GroupMember
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.GroupMember} GroupMember
         */
        GroupMember.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.GroupMember)
                return object;
            let message = new $root.immessage.GroupMember();
            if (object.memberId != null)
                message.memberId = String(object.memberId);
            if (object.isMute != null)
                message.isMute = object.isMute | 0;
            if (object.isAllow != null)
                message.isAllow = object.isAllow | 0;
            if (object.extFields) {
                if (!Array.isArray(object.extFields))
                    throw TypeError(".immessage.GroupMember.extFields: array expected");
                message.extFields = [];
                for (let i = 0; i < object.extFields.length; ++i) {
                    if (typeof object.extFields[i] !== "object")
                        throw TypeError(".immessage.GroupMember.extFields: object expected");
                    message.extFields[i] = $root.immessage.KvItem.fromObject(object.extFields[i]);
                }
            }
            if (object.settings) {
                if (!Array.isArray(object.settings))
                    throw TypeError(".immessage.GroupMember.settings: array expected");
                message.settings = [];
                for (let i = 0; i < object.settings.length; ++i) {
                    if (typeof object.settings[i] !== "object")
                        throw TypeError(".immessage.GroupMember.settings: object expected");
                    message.settings[i] = $root.immessage.KvItem.fromObject(object.settings[i]);
                }
            }
            switch (object.memberType) {
            default:
                if (typeof object.memberType === "number") {
                    message.memberType = object.memberType;
                    break;
                }
                break;
            case "User":
            case 0:
                message.memberType = 0;
                break;
            case "Bot":
            case 1:
                message.memberType = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupMember message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.GroupMember
         * @static
         * @param {immessage.GroupMember} message GroupMember
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupMember.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.extFields = [];
                object.settings = [];
            }
            if (options.defaults) {
                object.memberId = "";
                object.isMute = 0;
                object.isAllow = 0;
                object.memberType = options.enums === String ? "User" : 0;
            }
            if (message.memberId != null && message.hasOwnProperty("memberId"))
                object.memberId = message.memberId;
            if (message.isMute != null && message.hasOwnProperty("isMute"))
                object.isMute = message.isMute;
            if (message.isAllow != null && message.hasOwnProperty("isAllow"))
                object.isAllow = message.isAllow;
            if (message.extFields && message.extFields.length) {
                object.extFields = [];
                for (let j = 0; j < message.extFields.length; ++j)
                    object.extFields[j] = $root.immessage.KvItem.toObject(message.extFields[j], options);
            }
            if (message.settings && message.settings.length) {
                object.settings = [];
                for (let j = 0; j < message.settings.length; ++j)
                    object.settings[j] = $root.immessage.KvItem.toObject(message.settings[j], options);
            }
            if (message.memberType != null && message.hasOwnProperty("memberType"))
                object.memberType = options.enums === String ? $root.immessage.UserType[message.memberType] === undefined ? message.memberType : $root.immessage.UserType[message.memberType] : message.memberType;
            return object;
        };

        /**
         * Converts this GroupMember to JSON.
         * @function toJSON
         * @memberof immessage.GroupMember
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupMember.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GroupMember
         * @function getTypeUrl
         * @memberof immessage.GroupMember
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GroupMember.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.GroupMember";
        };

        return GroupMember;
    })();

    immessage.QryGroupMembersReq = (function() {

        /**
         * Properties of a QryGroupMembersReq.
         * @memberof immessage
         * @interface IQryGroupMembersReq
         * @property {string|null} [groupId] QryGroupMembersReq groupId
         * @property {number|Long|null} [limit] QryGroupMembersReq limit
         * @property {string|null} [offset] QryGroupMembersReq offset
         */

        /**
         * Constructs a new QryGroupMembersReq.
         * @memberof immessage
         * @classdesc Represents a QryGroupMembersReq.
         * @implements IQryGroupMembersReq
         * @constructor
         * @param {immessage.IQryGroupMembersReq=} [properties] Properties to set
         */
        function QryGroupMembersReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryGroupMembersReq groupId.
         * @member {string} groupId
         * @memberof immessage.QryGroupMembersReq
         * @instance
         */
        QryGroupMembersReq.prototype.groupId = "";

        /**
         * QryGroupMembersReq limit.
         * @member {number|Long} limit
         * @memberof immessage.QryGroupMembersReq
         * @instance
         */
        QryGroupMembersReq.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QryGroupMembersReq offset.
         * @member {string} offset
         * @memberof immessage.QryGroupMembersReq
         * @instance
         */
        QryGroupMembersReq.prototype.offset = "";

        /**
         * Creates a new QryGroupMembersReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryGroupMembersReq
         * @static
         * @param {immessage.IQryGroupMembersReq=} [properties] Properties to set
         * @returns {immessage.QryGroupMembersReq} QryGroupMembersReq instance
         */
        QryGroupMembersReq.create = function create(properties) {
            return new QryGroupMembersReq(properties);
        };

        /**
         * Encodes the specified QryGroupMembersReq message. Does not implicitly {@link immessage.QryGroupMembersReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryGroupMembersReq
         * @static
         * @param {immessage.IQryGroupMembersReq} message QryGroupMembersReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryGroupMembersReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
            if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.limit);
            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.offset);
            return writer;
        };

        /**
         * Encodes the specified QryGroupMembersReq message, length delimited. Does not implicitly {@link immessage.QryGroupMembersReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryGroupMembersReq
         * @static
         * @param {immessage.IQryGroupMembersReq} message QryGroupMembersReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryGroupMembersReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryGroupMembersReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryGroupMembersReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryGroupMembersReq} QryGroupMembersReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryGroupMembersReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryGroupMembersReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.groupId = reader.string();
                        break;
                    }
                case 2: {
                        message.limit = reader.int64();
                        break;
                    }
                case 3: {
                        message.offset = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryGroupMembersReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryGroupMembersReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryGroupMembersReq} QryGroupMembersReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryGroupMembersReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryGroupMembersReq message.
         * @function verify
         * @memberof immessage.QryGroupMembersReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryGroupMembersReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isString(message.groupId))
                    return "groupId: string expected";
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                    return "limit: integer|Long expected";
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isString(message.offset))
                    return "offset: string expected";
            return null;
        };

        /**
         * Creates a QryGroupMembersReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryGroupMembersReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryGroupMembersReq} QryGroupMembersReq
         */
        QryGroupMembersReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryGroupMembersReq)
                return object;
            let message = new $root.immessage.QryGroupMembersReq();
            if (object.groupId != null)
                message.groupId = String(object.groupId);
            if (object.limit != null)
                if ($util.Long)
                    (message.limit = $util.Long.fromValue(object.limit)).unsigned = false;
                else if (typeof object.limit === "string")
                    message.limit = parseInt(object.limit, 10);
                else if (typeof object.limit === "number")
                    message.limit = object.limit;
                else if (typeof object.limit === "object")
                    message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber();
            if (object.offset != null)
                message.offset = String(object.offset);
            return message;
        };

        /**
         * Creates a plain object from a QryGroupMembersReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryGroupMembersReq
         * @static
         * @param {immessage.QryGroupMembersReq} message QryGroupMembersReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryGroupMembersReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.groupId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.limit = options.longs === String ? "0" : 0;
                object.offset = "";
            }
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = message.groupId;
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (typeof message.limit === "number")
                    object.limit = options.longs === String ? String(message.limit) : message.limit;
                else
                    object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber() : message.limit;
            if (message.offset != null && message.hasOwnProperty("offset"))
                object.offset = message.offset;
            return object;
        };

        /**
         * Converts this QryGroupMembersReq to JSON.
         * @function toJSON
         * @memberof immessage.QryGroupMembersReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryGroupMembersReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryGroupMembersReq
         * @function getTypeUrl
         * @memberof immessage.QryGroupMembersReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryGroupMembersReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryGroupMembersReq";
        };

        return QryGroupMembersReq;
    })();

    immessage.CheckGroupMembersReq = (function() {

        /**
         * Properties of a CheckGroupMembersReq.
         * @memberof immessage
         * @interface ICheckGroupMembersReq
         * @property {string|null} [groupId] CheckGroupMembersReq groupId
         * @property {Array.<string>|null} [memberIds] CheckGroupMembersReq memberIds
         */

        /**
         * Constructs a new CheckGroupMembersReq.
         * @memberof immessage
         * @classdesc Represents a CheckGroupMembersReq.
         * @implements ICheckGroupMembersReq
         * @constructor
         * @param {immessage.ICheckGroupMembersReq=} [properties] Properties to set
         */
        function CheckGroupMembersReq(properties) {
            this.memberIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CheckGroupMembersReq groupId.
         * @member {string} groupId
         * @memberof immessage.CheckGroupMembersReq
         * @instance
         */
        CheckGroupMembersReq.prototype.groupId = "";

        /**
         * CheckGroupMembersReq memberIds.
         * @member {Array.<string>} memberIds
         * @memberof immessage.CheckGroupMembersReq
         * @instance
         */
        CheckGroupMembersReq.prototype.memberIds = $util.emptyArray;

        /**
         * Creates a new CheckGroupMembersReq instance using the specified properties.
         * @function create
         * @memberof immessage.CheckGroupMembersReq
         * @static
         * @param {immessage.ICheckGroupMembersReq=} [properties] Properties to set
         * @returns {immessage.CheckGroupMembersReq} CheckGroupMembersReq instance
         */
        CheckGroupMembersReq.create = function create(properties) {
            return new CheckGroupMembersReq(properties);
        };

        /**
         * Encodes the specified CheckGroupMembersReq message. Does not implicitly {@link immessage.CheckGroupMembersReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.CheckGroupMembersReq
         * @static
         * @param {immessage.ICheckGroupMembersReq} message CheckGroupMembersReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckGroupMembersReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
            if (message.memberIds != null && message.memberIds.length)
                for (let i = 0; i < message.memberIds.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.memberIds[i]);
            return writer;
        };

        /**
         * Encodes the specified CheckGroupMembersReq message, length delimited. Does not implicitly {@link immessage.CheckGroupMembersReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.CheckGroupMembersReq
         * @static
         * @param {immessage.ICheckGroupMembersReq} message CheckGroupMembersReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckGroupMembersReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CheckGroupMembersReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.CheckGroupMembersReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.CheckGroupMembersReq} CheckGroupMembersReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckGroupMembersReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.CheckGroupMembersReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.groupId = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.memberIds && message.memberIds.length))
                            message.memberIds = [];
                        message.memberIds.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CheckGroupMembersReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.CheckGroupMembersReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.CheckGroupMembersReq} CheckGroupMembersReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckGroupMembersReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CheckGroupMembersReq message.
         * @function verify
         * @memberof immessage.CheckGroupMembersReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CheckGroupMembersReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isString(message.groupId))
                    return "groupId: string expected";
            if (message.memberIds != null && message.hasOwnProperty("memberIds")) {
                if (!Array.isArray(message.memberIds))
                    return "memberIds: array expected";
                for (let i = 0; i < message.memberIds.length; ++i)
                    if (!$util.isString(message.memberIds[i]))
                        return "memberIds: string[] expected";
            }
            return null;
        };

        /**
         * Creates a CheckGroupMembersReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.CheckGroupMembersReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.CheckGroupMembersReq} CheckGroupMembersReq
         */
        CheckGroupMembersReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.CheckGroupMembersReq)
                return object;
            let message = new $root.immessage.CheckGroupMembersReq();
            if (object.groupId != null)
                message.groupId = String(object.groupId);
            if (object.memberIds) {
                if (!Array.isArray(object.memberIds))
                    throw TypeError(".immessage.CheckGroupMembersReq.memberIds: array expected");
                message.memberIds = [];
                for (let i = 0; i < object.memberIds.length; ++i)
                    message.memberIds[i] = String(object.memberIds[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a CheckGroupMembersReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.CheckGroupMembersReq
         * @static
         * @param {immessage.CheckGroupMembersReq} message CheckGroupMembersReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CheckGroupMembersReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.memberIds = [];
            if (options.defaults)
                object.groupId = "";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = message.groupId;
            if (message.memberIds && message.memberIds.length) {
                object.memberIds = [];
                for (let j = 0; j < message.memberIds.length; ++j)
                    object.memberIds[j] = message.memberIds[j];
            }
            return object;
        };

        /**
         * Converts this CheckGroupMembersReq to JSON.
         * @function toJSON
         * @memberof immessage.CheckGroupMembersReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CheckGroupMembersReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CheckGroupMembersReq
         * @function getTypeUrl
         * @memberof immessage.CheckGroupMembersReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CheckGroupMembersReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.CheckGroupMembersReq";
        };

        return CheckGroupMembersReq;
    })();

    immessage.CheckGroupMembersResp = (function() {

        /**
         * Properties of a CheckGroupMembersResp.
         * @memberof immessage
         * @interface ICheckGroupMembersResp
         * @property {Object.<string,number|Long>|null} [memberIdMap] CheckGroupMembersResp memberIdMap
         */

        /**
         * Constructs a new CheckGroupMembersResp.
         * @memberof immessage
         * @classdesc Represents a CheckGroupMembersResp.
         * @implements ICheckGroupMembersResp
         * @constructor
         * @param {immessage.ICheckGroupMembersResp=} [properties] Properties to set
         */
        function CheckGroupMembersResp(properties) {
            this.memberIdMap = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CheckGroupMembersResp memberIdMap.
         * @member {Object.<string,number|Long>} memberIdMap
         * @memberof immessage.CheckGroupMembersResp
         * @instance
         */
        CheckGroupMembersResp.prototype.memberIdMap = $util.emptyObject;

        /**
         * Creates a new CheckGroupMembersResp instance using the specified properties.
         * @function create
         * @memberof immessage.CheckGroupMembersResp
         * @static
         * @param {immessage.ICheckGroupMembersResp=} [properties] Properties to set
         * @returns {immessage.CheckGroupMembersResp} CheckGroupMembersResp instance
         */
        CheckGroupMembersResp.create = function create(properties) {
            return new CheckGroupMembersResp(properties);
        };

        /**
         * Encodes the specified CheckGroupMembersResp message. Does not implicitly {@link immessage.CheckGroupMembersResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.CheckGroupMembersResp
         * @static
         * @param {immessage.ICheckGroupMembersResp} message CheckGroupMembersResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckGroupMembersResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.memberIdMap != null && Object.hasOwnProperty.call(message, "memberIdMap"))
                for (let keys = Object.keys(message.memberIdMap), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.memberIdMap[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CheckGroupMembersResp message, length delimited. Does not implicitly {@link immessage.CheckGroupMembersResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.CheckGroupMembersResp
         * @static
         * @param {immessage.ICheckGroupMembersResp} message CheckGroupMembersResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckGroupMembersResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CheckGroupMembersResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.CheckGroupMembersResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.CheckGroupMembersResp} CheckGroupMembersResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckGroupMembersResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.CheckGroupMembersResp(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (message.memberIdMap === $util.emptyObject)
                            message.memberIdMap = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = 0;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.int64();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.memberIdMap[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CheckGroupMembersResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.CheckGroupMembersResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.CheckGroupMembersResp} CheckGroupMembersResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckGroupMembersResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CheckGroupMembersResp message.
         * @function verify
         * @memberof immessage.CheckGroupMembersResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CheckGroupMembersResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.memberIdMap != null && message.hasOwnProperty("memberIdMap")) {
                if (!$util.isObject(message.memberIdMap))
                    return "memberIdMap: object expected";
                let key = Object.keys(message.memberIdMap);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.memberIdMap[key[i]]) && !(message.memberIdMap[key[i]] && $util.isInteger(message.memberIdMap[key[i]].low) && $util.isInteger(message.memberIdMap[key[i]].high)))
                        return "memberIdMap: integer|Long{k:string} expected";
            }
            return null;
        };

        /**
         * Creates a CheckGroupMembersResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.CheckGroupMembersResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.CheckGroupMembersResp} CheckGroupMembersResp
         */
        CheckGroupMembersResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.CheckGroupMembersResp)
                return object;
            let message = new $root.immessage.CheckGroupMembersResp();
            if (object.memberIdMap) {
                if (typeof object.memberIdMap !== "object")
                    throw TypeError(".immessage.CheckGroupMembersResp.memberIdMap: object expected");
                message.memberIdMap = {};
                for (let keys = Object.keys(object.memberIdMap), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.memberIdMap[keys[i]] = $util.Long.fromValue(object.memberIdMap[keys[i]])).unsigned = false;
                    else if (typeof object.memberIdMap[keys[i]] === "string")
                        message.memberIdMap[keys[i]] = parseInt(object.memberIdMap[keys[i]], 10);
                    else if (typeof object.memberIdMap[keys[i]] === "number")
                        message.memberIdMap[keys[i]] = object.memberIdMap[keys[i]];
                    else if (typeof object.memberIdMap[keys[i]] === "object")
                        message.memberIdMap[keys[i]] = new $util.LongBits(object.memberIdMap[keys[i]].low >>> 0, object.memberIdMap[keys[i]].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a CheckGroupMembersResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.CheckGroupMembersResp
         * @static
         * @param {immessage.CheckGroupMembersResp} message CheckGroupMembersResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CheckGroupMembersResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.memberIdMap = {};
            let keys2;
            if (message.memberIdMap && (keys2 = Object.keys(message.memberIdMap)).length) {
                object.memberIdMap = {};
                for (let j = 0; j < keys2.length; ++j)
                    if (typeof message.memberIdMap[keys2[j]] === "number")
                        object.memberIdMap[keys2[j]] = options.longs === String ? String(message.memberIdMap[keys2[j]]) : message.memberIdMap[keys2[j]];
                    else
                        object.memberIdMap[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.memberIdMap[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.memberIdMap[keys2[j]].low >>> 0, message.memberIdMap[keys2[j]].high >>> 0).toNumber() : message.memberIdMap[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this CheckGroupMembersResp to JSON.
         * @function toJSON
         * @memberof immessage.CheckGroupMembersResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CheckGroupMembersResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CheckGroupMembersResp
         * @function getTypeUrl
         * @memberof immessage.CheckGroupMembersResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CheckGroupMembersResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.CheckGroupMembersResp";
        };

        return CheckGroupMembersResp;
    })();

    immessage.QryGrpSnapshotReq = (function() {

        /**
         * Properties of a QryGrpSnapshotReq.
         * @memberof immessage
         * @interface IQryGrpSnapshotReq
         * @property {string|null} [groupId] QryGrpSnapshotReq groupId
         * @property {number|Long|null} [nearlyTime] QryGrpSnapshotReq nearlyTime
         */

        /**
         * Constructs a new QryGrpSnapshotReq.
         * @memberof immessage
         * @classdesc Represents a QryGrpSnapshotReq.
         * @implements IQryGrpSnapshotReq
         * @constructor
         * @param {immessage.IQryGrpSnapshotReq=} [properties] Properties to set
         */
        function QryGrpSnapshotReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryGrpSnapshotReq groupId.
         * @member {string} groupId
         * @memberof immessage.QryGrpSnapshotReq
         * @instance
         */
        QryGrpSnapshotReq.prototype.groupId = "";

        /**
         * QryGrpSnapshotReq nearlyTime.
         * @member {number|Long} nearlyTime
         * @memberof immessage.QryGrpSnapshotReq
         * @instance
         */
        QryGrpSnapshotReq.prototype.nearlyTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new QryGrpSnapshotReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryGrpSnapshotReq
         * @static
         * @param {immessage.IQryGrpSnapshotReq=} [properties] Properties to set
         * @returns {immessage.QryGrpSnapshotReq} QryGrpSnapshotReq instance
         */
        QryGrpSnapshotReq.create = function create(properties) {
            return new QryGrpSnapshotReq(properties);
        };

        /**
         * Encodes the specified QryGrpSnapshotReq message. Does not implicitly {@link immessage.QryGrpSnapshotReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryGrpSnapshotReq
         * @static
         * @param {immessage.IQryGrpSnapshotReq} message QryGrpSnapshotReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryGrpSnapshotReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
            if (message.nearlyTime != null && Object.hasOwnProperty.call(message, "nearlyTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.nearlyTime);
            return writer;
        };

        /**
         * Encodes the specified QryGrpSnapshotReq message, length delimited. Does not implicitly {@link immessage.QryGrpSnapshotReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryGrpSnapshotReq
         * @static
         * @param {immessage.IQryGrpSnapshotReq} message QryGrpSnapshotReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryGrpSnapshotReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryGrpSnapshotReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryGrpSnapshotReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryGrpSnapshotReq} QryGrpSnapshotReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryGrpSnapshotReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryGrpSnapshotReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.groupId = reader.string();
                        break;
                    }
                case 2: {
                        message.nearlyTime = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryGrpSnapshotReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryGrpSnapshotReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryGrpSnapshotReq} QryGrpSnapshotReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryGrpSnapshotReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryGrpSnapshotReq message.
         * @function verify
         * @memberof immessage.QryGrpSnapshotReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryGrpSnapshotReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isString(message.groupId))
                    return "groupId: string expected";
            if (message.nearlyTime != null && message.hasOwnProperty("nearlyTime"))
                if (!$util.isInteger(message.nearlyTime) && !(message.nearlyTime && $util.isInteger(message.nearlyTime.low) && $util.isInteger(message.nearlyTime.high)))
                    return "nearlyTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a QryGrpSnapshotReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryGrpSnapshotReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryGrpSnapshotReq} QryGrpSnapshotReq
         */
        QryGrpSnapshotReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryGrpSnapshotReq)
                return object;
            let message = new $root.immessage.QryGrpSnapshotReq();
            if (object.groupId != null)
                message.groupId = String(object.groupId);
            if (object.nearlyTime != null)
                if ($util.Long)
                    (message.nearlyTime = $util.Long.fromValue(object.nearlyTime)).unsigned = false;
                else if (typeof object.nearlyTime === "string")
                    message.nearlyTime = parseInt(object.nearlyTime, 10);
                else if (typeof object.nearlyTime === "number")
                    message.nearlyTime = object.nearlyTime;
                else if (typeof object.nearlyTime === "object")
                    message.nearlyTime = new $util.LongBits(object.nearlyTime.low >>> 0, object.nearlyTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a QryGrpSnapshotReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryGrpSnapshotReq
         * @static
         * @param {immessage.QryGrpSnapshotReq} message QryGrpSnapshotReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryGrpSnapshotReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.groupId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.nearlyTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.nearlyTime = options.longs === String ? "0" : 0;
            }
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = message.groupId;
            if (message.nearlyTime != null && message.hasOwnProperty("nearlyTime"))
                if (typeof message.nearlyTime === "number")
                    object.nearlyTime = options.longs === String ? String(message.nearlyTime) : message.nearlyTime;
                else
                    object.nearlyTime = options.longs === String ? $util.Long.prototype.toString.call(message.nearlyTime) : options.longs === Number ? new $util.LongBits(message.nearlyTime.low >>> 0, message.nearlyTime.high >>> 0).toNumber() : message.nearlyTime;
            return object;
        };

        /**
         * Converts this QryGrpSnapshotReq to JSON.
         * @function toJSON
         * @memberof immessage.QryGrpSnapshotReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryGrpSnapshotReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryGrpSnapshotReq
         * @function getTypeUrl
         * @memberof immessage.QryGrpSnapshotReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryGrpSnapshotReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryGrpSnapshotReq";
        };

        return QryGrpSnapshotReq;
    })();

    immessage.GroupSnapshot = (function() {

        /**
         * Properties of a GroupSnapshot.
         * @memberof immessage
         * @interface IGroupSnapshot
         * @property {string|null} [groupId] GroupSnapshot groupId
         * @property {Array.<string>|null} [memberIds] GroupSnapshot memberIds
         */

        /**
         * Constructs a new GroupSnapshot.
         * @memberof immessage
         * @classdesc Represents a GroupSnapshot.
         * @implements IGroupSnapshot
         * @constructor
         * @param {immessage.IGroupSnapshot=} [properties] Properties to set
         */
        function GroupSnapshot(properties) {
            this.memberIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupSnapshot groupId.
         * @member {string} groupId
         * @memberof immessage.GroupSnapshot
         * @instance
         */
        GroupSnapshot.prototype.groupId = "";

        /**
         * GroupSnapshot memberIds.
         * @member {Array.<string>} memberIds
         * @memberof immessage.GroupSnapshot
         * @instance
         */
        GroupSnapshot.prototype.memberIds = $util.emptyArray;

        /**
         * Creates a new GroupSnapshot instance using the specified properties.
         * @function create
         * @memberof immessage.GroupSnapshot
         * @static
         * @param {immessage.IGroupSnapshot=} [properties] Properties to set
         * @returns {immessage.GroupSnapshot} GroupSnapshot instance
         */
        GroupSnapshot.create = function create(properties) {
            return new GroupSnapshot(properties);
        };

        /**
         * Encodes the specified GroupSnapshot message. Does not implicitly {@link immessage.GroupSnapshot.verify|verify} messages.
         * @function encode
         * @memberof immessage.GroupSnapshot
         * @static
         * @param {immessage.IGroupSnapshot} message GroupSnapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupSnapshot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
            if (message.memberIds != null && message.memberIds.length)
                for (let i = 0; i < message.memberIds.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.memberIds[i]);
            return writer;
        };

        /**
         * Encodes the specified GroupSnapshot message, length delimited. Does not implicitly {@link immessage.GroupSnapshot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.GroupSnapshot
         * @static
         * @param {immessage.IGroupSnapshot} message GroupSnapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupSnapshot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupSnapshot message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.GroupSnapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.GroupSnapshot} GroupSnapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupSnapshot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.GroupSnapshot();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.groupId = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.memberIds && message.memberIds.length))
                            message.memberIds = [];
                        message.memberIds.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupSnapshot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.GroupSnapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.GroupSnapshot} GroupSnapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupSnapshot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupSnapshot message.
         * @function verify
         * @memberof immessage.GroupSnapshot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupSnapshot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isString(message.groupId))
                    return "groupId: string expected";
            if (message.memberIds != null && message.hasOwnProperty("memberIds")) {
                if (!Array.isArray(message.memberIds))
                    return "memberIds: array expected";
                for (let i = 0; i < message.memberIds.length; ++i)
                    if (!$util.isString(message.memberIds[i]))
                        return "memberIds: string[] expected";
            }
            return null;
        };

        /**
         * Creates a GroupSnapshot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.GroupSnapshot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.GroupSnapshot} GroupSnapshot
         */
        GroupSnapshot.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.GroupSnapshot)
                return object;
            let message = new $root.immessage.GroupSnapshot();
            if (object.groupId != null)
                message.groupId = String(object.groupId);
            if (object.memberIds) {
                if (!Array.isArray(object.memberIds))
                    throw TypeError(".immessage.GroupSnapshot.memberIds: array expected");
                message.memberIds = [];
                for (let i = 0; i < object.memberIds.length; ++i)
                    message.memberIds[i] = String(object.memberIds[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupSnapshot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.GroupSnapshot
         * @static
         * @param {immessage.GroupSnapshot} message GroupSnapshot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupSnapshot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.memberIds = [];
            if (options.defaults)
                object.groupId = "";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = message.groupId;
            if (message.memberIds && message.memberIds.length) {
                object.memberIds = [];
                for (let j = 0; j < message.memberIds.length; ++j)
                    object.memberIds[j] = message.memberIds[j];
            }
            return object;
        };

        /**
         * Converts this GroupSnapshot to JSON.
         * @function toJSON
         * @memberof immessage.GroupSnapshot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupSnapshot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GroupSnapshot
         * @function getTypeUrl
         * @memberof immessage.GroupSnapshot
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GroupSnapshot.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.GroupSnapshot";
        };

        return GroupSnapshot;
    })();

    immessage.QryGrpMemberSettingsReq = (function() {

        /**
         * Properties of a QryGrpMemberSettingsReq.
         * @memberof immessage
         * @interface IQryGrpMemberSettingsReq
         * @property {string|null} [memberId] QryGrpMemberSettingsReq memberId
         */

        /**
         * Constructs a new QryGrpMemberSettingsReq.
         * @memberof immessage
         * @classdesc Represents a QryGrpMemberSettingsReq.
         * @implements IQryGrpMemberSettingsReq
         * @constructor
         * @param {immessage.IQryGrpMemberSettingsReq=} [properties] Properties to set
         */
        function QryGrpMemberSettingsReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryGrpMemberSettingsReq memberId.
         * @member {string} memberId
         * @memberof immessage.QryGrpMemberSettingsReq
         * @instance
         */
        QryGrpMemberSettingsReq.prototype.memberId = "";

        /**
         * Creates a new QryGrpMemberSettingsReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryGrpMemberSettingsReq
         * @static
         * @param {immessage.IQryGrpMemberSettingsReq=} [properties] Properties to set
         * @returns {immessage.QryGrpMemberSettingsReq} QryGrpMemberSettingsReq instance
         */
        QryGrpMemberSettingsReq.create = function create(properties) {
            return new QryGrpMemberSettingsReq(properties);
        };

        /**
         * Encodes the specified QryGrpMemberSettingsReq message. Does not implicitly {@link immessage.QryGrpMemberSettingsReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryGrpMemberSettingsReq
         * @static
         * @param {immessage.IQryGrpMemberSettingsReq} message QryGrpMemberSettingsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryGrpMemberSettingsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.memberId != null && Object.hasOwnProperty.call(message, "memberId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.memberId);
            return writer;
        };

        /**
         * Encodes the specified QryGrpMemberSettingsReq message, length delimited. Does not implicitly {@link immessage.QryGrpMemberSettingsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryGrpMemberSettingsReq
         * @static
         * @param {immessage.IQryGrpMemberSettingsReq} message QryGrpMemberSettingsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryGrpMemberSettingsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryGrpMemberSettingsReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryGrpMemberSettingsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryGrpMemberSettingsReq} QryGrpMemberSettingsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryGrpMemberSettingsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryGrpMemberSettingsReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.memberId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryGrpMemberSettingsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryGrpMemberSettingsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryGrpMemberSettingsReq} QryGrpMemberSettingsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryGrpMemberSettingsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryGrpMemberSettingsReq message.
         * @function verify
         * @memberof immessage.QryGrpMemberSettingsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryGrpMemberSettingsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.memberId != null && message.hasOwnProperty("memberId"))
                if (!$util.isString(message.memberId))
                    return "memberId: string expected";
            return null;
        };

        /**
         * Creates a QryGrpMemberSettingsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryGrpMemberSettingsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryGrpMemberSettingsReq} QryGrpMemberSettingsReq
         */
        QryGrpMemberSettingsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryGrpMemberSettingsReq)
                return object;
            let message = new $root.immessage.QryGrpMemberSettingsReq();
            if (object.memberId != null)
                message.memberId = String(object.memberId);
            return message;
        };

        /**
         * Creates a plain object from a QryGrpMemberSettingsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryGrpMemberSettingsReq
         * @static
         * @param {immessage.QryGrpMemberSettingsReq} message QryGrpMemberSettingsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryGrpMemberSettingsReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.memberId = "";
            if (message.memberId != null && message.hasOwnProperty("memberId"))
                object.memberId = message.memberId;
            return object;
        };

        /**
         * Converts this QryGrpMemberSettingsReq to JSON.
         * @function toJSON
         * @memberof immessage.QryGrpMemberSettingsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryGrpMemberSettingsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryGrpMemberSettingsReq
         * @function getTypeUrl
         * @memberof immessage.QryGrpMemberSettingsReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryGrpMemberSettingsReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryGrpMemberSettingsReq";
        };

        return QryGrpMemberSettingsReq;
    })();

    immessage.QryGrpMemberSettingsResp = (function() {

        /**
         * Properties of a QryGrpMemberSettingsResp.
         * @memberof immessage
         * @interface IQryGrpMemberSettingsResp
         * @property {string|null} [groupId] QryGrpMemberSettingsResp groupId
         * @property {string|null} [memberId] QryGrpMemberSettingsResp memberId
         * @property {boolean|null} [isMember] QryGrpMemberSettingsResp isMember
         * @property {number|Long|null} [joinTime] QryGrpMemberSettingsResp joinTime
         * @property {Object.<string,string>|null} [groupSettings] QryGrpMemberSettingsResp groupSettings
         * @property {Object.<string,string>|null} [memberSettings] QryGrpMemberSettingsResp memberSettings
         * @property {Object.<string,string>|null} [memberExts] QryGrpMemberSettingsResp memberExts
         */

        /**
         * Constructs a new QryGrpMemberSettingsResp.
         * @memberof immessage
         * @classdesc Represents a QryGrpMemberSettingsResp.
         * @implements IQryGrpMemberSettingsResp
         * @constructor
         * @param {immessage.IQryGrpMemberSettingsResp=} [properties] Properties to set
         */
        function QryGrpMemberSettingsResp(properties) {
            this.groupSettings = {};
            this.memberSettings = {};
            this.memberExts = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryGrpMemberSettingsResp groupId.
         * @member {string} groupId
         * @memberof immessage.QryGrpMemberSettingsResp
         * @instance
         */
        QryGrpMemberSettingsResp.prototype.groupId = "";

        /**
         * QryGrpMemberSettingsResp memberId.
         * @member {string} memberId
         * @memberof immessage.QryGrpMemberSettingsResp
         * @instance
         */
        QryGrpMemberSettingsResp.prototype.memberId = "";

        /**
         * QryGrpMemberSettingsResp isMember.
         * @member {boolean} isMember
         * @memberof immessage.QryGrpMemberSettingsResp
         * @instance
         */
        QryGrpMemberSettingsResp.prototype.isMember = false;

        /**
         * QryGrpMemberSettingsResp joinTime.
         * @member {number|Long} joinTime
         * @memberof immessage.QryGrpMemberSettingsResp
         * @instance
         */
        QryGrpMemberSettingsResp.prototype.joinTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QryGrpMemberSettingsResp groupSettings.
         * @member {Object.<string,string>} groupSettings
         * @memberof immessage.QryGrpMemberSettingsResp
         * @instance
         */
        QryGrpMemberSettingsResp.prototype.groupSettings = $util.emptyObject;

        /**
         * QryGrpMemberSettingsResp memberSettings.
         * @member {Object.<string,string>} memberSettings
         * @memberof immessage.QryGrpMemberSettingsResp
         * @instance
         */
        QryGrpMemberSettingsResp.prototype.memberSettings = $util.emptyObject;

        /**
         * QryGrpMemberSettingsResp memberExts.
         * @member {Object.<string,string>} memberExts
         * @memberof immessage.QryGrpMemberSettingsResp
         * @instance
         */
        QryGrpMemberSettingsResp.prototype.memberExts = $util.emptyObject;

        /**
         * Creates a new QryGrpMemberSettingsResp instance using the specified properties.
         * @function create
         * @memberof immessage.QryGrpMemberSettingsResp
         * @static
         * @param {immessage.IQryGrpMemberSettingsResp=} [properties] Properties to set
         * @returns {immessage.QryGrpMemberSettingsResp} QryGrpMemberSettingsResp instance
         */
        QryGrpMemberSettingsResp.create = function create(properties) {
            return new QryGrpMemberSettingsResp(properties);
        };

        /**
         * Encodes the specified QryGrpMemberSettingsResp message. Does not implicitly {@link immessage.QryGrpMemberSettingsResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryGrpMemberSettingsResp
         * @static
         * @param {immessage.IQryGrpMemberSettingsResp} message QryGrpMemberSettingsResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryGrpMemberSettingsResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
            if (message.memberId != null && Object.hasOwnProperty.call(message, "memberId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.memberId);
            if (message.isMember != null && Object.hasOwnProperty.call(message, "isMember"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isMember);
            if (message.joinTime != null && Object.hasOwnProperty.call(message, "joinTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.joinTime);
            if (message.groupSettings != null && Object.hasOwnProperty.call(message, "groupSettings"))
                for (let keys = Object.keys(message.groupSettings), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.groupSettings[keys[i]]).ldelim();
            if (message.memberSettings != null && Object.hasOwnProperty.call(message, "memberSettings"))
                for (let keys = Object.keys(message.memberSettings), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.memberSettings[keys[i]]).ldelim();
            if (message.memberExts != null && Object.hasOwnProperty.call(message, "memberExts"))
                for (let keys = Object.keys(message.memberExts), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.memberExts[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QryGrpMemberSettingsResp message, length delimited. Does not implicitly {@link immessage.QryGrpMemberSettingsResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryGrpMemberSettingsResp
         * @static
         * @param {immessage.IQryGrpMemberSettingsResp} message QryGrpMemberSettingsResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryGrpMemberSettingsResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryGrpMemberSettingsResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryGrpMemberSettingsResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryGrpMemberSettingsResp} QryGrpMemberSettingsResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryGrpMemberSettingsResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryGrpMemberSettingsResp(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.groupId = reader.string();
                        break;
                    }
                case 2: {
                        message.memberId = reader.string();
                        break;
                    }
                case 3: {
                        message.isMember = reader.bool();
                        break;
                    }
                case 4: {
                        message.joinTime = reader.int64();
                        break;
                    }
                case 5: {
                        if (message.groupSettings === $util.emptyObject)
                            message.groupSettings = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.groupSettings[key] = value;
                        break;
                    }
                case 6: {
                        if (message.memberSettings === $util.emptyObject)
                            message.memberSettings = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.memberSettings[key] = value;
                        break;
                    }
                case 7: {
                        if (message.memberExts === $util.emptyObject)
                            message.memberExts = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.memberExts[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryGrpMemberSettingsResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryGrpMemberSettingsResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryGrpMemberSettingsResp} QryGrpMemberSettingsResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryGrpMemberSettingsResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryGrpMemberSettingsResp message.
         * @function verify
         * @memberof immessage.QryGrpMemberSettingsResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryGrpMemberSettingsResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isString(message.groupId))
                    return "groupId: string expected";
            if (message.memberId != null && message.hasOwnProperty("memberId"))
                if (!$util.isString(message.memberId))
                    return "memberId: string expected";
            if (message.isMember != null && message.hasOwnProperty("isMember"))
                if (typeof message.isMember !== "boolean")
                    return "isMember: boolean expected";
            if (message.joinTime != null && message.hasOwnProperty("joinTime"))
                if (!$util.isInteger(message.joinTime) && !(message.joinTime && $util.isInteger(message.joinTime.low) && $util.isInteger(message.joinTime.high)))
                    return "joinTime: integer|Long expected";
            if (message.groupSettings != null && message.hasOwnProperty("groupSettings")) {
                if (!$util.isObject(message.groupSettings))
                    return "groupSettings: object expected";
                let key = Object.keys(message.groupSettings);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.groupSettings[key[i]]))
                        return "groupSettings: string{k:string} expected";
            }
            if (message.memberSettings != null && message.hasOwnProperty("memberSettings")) {
                if (!$util.isObject(message.memberSettings))
                    return "memberSettings: object expected";
                let key = Object.keys(message.memberSettings);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.memberSettings[key[i]]))
                        return "memberSettings: string{k:string} expected";
            }
            if (message.memberExts != null && message.hasOwnProperty("memberExts")) {
                if (!$util.isObject(message.memberExts))
                    return "memberExts: object expected";
                let key = Object.keys(message.memberExts);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.memberExts[key[i]]))
                        return "memberExts: string{k:string} expected";
            }
            return null;
        };

        /**
         * Creates a QryGrpMemberSettingsResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryGrpMemberSettingsResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryGrpMemberSettingsResp} QryGrpMemberSettingsResp
         */
        QryGrpMemberSettingsResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryGrpMemberSettingsResp)
                return object;
            let message = new $root.immessage.QryGrpMemberSettingsResp();
            if (object.groupId != null)
                message.groupId = String(object.groupId);
            if (object.memberId != null)
                message.memberId = String(object.memberId);
            if (object.isMember != null)
                message.isMember = Boolean(object.isMember);
            if (object.joinTime != null)
                if ($util.Long)
                    (message.joinTime = $util.Long.fromValue(object.joinTime)).unsigned = false;
                else if (typeof object.joinTime === "string")
                    message.joinTime = parseInt(object.joinTime, 10);
                else if (typeof object.joinTime === "number")
                    message.joinTime = object.joinTime;
                else if (typeof object.joinTime === "object")
                    message.joinTime = new $util.LongBits(object.joinTime.low >>> 0, object.joinTime.high >>> 0).toNumber();
            if (object.groupSettings) {
                if (typeof object.groupSettings !== "object")
                    throw TypeError(".immessage.QryGrpMemberSettingsResp.groupSettings: object expected");
                message.groupSettings = {};
                for (let keys = Object.keys(object.groupSettings), i = 0; i < keys.length; ++i)
                    message.groupSettings[keys[i]] = String(object.groupSettings[keys[i]]);
            }
            if (object.memberSettings) {
                if (typeof object.memberSettings !== "object")
                    throw TypeError(".immessage.QryGrpMemberSettingsResp.memberSettings: object expected");
                message.memberSettings = {};
                for (let keys = Object.keys(object.memberSettings), i = 0; i < keys.length; ++i)
                    message.memberSettings[keys[i]] = String(object.memberSettings[keys[i]]);
            }
            if (object.memberExts) {
                if (typeof object.memberExts !== "object")
                    throw TypeError(".immessage.QryGrpMemberSettingsResp.memberExts: object expected");
                message.memberExts = {};
                for (let keys = Object.keys(object.memberExts), i = 0; i < keys.length; ++i)
                    message.memberExts[keys[i]] = String(object.memberExts[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from a QryGrpMemberSettingsResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryGrpMemberSettingsResp
         * @static
         * @param {immessage.QryGrpMemberSettingsResp} message QryGrpMemberSettingsResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryGrpMemberSettingsResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults) {
                object.groupSettings = {};
                object.memberSettings = {};
                object.memberExts = {};
            }
            if (options.defaults) {
                object.groupId = "";
                object.memberId = "";
                object.isMember = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.joinTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.joinTime = options.longs === String ? "0" : 0;
            }
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = message.groupId;
            if (message.memberId != null && message.hasOwnProperty("memberId"))
                object.memberId = message.memberId;
            if (message.isMember != null && message.hasOwnProperty("isMember"))
                object.isMember = message.isMember;
            if (message.joinTime != null && message.hasOwnProperty("joinTime"))
                if (typeof message.joinTime === "number")
                    object.joinTime = options.longs === String ? String(message.joinTime) : message.joinTime;
                else
                    object.joinTime = options.longs === String ? $util.Long.prototype.toString.call(message.joinTime) : options.longs === Number ? new $util.LongBits(message.joinTime.low >>> 0, message.joinTime.high >>> 0).toNumber() : message.joinTime;
            let keys2;
            if (message.groupSettings && (keys2 = Object.keys(message.groupSettings)).length) {
                object.groupSettings = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.groupSettings[keys2[j]] = message.groupSettings[keys2[j]];
            }
            if (message.memberSettings && (keys2 = Object.keys(message.memberSettings)).length) {
                object.memberSettings = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.memberSettings[keys2[j]] = message.memberSettings[keys2[j]];
            }
            if (message.memberExts && (keys2 = Object.keys(message.memberExts)).length) {
                object.memberExts = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.memberExts[keys2[j]] = message.memberExts[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this QryGrpMemberSettingsResp to JSON.
         * @function toJSON
         * @memberof immessage.QryGrpMemberSettingsResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryGrpMemberSettingsResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryGrpMemberSettingsResp
         * @function getTypeUrl
         * @memberof immessage.QryGrpMemberSettingsResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryGrpMemberSettingsResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryGrpMemberSettingsResp";
        };

        return QryGrpMemberSettingsResp;
    })();

    immessage.QryFileCredReq = (function() {

        /**
         * Properties of a QryFileCredReq.
         * @memberof immessage
         * @interface IQryFileCredReq
         * @property {immessage.FileType|null} [fileType] QryFileCredReq fileType
         * @property {string|null} [ext] QryFileCredReq ext
         */

        /**
         * Constructs a new QryFileCredReq.
         * @memberof immessage
         * @classdesc Represents a QryFileCredReq.
         * @implements IQryFileCredReq
         * @constructor
         * @param {immessage.IQryFileCredReq=} [properties] Properties to set
         */
        function QryFileCredReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryFileCredReq fileType.
         * @member {immessage.FileType} fileType
         * @memberof immessage.QryFileCredReq
         * @instance
         */
        QryFileCredReq.prototype.fileType = 0;

        /**
         * QryFileCredReq ext.
         * @member {string} ext
         * @memberof immessage.QryFileCredReq
         * @instance
         */
        QryFileCredReq.prototype.ext = "";

        /**
         * Creates a new QryFileCredReq instance using the specified properties.
         * @function create
         * @memberof immessage.QryFileCredReq
         * @static
         * @param {immessage.IQryFileCredReq=} [properties] Properties to set
         * @returns {immessage.QryFileCredReq} QryFileCredReq instance
         */
        QryFileCredReq.create = function create(properties) {
            return new QryFileCredReq(properties);
        };

        /**
         * Encodes the specified QryFileCredReq message. Does not implicitly {@link immessage.QryFileCredReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryFileCredReq
         * @static
         * @param {immessage.IQryFileCredReq} message QryFileCredReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryFileCredReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileType != null && Object.hasOwnProperty.call(message, "fileType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fileType);
            if (message.ext != null && Object.hasOwnProperty.call(message, "ext"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ext);
            return writer;
        };

        /**
         * Encodes the specified QryFileCredReq message, length delimited. Does not implicitly {@link immessage.QryFileCredReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryFileCredReq
         * @static
         * @param {immessage.IQryFileCredReq} message QryFileCredReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryFileCredReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryFileCredReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryFileCredReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryFileCredReq} QryFileCredReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryFileCredReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryFileCredReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.fileType = reader.int32();
                        break;
                    }
                case 2: {
                        message.ext = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryFileCredReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryFileCredReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryFileCredReq} QryFileCredReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryFileCredReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryFileCredReq message.
         * @function verify
         * @memberof immessage.QryFileCredReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryFileCredReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileType != null && message.hasOwnProperty("fileType"))
                switch (message.fileType) {
                default:
                    return "fileType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.ext != null && message.hasOwnProperty("ext"))
                if (!$util.isString(message.ext))
                    return "ext: string expected";
            return null;
        };

        /**
         * Creates a QryFileCredReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryFileCredReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryFileCredReq} QryFileCredReq
         */
        QryFileCredReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryFileCredReq)
                return object;
            let message = new $root.immessage.QryFileCredReq();
            switch (object.fileType) {
            default:
                if (typeof object.fileType === "number") {
                    message.fileType = object.fileType;
                    break;
                }
                break;
            case "DefaultFileType":
            case 0:
                message.fileType = 0;
                break;
            case "Image":
            case 1:
                message.fileType = 1;
                break;
            case "Audio":
            case 2:
                message.fileType = 2;
                break;
            case "Video":
            case 3:
                message.fileType = 3;
                break;
            case "File":
            case 4:
                message.fileType = 4;
                break;
            case "Log":
            case 5:
                message.fileType = 5;
                break;
            }
            if (object.ext != null)
                message.ext = String(object.ext);
            return message;
        };

        /**
         * Creates a plain object from a QryFileCredReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryFileCredReq
         * @static
         * @param {immessage.QryFileCredReq} message QryFileCredReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryFileCredReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.fileType = options.enums === String ? "DefaultFileType" : 0;
                object.ext = "";
            }
            if (message.fileType != null && message.hasOwnProperty("fileType"))
                object.fileType = options.enums === String ? $root.immessage.FileType[message.fileType] === undefined ? message.fileType : $root.immessage.FileType[message.fileType] : message.fileType;
            if (message.ext != null && message.hasOwnProperty("ext"))
                object.ext = message.ext;
            return object;
        };

        /**
         * Converts this QryFileCredReq to JSON.
         * @function toJSON
         * @memberof immessage.QryFileCredReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryFileCredReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryFileCredReq
         * @function getTypeUrl
         * @memberof immessage.QryFileCredReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryFileCredReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryFileCredReq";
        };

        return QryFileCredReq;
    })();

    /**
     * FileType enum.
     * @name immessage.FileType
     * @enum {number}
     * @property {number} DefaultFileType=0 DefaultFileType value
     * @property {number} Image=1 Image value
     * @property {number} Audio=2 Audio value
     * @property {number} Video=3 Video value
     * @property {number} File=4 File value
     * @property {number} Log=5 Log value
     */
    immessage.FileType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DefaultFileType"] = 0;
        values[valuesById[1] = "Image"] = 1;
        values[valuesById[2] = "Audio"] = 2;
        values[valuesById[3] = "Video"] = 3;
        values[valuesById[4] = "File"] = 4;
        values[valuesById[5] = "Log"] = 5;
        return values;
    })();

    immessage.QryFileCredResp = (function() {

        /**
         * Properties of a QryFileCredResp.
         * @memberof immessage
         * @interface IQryFileCredResp
         * @property {immessage.OssType|null} [ossType] QryFileCredResp ossType
         * @property {immessage.IQiNiuCredResp|null} [qiniuCred] QryFileCredResp qiniuCred
         * @property {immessage.IPreSignResp|null} [preSignResp] QryFileCredResp preSignResp
         */

        /**
         * Constructs a new QryFileCredResp.
         * @memberof immessage
         * @classdesc Represents a QryFileCredResp.
         * @implements IQryFileCredResp
         * @constructor
         * @param {immessage.IQryFileCredResp=} [properties] Properties to set
         */
        function QryFileCredResp(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QryFileCredResp ossType.
         * @member {immessage.OssType} ossType
         * @memberof immessage.QryFileCredResp
         * @instance
         */
        QryFileCredResp.prototype.ossType = 0;

        /**
         * QryFileCredResp qiniuCred.
         * @member {immessage.IQiNiuCredResp|null|undefined} qiniuCred
         * @memberof immessage.QryFileCredResp
         * @instance
         */
        QryFileCredResp.prototype.qiniuCred = null;

        /**
         * QryFileCredResp preSignResp.
         * @member {immessage.IPreSignResp|null|undefined} preSignResp
         * @memberof immessage.QryFileCredResp
         * @instance
         */
        QryFileCredResp.prototype.preSignResp = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * QryFileCredResp ossOf.
         * @member {"qiniuCred"|"preSignResp"|undefined} ossOf
         * @memberof immessage.QryFileCredResp
         * @instance
         */
        Object.defineProperty(QryFileCredResp.prototype, "ossOf", {
            get: $util.oneOfGetter($oneOfFields = ["qiniuCred", "preSignResp"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new QryFileCredResp instance using the specified properties.
         * @function create
         * @memberof immessage.QryFileCredResp
         * @static
         * @param {immessage.IQryFileCredResp=} [properties] Properties to set
         * @returns {immessage.QryFileCredResp} QryFileCredResp instance
         */
        QryFileCredResp.create = function create(properties) {
            return new QryFileCredResp(properties);
        };

        /**
         * Encodes the specified QryFileCredResp message. Does not implicitly {@link immessage.QryFileCredResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.QryFileCredResp
         * @static
         * @param {immessage.IQryFileCredResp} message QryFileCredResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryFileCredResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ossType != null && Object.hasOwnProperty.call(message, "ossType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ossType);
            if (message.qiniuCred != null && Object.hasOwnProperty.call(message, "qiniuCred"))
                $root.immessage.QiNiuCredResp.encode(message.qiniuCred, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.preSignResp != null && Object.hasOwnProperty.call(message, "preSignResp"))
                $root.immessage.PreSignResp.encode(message.preSignResp, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QryFileCredResp message, length delimited. Does not implicitly {@link immessage.QryFileCredResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QryFileCredResp
         * @static
         * @param {immessage.IQryFileCredResp} message QryFileCredResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QryFileCredResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QryFileCredResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QryFileCredResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QryFileCredResp} QryFileCredResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryFileCredResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QryFileCredResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.ossType = reader.int32();
                        break;
                    }
                case 11: {
                        message.qiniuCred = $root.immessage.QiNiuCredResp.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.preSignResp = $root.immessage.PreSignResp.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QryFileCredResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QryFileCredResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QryFileCredResp} QryFileCredResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QryFileCredResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QryFileCredResp message.
         * @function verify
         * @memberof immessage.QryFileCredResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QryFileCredResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.ossType != null && message.hasOwnProperty("ossType"))
                switch (message.ossType) {
                default:
                    return "ossType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.qiniuCred != null && message.hasOwnProperty("qiniuCred")) {
                properties.ossOf = 1;
                {
                    let error = $root.immessage.QiNiuCredResp.verify(message.qiniuCred);
                    if (error)
                        return "qiniuCred." + error;
                }
            }
            if (message.preSignResp != null && message.hasOwnProperty("preSignResp")) {
                if (properties.ossOf === 1)
                    return "ossOf: multiple values";
                properties.ossOf = 1;
                {
                    let error = $root.immessage.PreSignResp.verify(message.preSignResp);
                    if (error)
                        return "preSignResp." + error;
                }
            }
            return null;
        };

        /**
         * Creates a QryFileCredResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QryFileCredResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QryFileCredResp} QryFileCredResp
         */
        QryFileCredResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QryFileCredResp)
                return object;
            let message = new $root.immessage.QryFileCredResp();
            switch (object.ossType) {
            default:
                if (typeof object.ossType === "number") {
                    message.ossType = object.ossType;
                    break;
                }
                break;
            case "DefaultOss":
            case 0:
                message.ossType = 0;
                break;
            case "QiNiu":
            case 1:
                message.ossType = 1;
                break;
            case "S3":
            case 2:
                message.ossType = 2;
                break;
            case "Minio":
            case 3:
                message.ossType = 3;
                break;
            case "Oss":
            case 4:
                message.ossType = 4;
                break;
            }
            if (object.qiniuCred != null) {
                if (typeof object.qiniuCred !== "object")
                    throw TypeError(".immessage.QryFileCredResp.qiniuCred: object expected");
                message.qiniuCred = $root.immessage.QiNiuCredResp.fromObject(object.qiniuCred);
            }
            if (object.preSignResp != null) {
                if (typeof object.preSignResp !== "object")
                    throw TypeError(".immessage.QryFileCredResp.preSignResp: object expected");
                message.preSignResp = $root.immessage.PreSignResp.fromObject(object.preSignResp);
            }
            return message;
        };

        /**
         * Creates a plain object from a QryFileCredResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QryFileCredResp
         * @static
         * @param {immessage.QryFileCredResp} message QryFileCredResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QryFileCredResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.ossType = options.enums === String ? "DefaultOss" : 0;
            if (message.ossType != null && message.hasOwnProperty("ossType"))
                object.ossType = options.enums === String ? $root.immessage.OssType[message.ossType] === undefined ? message.ossType : $root.immessage.OssType[message.ossType] : message.ossType;
            if (message.qiniuCred != null && message.hasOwnProperty("qiniuCred")) {
                object.qiniuCred = $root.immessage.QiNiuCredResp.toObject(message.qiniuCred, options);
                if (options.oneofs)
                    object.ossOf = "qiniuCred";
            }
            if (message.preSignResp != null && message.hasOwnProperty("preSignResp")) {
                object.preSignResp = $root.immessage.PreSignResp.toObject(message.preSignResp, options);
                if (options.oneofs)
                    object.ossOf = "preSignResp";
            }
            return object;
        };

        /**
         * Converts this QryFileCredResp to JSON.
         * @function toJSON
         * @memberof immessage.QryFileCredResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QryFileCredResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QryFileCredResp
         * @function getTypeUrl
         * @memberof immessage.QryFileCredResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QryFileCredResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QryFileCredResp";
        };

        return QryFileCredResp;
    })();

    /**
     * OssType enum.
     * @name immessage.OssType
     * @enum {number}
     * @property {number} DefaultOss=0 DefaultOss value
     * @property {number} QiNiu=1 QiNiu value
     * @property {number} S3=2 S3 value
     * @property {number} Minio=3 Minio value
     * @property {number} Oss=4 Oss value
     */
    immessage.OssType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DefaultOss"] = 0;
        values[valuesById[1] = "QiNiu"] = 1;
        values[valuesById[2] = "S3"] = 2;
        values[valuesById[3] = "Minio"] = 3;
        values[valuesById[4] = "Oss"] = 4;
        return values;
    })();

    immessage.QiNiuCredResp = (function() {

        /**
         * Properties of a QiNiuCredResp.
         * @memberof immessage
         * @interface IQiNiuCredResp
         * @property {string|null} [domain] QiNiuCredResp domain
         * @property {string|null} [token] QiNiuCredResp token
         */

        /**
         * Constructs a new QiNiuCredResp.
         * @memberof immessage
         * @classdesc Represents a QiNiuCredResp.
         * @implements IQiNiuCredResp
         * @constructor
         * @param {immessage.IQiNiuCredResp=} [properties] Properties to set
         */
        function QiNiuCredResp(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QiNiuCredResp domain.
         * @member {string} domain
         * @memberof immessage.QiNiuCredResp
         * @instance
         */
        QiNiuCredResp.prototype.domain = "";

        /**
         * QiNiuCredResp token.
         * @member {string} token
         * @memberof immessage.QiNiuCredResp
         * @instance
         */
        QiNiuCredResp.prototype.token = "";

        /**
         * Creates a new QiNiuCredResp instance using the specified properties.
         * @function create
         * @memberof immessage.QiNiuCredResp
         * @static
         * @param {immessage.IQiNiuCredResp=} [properties] Properties to set
         * @returns {immessage.QiNiuCredResp} QiNiuCredResp instance
         */
        QiNiuCredResp.create = function create(properties) {
            return new QiNiuCredResp(properties);
        };

        /**
         * Encodes the specified QiNiuCredResp message. Does not implicitly {@link immessage.QiNiuCredResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.QiNiuCredResp
         * @static
         * @param {immessage.IQiNiuCredResp} message QiNiuCredResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QiNiuCredResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.domain);
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
            return writer;
        };

        /**
         * Encodes the specified QiNiuCredResp message, length delimited. Does not implicitly {@link immessage.QiNiuCredResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.QiNiuCredResp
         * @static
         * @param {immessage.IQiNiuCredResp} message QiNiuCredResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QiNiuCredResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QiNiuCredResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.QiNiuCredResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.QiNiuCredResp} QiNiuCredResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QiNiuCredResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.QiNiuCredResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.domain = reader.string();
                        break;
                    }
                case 2: {
                        message.token = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QiNiuCredResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.QiNiuCredResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.QiNiuCredResp} QiNiuCredResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QiNiuCredResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QiNiuCredResp message.
         * @function verify
         * @memberof immessage.QiNiuCredResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QiNiuCredResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.domain != null && message.hasOwnProperty("domain"))
                if (!$util.isString(message.domain))
                    return "domain: string expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!$util.isString(message.token))
                    return "token: string expected";
            return null;
        };

        /**
         * Creates a QiNiuCredResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.QiNiuCredResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.QiNiuCredResp} QiNiuCredResp
         */
        QiNiuCredResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.QiNiuCredResp)
                return object;
            let message = new $root.immessage.QiNiuCredResp();
            if (object.domain != null)
                message.domain = String(object.domain);
            if (object.token != null)
                message.token = String(object.token);
            return message;
        };

        /**
         * Creates a plain object from a QiNiuCredResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.QiNiuCredResp
         * @static
         * @param {immessage.QiNiuCredResp} message QiNiuCredResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QiNiuCredResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.domain = "";
                object.token = "";
            }
            if (message.domain != null && message.hasOwnProperty("domain"))
                object.domain = message.domain;
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = message.token;
            return object;
        };

        /**
         * Converts this QiNiuCredResp to JSON.
         * @function toJSON
         * @memberof immessage.QiNiuCredResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QiNiuCredResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QiNiuCredResp
         * @function getTypeUrl
         * @memberof immessage.QiNiuCredResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QiNiuCredResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.QiNiuCredResp";
        };

        return QiNiuCredResp;
    })();

    immessage.PreSignResp = (function() {

        /**
         * Properties of a PreSignResp.
         * @memberof immessage
         * @interface IPreSignResp
         * @property {string|null} [url] PreSignResp url
         * @property {string|null} [objKey] PreSignResp objKey
         * @property {string|null} [policy] PreSignResp policy
         * @property {string|null} [signVersion] PreSignResp signVersion
         * @property {string|null} [credential] PreSignResp credential
         * @property {string|null} [date] PreSignResp date
         * @property {string|null} [signature] PreSignResp signature
         */

        /**
         * Constructs a new PreSignResp.
         * @memberof immessage
         * @classdesc Represents a PreSignResp.
         * @implements IPreSignResp
         * @constructor
         * @param {immessage.IPreSignResp=} [properties] Properties to set
         */
        function PreSignResp(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PreSignResp url.
         * @member {string} url
         * @memberof immessage.PreSignResp
         * @instance
         */
        PreSignResp.prototype.url = "";

        /**
         * PreSignResp objKey.
         * @member {string} objKey
         * @memberof immessage.PreSignResp
         * @instance
         */
        PreSignResp.prototype.objKey = "";

        /**
         * PreSignResp policy.
         * @member {string} policy
         * @memberof immessage.PreSignResp
         * @instance
         */
        PreSignResp.prototype.policy = "";

        /**
         * PreSignResp signVersion.
         * @member {string} signVersion
         * @memberof immessage.PreSignResp
         * @instance
         */
        PreSignResp.prototype.signVersion = "";

        /**
         * PreSignResp credential.
         * @member {string} credential
         * @memberof immessage.PreSignResp
         * @instance
         */
        PreSignResp.prototype.credential = "";

        /**
         * PreSignResp date.
         * @member {string} date
         * @memberof immessage.PreSignResp
         * @instance
         */
        PreSignResp.prototype.date = "";

        /**
         * PreSignResp signature.
         * @member {string} signature
         * @memberof immessage.PreSignResp
         * @instance
         */
        PreSignResp.prototype.signature = "";

        /**
         * Creates a new PreSignResp instance using the specified properties.
         * @function create
         * @memberof immessage.PreSignResp
         * @static
         * @param {immessage.IPreSignResp=} [properties] Properties to set
         * @returns {immessage.PreSignResp} PreSignResp instance
         */
        PreSignResp.create = function create(properties) {
            return new PreSignResp(properties);
        };

        /**
         * Encodes the specified PreSignResp message. Does not implicitly {@link immessage.PreSignResp.verify|verify} messages.
         * @function encode
         * @memberof immessage.PreSignResp
         * @static
         * @param {immessage.IPreSignResp} message PreSignResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreSignResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
            if (message.objKey != null && Object.hasOwnProperty.call(message, "objKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.objKey);
            if (message.policy != null && Object.hasOwnProperty.call(message, "policy"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.policy);
            if (message.signVersion != null && Object.hasOwnProperty.call(message, "signVersion"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.signVersion);
            if (message.credential != null && Object.hasOwnProperty.call(message, "credential"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.credential);
            if (message.date != null && Object.hasOwnProperty.call(message, "date"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.date);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.signature);
            return writer;
        };

        /**
         * Encodes the specified PreSignResp message, length delimited. Does not implicitly {@link immessage.PreSignResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.PreSignResp
         * @static
         * @param {immessage.IPreSignResp} message PreSignResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreSignResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PreSignResp message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.PreSignResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.PreSignResp} PreSignResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreSignResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.PreSignResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.url = reader.string();
                        break;
                    }
                case 2: {
                        message.objKey = reader.string();
                        break;
                    }
                case 3: {
                        message.policy = reader.string();
                        break;
                    }
                case 4: {
                        message.signVersion = reader.string();
                        break;
                    }
                case 5: {
                        message.credential = reader.string();
                        break;
                    }
                case 6: {
                        message.date = reader.string();
                        break;
                    }
                case 7: {
                        message.signature = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PreSignResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.PreSignResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.PreSignResp} PreSignResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreSignResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PreSignResp message.
         * @function verify
         * @memberof immessage.PreSignResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PreSignResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.objKey != null && message.hasOwnProperty("objKey"))
                if (!$util.isString(message.objKey))
                    return "objKey: string expected";
            if (message.policy != null && message.hasOwnProperty("policy"))
                if (!$util.isString(message.policy))
                    return "policy: string expected";
            if (message.signVersion != null && message.hasOwnProperty("signVersion"))
                if (!$util.isString(message.signVersion))
                    return "signVersion: string expected";
            if (message.credential != null && message.hasOwnProperty("credential"))
                if (!$util.isString(message.credential))
                    return "credential: string expected";
            if (message.date != null && message.hasOwnProperty("date"))
                if (!$util.isString(message.date))
                    return "date: string expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!$util.isString(message.signature))
                    return "signature: string expected";
            return null;
        };

        /**
         * Creates a PreSignResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.PreSignResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.PreSignResp} PreSignResp
         */
        PreSignResp.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.PreSignResp)
                return object;
            let message = new $root.immessage.PreSignResp();
            if (object.url != null)
                message.url = String(object.url);
            if (object.objKey != null)
                message.objKey = String(object.objKey);
            if (object.policy != null)
                message.policy = String(object.policy);
            if (object.signVersion != null)
                message.signVersion = String(object.signVersion);
            if (object.credential != null)
                message.credential = String(object.credential);
            if (object.date != null)
                message.date = String(object.date);
            if (object.signature != null)
                message.signature = String(object.signature);
            return message;
        };

        /**
         * Creates a plain object from a PreSignResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.PreSignResp
         * @static
         * @param {immessage.PreSignResp} message PreSignResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PreSignResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.url = "";
                object.objKey = "";
                object.policy = "";
                object.signVersion = "";
                object.credential = "";
                object.date = "";
                object.signature = "";
            }
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.objKey != null && message.hasOwnProperty("objKey"))
                object.objKey = message.objKey;
            if (message.policy != null && message.hasOwnProperty("policy"))
                object.policy = message.policy;
            if (message.signVersion != null && message.hasOwnProperty("signVersion"))
                object.signVersion = message.signVersion;
            if (message.credential != null && message.hasOwnProperty("credential"))
                object.credential = message.credential;
            if (message.date != null && message.hasOwnProperty("date"))
                object.date = message.date;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = message.signature;
            return object;
        };

        /**
         * Converts this PreSignResp to JSON.
         * @function toJSON
         * @memberof immessage.PreSignResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PreSignResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PreSignResp
         * @function getTypeUrl
         * @memberof immessage.PreSignResp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PreSignResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.PreSignResp";
        };

        return PreSignResp;
    })();

    immessage.UploadLogStatusReq = (function() {

        /**
         * Properties of an UploadLogStatusReq.
         * @memberof immessage
         * @interface IUploadLogStatusReq
         * @property {string|null} [msgId] UploadLogStatusReq msgId
         * @property {string|null} [logUrl] UploadLogStatusReq logUrl
         * @property {number|null} [state] UploadLogStatusReq state
         */

        /**
         * Constructs a new UploadLogStatusReq.
         * @memberof immessage
         * @classdesc Represents an UploadLogStatusReq.
         * @implements IUploadLogStatusReq
         * @constructor
         * @param {immessage.IUploadLogStatusReq=} [properties] Properties to set
         */
        function UploadLogStatusReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UploadLogStatusReq msgId.
         * @member {string} msgId
         * @memberof immessage.UploadLogStatusReq
         * @instance
         */
        UploadLogStatusReq.prototype.msgId = "";

        /**
         * UploadLogStatusReq logUrl.
         * @member {string} logUrl
         * @memberof immessage.UploadLogStatusReq
         * @instance
         */
        UploadLogStatusReq.prototype.logUrl = "";

        /**
         * UploadLogStatusReq state.
         * @member {number} state
         * @memberof immessage.UploadLogStatusReq
         * @instance
         */
        UploadLogStatusReq.prototype.state = 0;

        /**
         * Creates a new UploadLogStatusReq instance using the specified properties.
         * @function create
         * @memberof immessage.UploadLogStatusReq
         * @static
         * @param {immessage.IUploadLogStatusReq=} [properties] Properties to set
         * @returns {immessage.UploadLogStatusReq} UploadLogStatusReq instance
         */
        UploadLogStatusReq.create = function create(properties) {
            return new UploadLogStatusReq(properties);
        };

        /**
         * Encodes the specified UploadLogStatusReq message. Does not implicitly {@link immessage.UploadLogStatusReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.UploadLogStatusReq
         * @static
         * @param {immessage.IUploadLogStatusReq} message UploadLogStatusReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UploadLogStatusReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.msgId);
            if (message.logUrl != null && Object.hasOwnProperty.call(message, "logUrl"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.logUrl);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.state);
            return writer;
        };

        /**
         * Encodes the specified UploadLogStatusReq message, length delimited. Does not implicitly {@link immessage.UploadLogStatusReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.UploadLogStatusReq
         * @static
         * @param {immessage.IUploadLogStatusReq} message UploadLogStatusReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UploadLogStatusReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UploadLogStatusReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.UploadLogStatusReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.UploadLogStatusReq} UploadLogStatusReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UploadLogStatusReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.UploadLogStatusReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.msgId = reader.string();
                        break;
                    }
                case 2: {
                        message.logUrl = reader.string();
                        break;
                    }
                case 3: {
                        message.state = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UploadLogStatusReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.UploadLogStatusReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.UploadLogStatusReq} UploadLogStatusReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UploadLogStatusReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UploadLogStatusReq message.
         * @function verify
         * @memberof immessage.UploadLogStatusReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UploadLogStatusReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            if (message.logUrl != null && message.hasOwnProperty("logUrl"))
                if (!$util.isString(message.logUrl))
                    return "logUrl: string expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (!$util.isInteger(message.state))
                    return "state: integer expected";
            return null;
        };

        /**
         * Creates an UploadLogStatusReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.UploadLogStatusReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.UploadLogStatusReq} UploadLogStatusReq
         */
        UploadLogStatusReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.UploadLogStatusReq)
                return object;
            let message = new $root.immessage.UploadLogStatusReq();
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            if (object.logUrl != null)
                message.logUrl = String(object.logUrl);
            if (object.state != null)
                message.state = object.state | 0;
            return message;
        };

        /**
         * Creates a plain object from an UploadLogStatusReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.UploadLogStatusReq
         * @static
         * @param {immessage.UploadLogStatusReq} message UploadLogStatusReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UploadLogStatusReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.msgId = "";
                object.logUrl = "";
                object.state = 0;
            }
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            if (message.logUrl != null && message.hasOwnProperty("logUrl"))
                object.logUrl = message.logUrl;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            return object;
        };

        /**
         * Converts this UploadLogStatusReq to JSON.
         * @function toJSON
         * @memberof immessage.UploadLogStatusReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UploadLogStatusReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UploadLogStatusReq
         * @function getTypeUrl
         * @memberof immessage.UploadLogStatusReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UploadLogStatusReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.UploadLogStatusReq";
        };

        return UploadLogStatusReq;
    })();

    immessage.SubMsgs = (function() {

        /**
         * Properties of a SubMsgs.
         * @memberof immessage
         * @interface ISubMsgs
         * @property {Array.<immessage.ISubMsg>|null} [subMsgs] SubMsgs subMsgs
         */

        /**
         * Constructs a new SubMsgs.
         * @memberof immessage
         * @classdesc Represents a SubMsgs.
         * @implements ISubMsgs
         * @constructor
         * @param {immessage.ISubMsgs=} [properties] Properties to set
         */
        function SubMsgs(properties) {
            this.subMsgs = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubMsgs subMsgs.
         * @member {Array.<immessage.ISubMsg>} subMsgs
         * @memberof immessage.SubMsgs
         * @instance
         */
        SubMsgs.prototype.subMsgs = $util.emptyArray;

        /**
         * Creates a new SubMsgs instance using the specified properties.
         * @function create
         * @memberof immessage.SubMsgs
         * @static
         * @param {immessage.ISubMsgs=} [properties] Properties to set
         * @returns {immessage.SubMsgs} SubMsgs instance
         */
        SubMsgs.create = function create(properties) {
            return new SubMsgs(properties);
        };

        /**
         * Encodes the specified SubMsgs message. Does not implicitly {@link immessage.SubMsgs.verify|verify} messages.
         * @function encode
         * @memberof immessage.SubMsgs
         * @static
         * @param {immessage.ISubMsgs} message SubMsgs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubMsgs.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.subMsgs != null && message.subMsgs.length)
                for (let i = 0; i < message.subMsgs.length; ++i)
                    $root.immessage.SubMsg.encode(message.subMsgs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SubMsgs message, length delimited. Does not implicitly {@link immessage.SubMsgs.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.SubMsgs
         * @static
         * @param {immessage.ISubMsgs} message SubMsgs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubMsgs.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubMsgs message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.SubMsgs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.SubMsgs} SubMsgs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubMsgs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.SubMsgs();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.subMsgs && message.subMsgs.length))
                            message.subMsgs = [];
                        message.subMsgs.push($root.immessage.SubMsg.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubMsgs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.SubMsgs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.SubMsgs} SubMsgs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubMsgs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubMsgs message.
         * @function verify
         * @memberof immessage.SubMsgs
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubMsgs.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.subMsgs != null && message.hasOwnProperty("subMsgs")) {
                if (!Array.isArray(message.subMsgs))
                    return "subMsgs: array expected";
                for (let i = 0; i < message.subMsgs.length; ++i) {
                    let error = $root.immessage.SubMsg.verify(message.subMsgs[i]);
                    if (error)
                        return "subMsgs." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SubMsgs message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.SubMsgs
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.SubMsgs} SubMsgs
         */
        SubMsgs.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.SubMsgs)
                return object;
            let message = new $root.immessage.SubMsgs();
            if (object.subMsgs) {
                if (!Array.isArray(object.subMsgs))
                    throw TypeError(".immessage.SubMsgs.subMsgs: array expected");
                message.subMsgs = [];
                for (let i = 0; i < object.subMsgs.length; ++i) {
                    if (typeof object.subMsgs[i] !== "object")
                        throw TypeError(".immessage.SubMsgs.subMsgs: object expected");
                    message.subMsgs[i] = $root.immessage.SubMsg.fromObject(object.subMsgs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SubMsgs message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.SubMsgs
         * @static
         * @param {immessage.SubMsgs} message SubMsgs
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubMsgs.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.subMsgs = [];
            if (message.subMsgs && message.subMsgs.length) {
                object.subMsgs = [];
                for (let j = 0; j < message.subMsgs.length; ++j)
                    object.subMsgs[j] = $root.immessage.SubMsg.toObject(message.subMsgs[j], options);
            }
            return object;
        };

        /**
         * Converts this SubMsgs to JSON.
         * @function toJSON
         * @memberof immessage.SubMsgs
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubMsgs.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubMsgs
         * @function getTypeUrl
         * @memberof immessage.SubMsgs
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubMsgs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.SubMsgs";
        };

        return SubMsgs;
    })();

    immessage.SubMsg = (function() {

        /**
         * Properties of a SubMsg.
         * @memberof immessage
         * @interface ISubMsg
         * @property {immessage.IDownMsg|null} [msg] SubMsg msg
         * @property {string|null} [platform] SubMsg platform
         */

        /**
         * Constructs a new SubMsg.
         * @memberof immessage
         * @classdesc Represents a SubMsg.
         * @implements ISubMsg
         * @constructor
         * @param {immessage.ISubMsg=} [properties] Properties to set
         */
        function SubMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubMsg msg.
         * @member {immessage.IDownMsg|null|undefined} msg
         * @memberof immessage.SubMsg
         * @instance
         */
        SubMsg.prototype.msg = null;

        /**
         * SubMsg platform.
         * @member {string} platform
         * @memberof immessage.SubMsg
         * @instance
         */
        SubMsg.prototype.platform = "";

        /**
         * Creates a new SubMsg instance using the specified properties.
         * @function create
         * @memberof immessage.SubMsg
         * @static
         * @param {immessage.ISubMsg=} [properties] Properties to set
         * @returns {immessage.SubMsg} SubMsg instance
         */
        SubMsg.create = function create(properties) {
            return new SubMsg(properties);
        };

        /**
         * Encodes the specified SubMsg message. Does not implicitly {@link immessage.SubMsg.verify|verify} messages.
         * @function encode
         * @memberof immessage.SubMsg
         * @static
         * @param {immessage.ISubMsg} message SubMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                $root.immessage.DownMsg.encode(message.msg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.platform);
            return writer;
        };

        /**
         * Encodes the specified SubMsg message, length delimited. Does not implicitly {@link immessage.SubMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.SubMsg
         * @static
         * @param {immessage.ISubMsg} message SubMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubMsg message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.SubMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.SubMsg} SubMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.SubMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.msg = $root.immessage.DownMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.platform = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.SubMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.SubMsg} SubMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubMsg message.
         * @function verify
         * @memberof immessage.SubMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msg != null && message.hasOwnProperty("msg")) {
                let error = $root.immessage.DownMsg.verify(message.msg);
                if (error)
                    return "msg." + error;
            }
            if (message.platform != null && message.hasOwnProperty("platform"))
                if (!$util.isString(message.platform))
                    return "platform: string expected";
            return null;
        };

        /**
         * Creates a SubMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.SubMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.SubMsg} SubMsg
         */
        SubMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.SubMsg)
                return object;
            let message = new $root.immessage.SubMsg();
            if (object.msg != null) {
                if (typeof object.msg !== "object")
                    throw TypeError(".immessage.SubMsg.msg: object expected");
                message.msg = $root.immessage.DownMsg.fromObject(object.msg);
            }
            if (object.platform != null)
                message.platform = String(object.platform);
            return message;
        };

        /**
         * Creates a plain object from a SubMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.SubMsg
         * @static
         * @param {immessage.SubMsg} message SubMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.msg = null;
                object.platform = "";
            }
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = $root.immessage.DownMsg.toObject(message.msg, options);
            if (message.platform != null && message.hasOwnProperty("platform"))
                object.platform = message.platform;
            return object;
        };

        /**
         * Converts this SubMsg to JSON.
         * @function toJSON
         * @memberof immessage.SubMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubMsg
         * @function getTypeUrl
         * @memberof immessage.SubMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.SubMsg";
        };

        return SubMsg;
    })();

    immessage.OnlineOfflineMsg = (function() {

        /**
         * Properties of an OnlineOfflineMsg.
         * @memberof immessage
         * @interface IOnlineOfflineMsg
         * @property {immessage.OnlineType|null} [type] OnlineOfflineMsg type
         * @property {string|null} [userId] OnlineOfflineMsg userId
         * @property {string|null} [deviceId] OnlineOfflineMsg deviceId
         * @property {string|null} [platform] OnlineOfflineMsg platform
         * @property {string|null} [clientIp] OnlineOfflineMsg clientIp
         * @property {string|null} [sessionId] OnlineOfflineMsg sessionId
         * @property {number|Long|null} [timestamp] OnlineOfflineMsg timestamp
         * @property {string|null} [connectionExt] OnlineOfflineMsg connectionExt
         * @property {string|null} [instanceId] OnlineOfflineMsg instanceId
         */

        /**
         * Constructs a new OnlineOfflineMsg.
         * @memberof immessage
         * @classdesc Represents an OnlineOfflineMsg.
         * @implements IOnlineOfflineMsg
         * @constructor
         * @param {immessage.IOnlineOfflineMsg=} [properties] Properties to set
         */
        function OnlineOfflineMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OnlineOfflineMsg type.
         * @member {immessage.OnlineType} type
         * @memberof immessage.OnlineOfflineMsg
         * @instance
         */
        OnlineOfflineMsg.prototype.type = 0;

        /**
         * OnlineOfflineMsg userId.
         * @member {string} userId
         * @memberof immessage.OnlineOfflineMsg
         * @instance
         */
        OnlineOfflineMsg.prototype.userId = "";

        /**
         * OnlineOfflineMsg deviceId.
         * @member {string} deviceId
         * @memberof immessage.OnlineOfflineMsg
         * @instance
         */
        OnlineOfflineMsg.prototype.deviceId = "";

        /**
         * OnlineOfflineMsg platform.
         * @member {string} platform
         * @memberof immessage.OnlineOfflineMsg
         * @instance
         */
        OnlineOfflineMsg.prototype.platform = "";

        /**
         * OnlineOfflineMsg clientIp.
         * @member {string} clientIp
         * @memberof immessage.OnlineOfflineMsg
         * @instance
         */
        OnlineOfflineMsg.prototype.clientIp = "";

        /**
         * OnlineOfflineMsg sessionId.
         * @member {string} sessionId
         * @memberof immessage.OnlineOfflineMsg
         * @instance
         */
        OnlineOfflineMsg.prototype.sessionId = "";

        /**
         * OnlineOfflineMsg timestamp.
         * @member {number|Long} timestamp
         * @memberof immessage.OnlineOfflineMsg
         * @instance
         */
        OnlineOfflineMsg.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OnlineOfflineMsg connectionExt.
         * @member {string} connectionExt
         * @memberof immessage.OnlineOfflineMsg
         * @instance
         */
        OnlineOfflineMsg.prototype.connectionExt = "";

        /**
         * OnlineOfflineMsg instanceId.
         * @member {string} instanceId
         * @memberof immessage.OnlineOfflineMsg
         * @instance
         */
        OnlineOfflineMsg.prototype.instanceId = "";

        /**
         * Creates a new OnlineOfflineMsg instance using the specified properties.
         * @function create
         * @memberof immessage.OnlineOfflineMsg
         * @static
         * @param {immessage.IOnlineOfflineMsg=} [properties] Properties to set
         * @returns {immessage.OnlineOfflineMsg} OnlineOfflineMsg instance
         */
        OnlineOfflineMsg.create = function create(properties) {
            return new OnlineOfflineMsg(properties);
        };

        /**
         * Encodes the specified OnlineOfflineMsg message. Does not implicitly {@link immessage.OnlineOfflineMsg.verify|verify} messages.
         * @function encode
         * @memberof immessage.OnlineOfflineMsg
         * @static
         * @param {immessage.IOnlineOfflineMsg} message OnlineOfflineMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OnlineOfflineMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.userId);
            if (message.deviceId != null && Object.hasOwnProperty.call(message, "deviceId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.deviceId);
            if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.platform);
            if (message.clientIp != null && Object.hasOwnProperty.call(message, "clientIp"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.clientIp);
            if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.sessionId);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
            if (message.connectionExt != null && Object.hasOwnProperty.call(message, "connectionExt"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.connectionExt);
            if (message.instanceId != null && Object.hasOwnProperty.call(message, "instanceId"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.instanceId);
            return writer;
        };

        /**
         * Encodes the specified OnlineOfflineMsg message, length delimited. Does not implicitly {@link immessage.OnlineOfflineMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.OnlineOfflineMsg
         * @static
         * @param {immessage.IOnlineOfflineMsg} message OnlineOfflineMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OnlineOfflineMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OnlineOfflineMsg message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.OnlineOfflineMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.OnlineOfflineMsg} OnlineOfflineMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OnlineOfflineMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.OnlineOfflineMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.userId = reader.string();
                        break;
                    }
                case 3: {
                        message.deviceId = reader.string();
                        break;
                    }
                case 4: {
                        message.platform = reader.string();
                        break;
                    }
                case 5: {
                        message.clientIp = reader.string();
                        break;
                    }
                case 6: {
                        message.sessionId = reader.string();
                        break;
                    }
                case 7: {
                        message.timestamp = reader.int64();
                        break;
                    }
                case 8: {
                        message.connectionExt = reader.string();
                        break;
                    }
                case 9: {
                        message.instanceId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OnlineOfflineMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.OnlineOfflineMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.OnlineOfflineMsg} OnlineOfflineMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OnlineOfflineMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OnlineOfflineMsg message.
         * @function verify
         * @memberof immessage.OnlineOfflineMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OnlineOfflineMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (!$util.isString(message.deviceId))
                    return "deviceId: string expected";
            if (message.platform != null && message.hasOwnProperty("platform"))
                if (!$util.isString(message.platform))
                    return "platform: string expected";
            if (message.clientIp != null && message.hasOwnProperty("clientIp"))
                if (!$util.isString(message.clientIp))
                    return "clientIp: string expected";
            if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                if (!$util.isString(message.sessionId))
                    return "sessionId: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.connectionExt != null && message.hasOwnProperty("connectionExt"))
                if (!$util.isString(message.connectionExt))
                    return "connectionExt: string expected";
            if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                if (!$util.isString(message.instanceId))
                    return "instanceId: string expected";
            return null;
        };

        /**
         * Creates an OnlineOfflineMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.OnlineOfflineMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.OnlineOfflineMsg} OnlineOfflineMsg
         */
        OnlineOfflineMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.OnlineOfflineMsg)
                return object;
            let message = new $root.immessage.OnlineOfflineMsg();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "Offline":
            case 0:
                message.type = 0;
                break;
            case "Online":
            case 1:
                message.type = 1;
                break;
            }
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.deviceId != null)
                message.deviceId = String(object.deviceId);
            if (object.platform != null)
                message.platform = String(object.platform);
            if (object.clientIp != null)
                message.clientIp = String(object.clientIp);
            if (object.sessionId != null)
                message.sessionId = String(object.sessionId);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.connectionExt != null)
                message.connectionExt = String(object.connectionExt);
            if (object.instanceId != null)
                message.instanceId = String(object.instanceId);
            return message;
        };

        /**
         * Creates a plain object from an OnlineOfflineMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.OnlineOfflineMsg
         * @static
         * @param {immessage.OnlineOfflineMsg} message OnlineOfflineMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OnlineOfflineMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "Offline" : 0;
                object.userId = "";
                object.deviceId = "";
                object.platform = "";
                object.clientIp = "";
                object.sessionId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.connectionExt = "";
                object.instanceId = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.immessage.OnlineType[message.type] === undefined ? message.type : $root.immessage.OnlineType[message.type] : message.type;
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                object.deviceId = message.deviceId;
            if (message.platform != null && message.hasOwnProperty("platform"))
                object.platform = message.platform;
            if (message.clientIp != null && message.hasOwnProperty("clientIp"))
                object.clientIp = message.clientIp;
            if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                object.sessionId = message.sessionId;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.connectionExt != null && message.hasOwnProperty("connectionExt"))
                object.connectionExt = message.connectionExt;
            if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                object.instanceId = message.instanceId;
            return object;
        };

        /**
         * Converts this OnlineOfflineMsg to JSON.
         * @function toJSON
         * @memberof immessage.OnlineOfflineMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OnlineOfflineMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OnlineOfflineMsg
         * @function getTypeUrl
         * @memberof immessage.OnlineOfflineMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OnlineOfflineMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.OnlineOfflineMsg";
        };

        return OnlineOfflineMsg;
    })();

    immessage.TransReq = (function() {

        /**
         * Properties of a TransReq.
         * @memberof immessage
         * @interface ITransReq
         * @property {Array.<immessage.ITransItem>|null} [items] TransReq items
         * @property {string|null} [targetLang] TransReq targetLang
         * @property {string|null} [sourceLang] TransReq sourceLang
         */

        /**
         * Constructs a new TransReq.
         * @memberof immessage
         * @classdesc Represents a TransReq.
         * @implements ITransReq
         * @constructor
         * @param {immessage.ITransReq=} [properties] Properties to set
         */
        function TransReq(properties) {
            this.items = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransReq items.
         * @member {Array.<immessage.ITransItem>} items
         * @memberof immessage.TransReq
         * @instance
         */
        TransReq.prototype.items = $util.emptyArray;

        /**
         * TransReq targetLang.
         * @member {string} targetLang
         * @memberof immessage.TransReq
         * @instance
         */
        TransReq.prototype.targetLang = "";

        /**
         * TransReq sourceLang.
         * @member {string} sourceLang
         * @memberof immessage.TransReq
         * @instance
         */
        TransReq.prototype.sourceLang = "";

        /**
         * Creates a new TransReq instance using the specified properties.
         * @function create
         * @memberof immessage.TransReq
         * @static
         * @param {immessage.ITransReq=} [properties] Properties to set
         * @returns {immessage.TransReq} TransReq instance
         */
        TransReq.create = function create(properties) {
            return new TransReq(properties);
        };

        /**
         * Encodes the specified TransReq message. Does not implicitly {@link immessage.TransReq.verify|verify} messages.
         * @function encode
         * @memberof immessage.TransReq
         * @static
         * @param {immessage.ITransReq} message TransReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (let i = 0; i < message.items.length; ++i)
                    $root.immessage.TransItem.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.targetLang != null && Object.hasOwnProperty.call(message, "targetLang"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetLang);
            if (message.sourceLang != null && Object.hasOwnProperty.call(message, "sourceLang"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.sourceLang);
            return writer;
        };

        /**
         * Encodes the specified TransReq message, length delimited. Does not implicitly {@link immessage.TransReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.TransReq
         * @static
         * @param {immessage.ITransReq} message TransReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransReq message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.TransReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.TransReq} TransReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.TransReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.immessage.TransItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.targetLang = reader.string();
                        break;
                    }
                case 3: {
                        message.sourceLang = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.TransReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.TransReq} TransReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransReq message.
         * @function verify
         * @memberof immessage.TransReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (let i = 0; i < message.items.length; ++i) {
                    let error = $root.immessage.TransItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.targetLang != null && message.hasOwnProperty("targetLang"))
                if (!$util.isString(message.targetLang))
                    return "targetLang: string expected";
            if (message.sourceLang != null && message.hasOwnProperty("sourceLang"))
                if (!$util.isString(message.sourceLang))
                    return "sourceLang: string expected";
            return null;
        };

        /**
         * Creates a TransReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.TransReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.TransReq} TransReq
         */
        TransReq.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.TransReq)
                return object;
            let message = new $root.immessage.TransReq();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".immessage.TransReq.items: array expected");
                message.items = [];
                for (let i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".immessage.TransReq.items: object expected");
                    message.items[i] = $root.immessage.TransItem.fromObject(object.items[i]);
                }
            }
            if (object.targetLang != null)
                message.targetLang = String(object.targetLang);
            if (object.sourceLang != null)
                message.sourceLang = String(object.sourceLang);
            return message;
        };

        /**
         * Creates a plain object from a TransReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.TransReq
         * @static
         * @param {immessage.TransReq} message TransReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults) {
                object.targetLang = "";
                object.sourceLang = "";
            }
            if (message.items && message.items.length) {
                object.items = [];
                for (let j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.immessage.TransItem.toObject(message.items[j], options);
            }
            if (message.targetLang != null && message.hasOwnProperty("targetLang"))
                object.targetLang = message.targetLang;
            if (message.sourceLang != null && message.hasOwnProperty("sourceLang"))
                object.sourceLang = message.sourceLang;
            return object;
        };

        /**
         * Converts this TransReq to JSON.
         * @function toJSON
         * @memberof immessage.TransReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TransReq
         * @function getTypeUrl
         * @memberof immessage.TransReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.TransReq";
        };

        return TransReq;
    })();

    immessage.TransItem = (function() {

        /**
         * Properties of a TransItem.
         * @memberof immessage
         * @interface ITransItem
         * @property {string|null} [key] TransItem key
         * @property {string|null} [content] TransItem content
         */

        /**
         * Constructs a new TransItem.
         * @memberof immessage
         * @classdesc Represents a TransItem.
         * @implements ITransItem
         * @constructor
         * @param {immessage.ITransItem=} [properties] Properties to set
         */
        function TransItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransItem key.
         * @member {string} key
         * @memberof immessage.TransItem
         * @instance
         */
        TransItem.prototype.key = "";

        /**
         * TransItem content.
         * @member {string} content
         * @memberof immessage.TransItem
         * @instance
         */
        TransItem.prototype.content = "";

        /**
         * Creates a new TransItem instance using the specified properties.
         * @function create
         * @memberof immessage.TransItem
         * @static
         * @param {immessage.ITransItem=} [properties] Properties to set
         * @returns {immessage.TransItem} TransItem instance
         */
        TransItem.create = function create(properties) {
            return new TransItem(properties);
        };

        /**
         * Encodes the specified TransItem message. Does not implicitly {@link immessage.TransItem.verify|verify} messages.
         * @function encode
         * @memberof immessage.TransItem
         * @static
         * @param {immessage.ITransItem} message TransItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.content);
            return writer;
        };

        /**
         * Encodes the specified TransItem message, length delimited. Does not implicitly {@link immessage.TransItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof immessage.TransItem
         * @static
         * @param {immessage.ITransItem} message TransItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransItem message from the specified reader or buffer.
         * @function decode
         * @memberof immessage.TransItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {immessage.TransItem} TransItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immessage.TransItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.key = reader.string();
                        break;
                    }
                case 2: {
                        message.content = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof immessage.TransItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {immessage.TransItem} TransItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransItem message.
         * @function verify
         * @memberof immessage.TransItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            return null;
        };

        /**
         * Creates a TransItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof immessage.TransItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {immessage.TransItem} TransItem
         */
        TransItem.fromObject = function fromObject(object) {
            if (object instanceof $root.immessage.TransItem)
                return object;
            let message = new $root.immessage.TransItem();
            if (object.key != null)
                message.key = String(object.key);
            if (object.content != null)
                message.content = String(object.content);
            return message;
        };

        /**
         * Creates a plain object from a TransItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof immessage.TransItem
         * @static
         * @param {immessage.TransItem} message TransItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.key = "";
                object.content = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            return object;
        };

        /**
         * Converts this TransItem to JSON.
         * @function toJSON
         * @memberof immessage.TransItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TransItem
         * @function getTypeUrl
         * @memberof immessage.TransItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TransItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/immessage.TransItem";
        };

        return TransItem;
    })();

    return immessage;
})();

export { $root as default };
